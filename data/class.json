{"id": 263287, "class_signatures": "public final class CmisHttpCookie implements Cloneable, Serializable", "class_methods": [{"signature": "public CmisHttpCookie(String name, String value)", "full": "public CmisHttpCookie(String name, String value) {\n        String ntrim = name.trim(); if (!isValidName(ntrim)) {\n            throw new IllegalArgumentException(\"Invalid name!\");\n        }\n\n        this.name = ntrim;\n        this.value = value;\n    }"}, {"signature": "public static boolean domainMatches(String domain, String host)", "full": "public static boolean domainMatches(String domain, String host) {\n        if (domain == null || host == null) {\n            return false;\n        }\n        String newDomain = domain.toLowerCase(Locale.ENGLISH);\n        String newHost = host.toLowerCase(Locale.ENGLISH);\n\n        return newDomain.equals(newHost)\n                || (isValidDomain(newDomain) && effDomainMatches(newDomain, newHost) && isValidHost(newDomain, newHost));\n    }"}, {"signature": "private static boolean effDomainMatches(String domain, String host)", "full": "private static boolean effDomainMatches(String domain, String host) {\n        String effHost = host.indexOf(DOT_STR) != -1 ? host : (host + LOCAL_STR);\n\n        boolean inDomain = domain.equals(effHost);\n        inDomain = inDomain\n                || (effHost.endsWith(domain) && effHost.length() > domain.length() && domain.startsWith(DOT_STR));\n\n        return inDomain;\n    }"}, {"signature": "private static boolean isCommaDelim(CmisHttpCookie cookie)", "full": "private static boolean isCommaDelim(CmisHttpCookie cookie) {\n        String value = cookie.getValue();\n        if (value.startsWith(QUOTE_STR) && value.endsWith(QUOTE_STR)) {\n            cookie.setValue(value.substring(1, value.length() - 1));\n            return false;\n        }\n\n        if (cookie.getVersion() == 1 && value.contains(COMMA_STR)) {\n            cookie.setValue(value.substring(0, value.indexOf(COMMA_STR)));\n            return true;\n        }\n\n        return false;\n    }"}, {"signature": "private static boolean isValidDomain(String domain)", "full": "private static boolean isValidDomain(String domain) {\n        if (domain.length() <= 2) {\n            return false;\n        }\n\n        return domain.substring(1, domain.length() - 1).indexOf(DOT_STR) != -1 || domain.equals(LOCAL_STR);\n    }"}, {"signature": "private static boolean isValidHost(String domain, String host)", "full": "private static boolean isValidHost(String domain, String host) {\n        boolean matches = !host.endsWith(domain);\n        if (!matches) {\n            String hostSub = host.substring(0, host.length() - domain.length());\n            matches = hostSub.indexOf(DOT_STR) == -1;\n        }\n\n        return matches;\n    }"}, {"signature": "public static List<CmisHttpCookie> parse(String header)", "full": "public static List<CmisHttpCookie> parse(String header) {\n        Matcher matcher = HEAD_PATTERN.matcher(header);\n        List<CmisHttpCookie> list = null;\n        CmisHttpCookie cookie = null;\n        String headerString = header;\n        int version = 0;\n        if (matcher.find()) {\n            String cookieHead = matcher.group();\n            if (\"set-cookie2:\".equalsIgnoreCase(cookieHead)) {\n                version = 1;\n            }\n            headerString = header.substring(cookieHead.length());\n        }\n\n        matcher = NAME_PATTERN.matcher(headerString);\n        if (matcher.lookingAt()) {\n            list = new ArrayList<CmisHttpCookie>();\n            cookie = new CmisHttpCookie(matcher.group(1), matcher.group(2));\n            cookie.setVersion(version);\n\n            String nameGroup = matcher.group();\n            if (isCommaDelim(cookie)) {\n                headerString = headerString.substring(nameGroup.indexOf(COMMA_STR));\n            } else {\n                headerString = headerString.substring(nameGroup.length());\n            }\n            list.add(cookie);\n        } else {\n            throw new IllegalArgumentException();\n        }\n\n        while (!(headerString.length() == 0)) {\n            matcher = cookie.getVersion() == 1 ? ATTR_PATTERN1.matcher(headerString) : ATTR_PATTERN0\n                    .matcher(headerString);\n\n            if (matcher.lookingAt()) {\n                String attrName = matcher.group(1).trim();\n\n                if (attrName.length() == 0) {\n                    headerString = headerString.substring(1);\n                    continue;\n                }\n\n                if (attrName.equalsIgnoreCase(\"port\") || attrName.equalsIgnoreCase(\"expires\")) {\n                    int start = matcher.regionStart();\n                    matcher = ATTR_PATTERN0.matcher(headerString);\n                    matcher.region(start, headerString.length());\n                    matcher.lookingAt();\n                } else if (cookie.getVersion() == 1 && attrName.startsWith(COMMA_STR)) {\n                    headerString = headerString.substring(1);\n                    matcher = NAME_PATTERN.matcher(headerString);\n                    if (matcher.lookingAt()) {\n                        cookie = new CmisHttpCookie(matcher.group(1), matcher.group(2));\n                        list.add(cookie);\n                        headerString = headerString.substring(matcher.group().length());\n                        continue;\n                    }\n                }\n\n                Setter setter = cookie.attributeSet.get(attrName.toLowerCase(Locale.ENGLISH));\n                if (setter != null && !setter.isSet()) {\n                    String attrValue = matcher.group(2);\n                    setter.validate(attrValue, cookie);\n                    setter.setValue(matcher.group(2), cookie);\n                }\n                headerString = headerString.substring(matcher.end());\n            }\n        }\n\n        return list;\n    }"}, {"signature": "private void attrToString(StringBuilder builder, String attrName, String attrValue)", "full": "private void attrToString(StringBuilder builder, String attrName, String attrValue) {\n        if (attrValue != null && builder != null) {\n            builder.append(';');\n            builder.append('$');\n            builder.append(attrName);\n            builder.append(\"=\\\"\");\n            builder.append(attrValue);\n            builder.append(QUOTE_STR);\n        }\n    }"}, {"signature": "public Object clone()", "full": "@Override\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }"}, {"signature": "public boolean equals(Object obj)", "full": "@Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof CmisHttpCookie) {\n            CmisHttpCookie anotherCookie = (CmisHttpCookie) obj;\n            if (name.equalsIgnoreCase(anotherCookie.getName())) {\n                String anotherDomain = anotherCookie.getDomain();\n                boolean equals = domain == null ? anotherDomain == null : domain.equalsIgnoreCase(anotherDomain);\n                if (equals) {\n                    String anotherPath = anotherCookie.getPath();\n                    return path == null ? anotherPath == null : path.equals(anotherPath);\n                }\n            }\n        }\n        return false;\n    }"}, {"signature": "public String getComment()", "full": "public String getComment() {\n        return comment;\n    }"}, {"signature": "public String getCommentURL()", "full": "public String getCommentURL() {\n        return commentURL;\n    }"}, {"signature": "public boolean getDiscard()", "full": "public boolean getDiscard() {\n        return discard;\n    }"}, {"signature": "public String getDomain()", "full": "public String getDomain() {\n        return domain;\n    }"}, {"signature": "public long getMaxAge()", "full": "public long getMaxAge() {\n        return maxAge;\n    }"}, {"signature": "public String getName()", "full": "public String getName() {\n        return name;\n    }"}, {"signature": "public String getPath()", "full": "public String getPath() {\n        return path;\n    }"}, {"signature": "public String getPortlist()", "full": "public String getPortlist() {\n        return portList;\n    }"}, {"signature": "public boolean getSecure()", "full": "public boolean getSecure() {\n        return secure;\n    }"}, {"signature": "public String getValue()", "full": "public String getValue() {\n        return value;\n    }"}, {"signature": "public int getVersion()", "full": "public int getVersion() {\n        return version;\n    }"}, {"signature": "public boolean hasExpired()", "full": "public boolean hasExpired() {\n        if (maxAge == -1L) {\n            return false;\n        }\n\n        boolean expired = false;\n        if (maxAge <= 0L) {\n            expired = true;\n        }\n        return expired;\n    }"}, {"signature": "public int hashCode()", "full": "@Override\n    public int hashCode() {\n        int hashCode = name.toLowerCase(Locale.ENGLISH).hashCode();\n        hashCode += domain == null ? 0 : domain.toLowerCase(Locale.ENGLISH).hashCode();\n        hashCode += path == null ? 0 : path.hashCode();\n        return hashCode;\n    }"}, {"signature": "private boolean isValidName(String n)", "full": "private boolean isValidName(String n) {\n        boolean isValid = !(n.length() == 0 || n.charAt(0) == '$' || attributeSet.containsKey(n\n                .toLowerCase(Locale.ENGLISH)));\n        if (isValid) {\n            for (int i = 0; i < n.length(); i++) {\n                char nameChar = n.charAt(i);\n                if (nameChar < 0 || nameChar >= 127 || nameChar == ';' || nameChar == ','\n                        || (Character.isWhitespace(nameChar) && nameChar != ' ')) {\n                    isValid = false;\n                    break;\n                }\n            }\n        }\n\n        return isValid;\n    }"}, {"signature": "public void setComment(String purpose)", "full": "public void setComment(String purpose) {\n        comment = purpose;\n    }"}, {"signature": "public void setCommentURL(String purpose)", "full": "public void setCommentURL(String purpose) {\n        commentURL = purpose;\n    }"}, {"signature": "public void setDiscard(boolean discard)", "full": "public void setDiscard(boolean discard) {\n        this.discard = discard;\n    }"}, {"signature": "public void setDomain(String pattern)", "full": "public void setDomain(String pattern) {\n        domain = pattern == null ? null : pattern.toLowerCase(Locale.ENGLISH);\n    }"}, {"signature": "public void setMaxAge(long expiry)", "full": "public void setMaxAge(long expiry) {\n        maxAge = expiry;\n    }"}, {"signature": "public void setPath(String path)", "full": "public void setPath(String path) {\n        this.path = path;\n    }"}, {"signature": "public void setPortlist(String ports)", "full": "public void setPortlist(String ports) {\n        portList = ports;\n    }"}, {"signature": "public void setSecure(boolean flag)", "full": "public void setSecure(boolean flag) {\n        secure = flag;\n    }"}, {"signature": "public void setValue(String newValue)", "full": "public void setValue(String newValue) {\n        value = newValue;\n    }"}, {"signature": "public void setVersion(int v)", "full": "public void setVersion(int v) {\n        if (v != 0 && v != 1) {\n            throw new IllegalArgumentException(\"Unknown version!\");\n        }\n        version = v;\n    }"}, {"signature": "public String toString() \n}", "full": "@Override\n    public String toString() {\n        StringBuilder cookieStr = new StringBuilder(128);\n        cookieStr.append(name);\n        cookieStr.append('=');\n        if (version == 0) {\n            cookieStr.append(value);\n        } else if (version == 1) {\n            cookieStr.append(QUOTE_STR);\n            cookieStr.append(value);\n            cookieStr.append(QUOTE_STR);\n\n            attrToString(cookieStr, \"Path\", path);\n            attrToString(cookieStr, \"Domain\", domain);\n            attrToString(cookieStr, \"Port\", portList);\n        }\n\n        return cookieStr.toString();\n    }\n}"}], "class_attributes": [{"type": "long", "name": "serialVersionUID"}, {"type": "String", "name": "DOT_STR"}, {"type": "String", "name": "LOCAL_STR"}, {"type": "String", "name": "QUOTE_STR"}, {"type": "String", "name": "COMMA_STR"}, {"type": "Pattern", "name": "HEAD_PATTERN"}, {"type": "Pattern", "name": "NAME_PATTERN"}, {"type": "Pattern", "name": "ATTR_PATTERN0"}, {"type": "Pattern", "name": "ATTR_PATTERN1"}, {"type": "Map", "name": "attributeSet"}, {"type": "String", "name": "comment"}, {"type": "String", "name": "commentURL"}, {"type": "boolean", "name": "discard"}, {"type": "String", "name": "domain"}, {"type": "long", "name": "maxAge"}, {"type": "String", "name": "name"}, {"type": "String", "name": "path"}, {"type": "String", "name": "portList"}, {"type": "boolean", "name": "secure"}, {"type": "String", "name": "value"}, {"type": "int", "name": "version"}]}
{"id": 400908, "class_signatures": "public class PieData extends ChartData<IPieDataSet>", "class_methods": [{"signature": "public PieData()", "full": "public PieData() {\n        super();\n    }"}, {"signature": "public PieData(IPieDataSet dataSet)", "full": "public PieData(IPieDataSet dataSet) {\n        super(dataSet);\n    }"}, {"signature": "public void setDataSet(IPieDataSet dataSet)", "full": "public void setDataSet(IPieDataSet dataSet) {\n        mDataSets.clear();\n        mDataSets.add(dataSet);\n        notifyDataChanged();\n    }"}, {"signature": "public IPieDataSet getDataSet()", "full": "public IPieDataSet getDataSet() {\n        return mDataSets.get(0);\n    }"}, {"signature": "public IPieDataSet getDataSetByIndex(int index)", "full": "@Override\n    public IPieDataSet getDataSetByIndex(int index) {\n        return index == 0 ? getDataSet() : null;\n    }"}, {"signature": "public IPieDataSet getDataSetByLabel(String label, boolean ignorecase)", "full": "@Override\n    public IPieDataSet getDataSetByLabel(String label, boolean ignorecase) {\n        return ignorecase ? label.equalsIgnoreCase(mDataSets.get(0).getLabel()) ? mDataSets.get(0)\n                : null : label.equals(mDataSets.get(0).getLabel()) ? mDataSets.get(0) : null;\n    }"}, {"signature": "public Entry getEntryForHighlight(Highlight highlight)", "full": "@Override\n    public Entry getEntryForHighlight(Highlight highlight) {\n        return getDataSet().getEntryForIndex((int) highlight.getX());\n    }"}, {"signature": "public float getYValueSum() \n}", "full": "public float getYValueSum() {\n\n        float sum = 0;\n\n        for (int i = 0; i < getDataSet().getEntryCount(); i++)\n            sum += getDataSet().getEntryForIndex(i).getY();\n\n\n        return sum;\n    }\n}"}], "class_attributes": []}
{"id": 400883, "class_signatures": "public class BagService extends StatusProvider", "class_methods": [{"signature": "public BagService(BagRepository bagRepository, BagPositionRepository myBagPositionRepository,\n                      MessageTypeRepository myMTRepository, TopicRepository myTopicRepository,\n                      TagRepository myTagRepository, ConfigService myConfigService, GeocodingService myGeocodingService,\n                      ScriptService myScriptService, ApplicationContext applicationContext)", "full": "public BagService(BagRepository bagRepository, BagPositionRepository myBagPositionRepository,\n                      MessageTypeRepository myMTRepository, TopicRepository myTopicRepository,\n                      TagRepository myTagRepository, ConfigService myConfigService, GeocodingService myGeocodingService,\n                      ScriptService myScriptService, ApplicationContext applicationContext) {\n        this.myBagRepository = bagRepository;\n        this.myBagPositionRepository = myBagPositionRepository;\n        this.myMTRepository = myMTRepository;\n        this.myTopicRepository = myTopicRepository;\n        this.myTagRepository = myTagRepository;\n        this.myConfigService = myConfigService;\n        this.myGeocodingService = myGeocodingService;\n        this.myScriptService = myScriptService;\n\n        List<BagStorageConfiguration> storageConfigs;\n\n        if (myConfigService != null && myConfigService.getConfiguration() != null) {\n            storageConfigs = myConfigService.getConfiguration().getStorageConfigurations();\n        }\n        else {\n            storageConfigs = new ArrayList<>();\n        }\n\n        if (storageConfigs.isEmpty()) {\n            myLogger.info(\"No storage configs explicitly defined; creating default filesystem storage.\");\n            FilesystemBagStorageConfigImpl fsConfig = new FilesystemBagStorageConfigImpl();\n            if (myConfigService != null && myConfigService.getConfiguration() != null) {\n                fsConfig.basePath = myConfigService.getConfiguration().getBagPath();\n                fsConfig.dockerPath = \"/bags\";\n            }\n            fsConfig.storageId = \"default\";\n            storageConfigs.add(fsConfig);\n        }\n\n        for (BagStorageConfiguration config : storageConfigs) {\n            try {\n                BagStorage storage;\n                if (config instanceof FilesystemBagStorageConfigImpl) {\n                    myLogger.info(\"Creating FilesystemBagStorageImpl.\");\n                    storage = applicationContext.getBean(FilesystemBagStorageImpl.class);\n                    storage.setBagService(this);\n                }\n                else if (config instanceof S3BagStorageConfigImpl) {\n                    myLogger.info(\"Creating S3BagStorageImpl.\");\n                    storage = applicationContext.getBean(S3BagStorageImpl.class);\n                    storage.setBagService(this);\n                }\n                else {\n                    myLogger.warn(\"Unexpected storage config type: \" + config.getClass().toString());\n                    continue;\n                }\n                storage.loadConfig(config);\n                myBagStorages.put(storage.getStorageId(), storage);\n                storage.start();\n            }\n            catch (BagStorageConfigException e) {\n                myLogger.error(\"Error configuring BagStorage\", e);\n            }\n        }\n    }"}, {"signature": "public void deleteUnownedBags()", "full": "@Transactional\n    public void deleteUnownedBags() {\n        myLogger.trace(\"deleteUnownedBags\");\n        List<String> storageIds = getBagStorageIds();\n        Query query = myEM.createQuery(\"delete from Bag b where b.storageId not in ?1 or b.storageId is null\");\n        query.setParameter(1, storageIds);\n        int numberRemoved = query.executeUpdate();\n        myLogger.info(\"Removed \" + numberRemoved + \" bags that were not owned by any configured storage mechanism.\");\n    }"}, {"signature": "public Collection<BagStorage> getBagStorages()", "full": "public Collection<BagStorage> getBagStorages() {\n        return this.myBagStorages.values();\n    }"}, {"signature": "public List<String> getBagStorageIds()", "full": "public List<String> getBagStorageIds() {\n        List<String> storageList = Lists.newArrayList(myBagStorages.keySet());\n        storageList.sort(String::compareToIgnoreCase);\n        return storageList;\n    }"}, {"signature": "public String getBagMd5Sum(long bagId) throws NonexistentBagException", "full": "@Transactional\n    public String getBagMd5Sum(long bagId) throws NonexistentBagException {\n        return myBagRepository.findById(bagId).orElseThrow(() ->\n            new NonexistentBagException(\"Bag not found: \" + bagId)).getMd5sum();\n    }"}, {"signature": "public BagWrapper getBagWrapper(long bagId) throws NonexistentBagException", "full": "@Transactional\n    public BagWrapper getBagWrapper(long bagId) throws NonexistentBagException {\n        Bag bag = myBagRepository.findById(bagId).orElseThrow(() ->\n            new NonexistentBagException(\"Bag not found: \" + bagId));\n        BagStorage storage = myBagStorages.get(bag.getStorageId());\n        return storage.getBagWrapper(bag);\n    }"}, {"signature": "public Bag getBag(Long bagId) throws NonexistentBagException", "full": "@Transactional(readOnly = true)\n    public Bag getBag(Long bagId) throws NonexistentBagException {\n        Bag response = myBagRepository.findById(bagId).orElseThrow(() ->\n                new NonexistentBagException(\"Bag not found: \" + bagId));\n        myLogger.debug(\"Successfully got bag: \" + response.getFilename());\n        return response;\n    }"}, {"signature": "public byte[] getImage(Long bagId, String topicName, int index) throws BagReaderException, NonexistentBagException", "full": "@Transactional(readOnly = true)\n    public byte[] getImage(Long bagId, String topicName, int index) throws BagReaderException, NonexistentBagException {\n        try (BagWrapper wrapper = getBagWrapper(bagId)) {\n            BagFile bagFile = wrapper.getBagFile();\n\n            myLogger.debug(\"Reading message #\" + index + \" from bag \" + bagId +\n                           \" on topic [\" + topicName + \"]\");\n            com.github.swrirobotics.bags.reader.messages.serialization.MessageType\n                    mt = bagFile.getFirstMessageOnTopic(topicName);\n                    if (mt == null) {\n                String errorMsg = \"No messages found on topic: \" + topicName;\n                myLogger.warn(errorMsg);\n                throw new BagReaderException(errorMsg);\n            }\n            String messageType = mt.getPackage() + \"/\" + mt.getType();\n            if (messageType.equals(\"sensor_msgs/Image\")) {\n                return convertImageToJpeg(getUncompressedImage(mt));\n            }\n            else if (messageType.equals(\"sensor_msgs/CompressedImage\")) {\n                return getCompressedImage(mt);\n            }\n            else {\n                String errorMsg = \"Unknown image message type: \" + mt.getType();\n                myLogger.error(errorMsg);\n                throw new BagReaderException(errorMsg);\n            }\n\n        }\n        catch (BagReaderException | UninitializedFieldException | IOException e) {\n            String msg = \"Unable to read image for bag \" + bagId + \": \" + e.getLocalizedMessage();\n            myLogger.error(msg, e);\n            throw new BagReaderException(e);\n        }\n    }"}, {"signature": "void writeVideoStream(Long bagId, String topicName, Long frameSkip, OutputStream output) throws BagReaderException,\n        NonexistentBagException", "full": "@Transactional(readOnly = true)\n    void writeVideoStream(Long bagId, String topicName, Long frameSkip, OutputStream output) throws BagReaderException,\n        NonexistentBagException {\n\n        try (BagWrapper wrapper = getBagWrapper(bagId)) {\n            BagFile bagFile = wrapper.getBagFile();\n\n            long messageCount = -1;\n            for (TopicInfo topic : bagFile.getTopics()) {\n                if (topic.getName().equals(topicName)) {\n                    messageCount = topic.getMessageCount();\n                    break;\n                }\n            }\n            myLogger.debug(\"Expecting \" + messageCount + \" frames.\");\n            myLogger.debug(\"Reading message from bag \" + bagId +\n                           \" on topic [\" + topicName + \"]\");\n\n            FrameRateDeterminer determiner = new FrameRateDeterminer(messageCount);\n            bagFile.forMessagesOnTopic(topicName, determiner);\n\n            FfmpegImageHandler handler = new FfmpegImageHandler(output,\n                                                                determiner.getFrameRate(),\n                                                                determiner.getDurationS());\n            handler.setFrameSkip(frameSkip);\n            bagFile.forMessagesOnTopic(topicName, handler);\n            handler.finish();\n        }\n        catch (BagReaderException e) {\n            String msg = \"Unable to read image for bag \" + bagId + \": \" + e.getLocalizedMessage();\n            myLogger.error(msg, e);\n            throw new BagReaderException(e);\n        }\n        catch (Exception e) {\n            myLogger.error(\"Unexpected exception: \" + e.getLocalizedMessage());\n            throw new BagReaderException(e);\n        }\n        finally {\n            myLogger.info(\"Done streaming video.\");\n        }\n    }"}, {"signature": "private byte[] getCompressedImage(com.github.swrirobotics.bags.reader.messages.serialization.MessageType mt)\n            throws IOException, UninitializedFieldException", "full": "private byte[] getCompressedImage(com.github.swrirobotics.bags.reader.messages.serialization.MessageType mt)\n            throws IOException, UninitializedFieldException {\n        String type = mt.<StringType>getField(\"format\").getValue();\n        ArrayType data = mt.getField(\"data\");\n        byte[] byteData = data.getAsBytes();\n\n        if (type.equalsIgnoreCase(\"jpeg\")) {\n            return byteData;\n        }\n\n        try (ByteArrayInputStream byteStream = new ByteArrayInputStream(byteData)) {\n            BufferedImage image = ImageIO.read(byteStream);\n            ByteArrayOutputStream stream = new ByteArrayOutputStream();\n            ImageIO.write(image, \"jpeg\", stream);\n\n            return stream.toByteArray();\n        }\n    }"}, {"signature": "private byte[] convertImageToJpeg(BufferedImage image) throws IOException", "full": "private byte[] convertImageToJpeg(BufferedImage image) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        if (!ImageIO.write(image, \"jpeg\", stream)) {\n            myLogger.warn(\"ImageIO said it couldn't find a valid writer.\");\n        }\n\n        return stream.toByteArray();\n    }"}, {"signature": "private BufferedImage getUncompressedImage(com.github.swrirobotics.bags.reader.messages.serialization.MessageType mt)\n            throws UninitializedFieldException, BagReaderException", "full": "private BufferedImage getUncompressedImage(com.github.swrirobotics.bags.reader.messages.serialization.MessageType mt)\n            throws UninitializedFieldException, BagReaderException {\n\n        String encoding = mt.<StringType>getField(\"encoding\").getValue().trim().toLowerCase();\n        int imageType;\n        switch (encoding) {\n            case \"rgb8\":\n            case \"bayer_rggb8\":\n            case \"bayer_bggr8\":\n            case \"bayer_gbrg8\":\n            case \"bayer_grbg8\":\n                imageType = BufferedImage.TYPE_INT_RGB;\n                break;\n            case \"bgra8\":\n            case \"rgba8\":\n                imageType = BufferedImage.TYPE_INT_ARGB;\n                break;\n            case \"bgr8\":\n                imageType = BufferedImage.TYPE_INT_BGR;\n                break;\n            case \"mono8\":\n            case \"8uc1\":\n                imageType = BufferedImage.TYPE_BYTE_GRAY;\n                break;\n            case \"mono16\":\n                imageType = BufferedImage.TYPE_USHORT_GRAY;\n                break;\n            default:\n                String errorMsg = \"Unsupported image encoding: \" + encoding;\n                myLogger.warn(errorMsg);\n                throw new BagReaderException(errorMsg);\n        }\n\n        int height = mt.<UInt32Type>getField(\"height\").getValue().intValue();\n        int width = mt.<UInt32Type>getField(\"width\").getValue().intValue();\n        Short isBigEndian = mt.<UInt8Type>getField(\"is_bigendian\").getValue();\n        ArrayType dataArray = mt.getField(\"data\");\n        if (isBigEndian > 0) {\n            dataArray.setOrder(ByteOrder.BIG_ENDIAN);\n        }\n\n        byte[] byteData = dataArray.getAsBytes();\n        return decodeImage(width, height, encoding, imageType, byteData);\n    }"}, {"signature": "public BufferedImage decodeImage(int width, int height, String encoding, int imageType, byte[] byteData)", "full": "public BufferedImage decodeImage(int width, int height, String encoding, int imageType, byte[] byteData) {\n        if (encoding.startsWith(\"bayer\")) {\n            byteData = convertBayer(width, height, byteData, encoding);\n        }\n\n        int[] mixChannels;\n        switch (encoding) {\n            case \"bgra8\":\n                mixChannels = bgra2rgb;\n                break;\n            case \"rgba8\":\n                mixChannels = rgba2rgb;\n                break;\n            default:\n                mixChannels = null;\n                break;\n        }\n        if (mixChannels != null) {\n            byteData = mix2rgb(width, height, byteData, mixChannels);\n        }\n\n        int[] intData = new int[byteData.length];\n        for (int i = 0; i < byteData.length; i++) {\n            intData[i] = byteData[i];\n        }\n\n        if (imageType == BufferedImage.TYPE_INT_ARGB) {\n            imageType = BufferedImage.TYPE_INT_RGB;\n        }\n\n        BufferedImage image = new BufferedImage(width, height, imageType);\n        image.getRaster().setPixels(0, 0, width, height, intData);\n        return image;\n    }"}, {"signature": "private byte[] convertBayer(int width, int height, byte[] input, String encoding)", "full": "private byte[] convertBayer(int width, int height, byte[] input, String encoding) {\n        int type;\n        int pattern;\n        if (encoding.startsWith(\"bayer_rggb\")) {\n            pattern = Imgproc.COLOR_BayerBG2RGB;\n        }\n        else if (encoding.startsWith(\"bayer_bggr\")) {\n            pattern = Imgproc.COLOR_BayerRG2RGB;\n        }\n        else if (encoding.startsWith(\"bayer_gbrg\")) {\n            pattern = Imgproc.COLOR_BayerGR2RGB;\n        }\n        else {\n            pattern = Imgproc.COLOR_BayerGB2RGB;\n        }\n        if (encoding.endsWith(\"8\")) {\n            type = CvType.CV_8U;\n        }\n        else {\n            type = CvType.CV_16U;\n        }\n        Mat sourceMat = new Mat(height, width, type);\n        sourceMat.put(0, 0, input);\n        Mat destMat = new Mat(height, width, type);\n        Imgproc.cvtColor(sourceMat, destMat, pattern);\n        byte[] output = new byte[(int)destMat.total() * destMat.channels()];\n        destMat.get(0, 0, output);\n        return output;\n    }"}, {"signature": "private byte[] mix2rgb(int width, int height, byte[] input, int[] mixChannels)", "full": "private byte[] mix2rgb(int width, int height, byte[] input, int[] mixChannels) {\n        MatOfInt fromto = new MatOfInt(mixChannels);\n        var sourceMatList = Lists.newArrayList(new Mat(height, width, CvType.CV_8UC4));\n        sourceMatList.get(0).put(0, 0, input);\n        var destMatList = Lists.newArrayList(new Mat(height, width, CvType.CV_8UC3));\n        Core.mixChannels(sourceMatList, destMatList, fromto);\n        var destMat = destMatList.get(0);\n        byte[] output = new byte[(int)destMat.total() * destMat.channels()];\n        destMat.get(0, 0, output);\n        return output;\n    }"}, {"signature": "public void removeDuplicateBags()", "full": "@Transactional\n    public void removeDuplicateBags() {\n        String msg = \"Removing duplicate bag files.\";\n        myLogger.info(msg);\n        reportStatus(Status.State.WORKING, msg);\n        List<Bag> bags = myBagRepository.findAll();\n        Map<String, List<Bag>> md5Bags = Maps.newHashMap();\n\n        for (Bag bag : bags) {\n            List<Bag> tmp = md5Bags.computeIfAbsent(bag.getMd5sum(), k -> Lists.newArrayList());\n            tmp.add(bag);\n        }\n\n        myLogger.info(\"Found \" + bags.size() + \" bags with \" +\n                      md5Bags.keySet().size() + \" different MD5s.\");\n\n        for (List<Bag> sublist : md5Bags.values()) {\n            if (sublist.size() > 1) {\n                myLogger.debug(\"Found \" + sublist.size() +\n                    \" duplicates for MD5 sum \" + sublist.get(0).getMd5sum() + \".\");\n                for (int i = 1; i < sublist.size(); i++) {\n                    Bag dupBag = sublist.get(i);\n                    msg = \"Removing bag w/ ID \" + dupBag.getMd5sum();\n                    myLogger.debug(msg);\n                    reportStatus(Status.State.WORKING, msg);\n                    myBagRepository.delete(dupBag);\n                }\n            }\n        }\n        msg = \"Done removing duplicates.\";\n        myLogger.info(msg);\n        reportStatus(Status.State.IDLE, msg);\n    }"}, {"signature": "public Point makePoint(Double latitude, Double longitude)", "full": "public Point makePoint(Double latitude, Double longitude) {\n        return myGeometryFactory.createPoint(new Coordinate(longitude, latitude));\n    }"}, {"signature": "public void updateBag(Bag newBag)", "full": "@Transactional\n    public void updateBag(Bag newBag) {\n        Bag dbBag = myBagRepository.findById(newBag.getId()).orElseThrow();\n        dbBag.setDescription(newBag.getDescription());\n        if (newBag.getLatitudeDeg() != null && newBag.getLongitudeDeg() != null)\n        {\n            dbBag.setCoordinate(makePoint(newBag.getLatitudeDeg(), newBag.getLongitudeDeg()));\n        }\n        else\n        {\n            dbBag.setCoordinate(null);\n        }\n        dbBag.setLocation(newBag.getLocation());\n        dbBag.setVehicle(newBag.getVehicle());\n        dbBag.getTags().addAll(newBag.getTags());\n        dbBag.setUpdatedOn(new Timestamp(System.currentTimeMillis()));\n        myBagRepository.save(dbBag);\n    }"}, {"signature": "public void uploadBag(MultipartFile file, String targetDirectory, String storageId) throws IOException", "full": "public void uploadBag(MultipartFile file, String targetDirectory, String storageId) throws IOException {\n        BagStorage storage = myBagStorages.get(storageId);\n        if (storage == null) {\n            throw new IOException(\"Unknown bag storage: \" + storageId);\n        }\n        storage.uploadBag(file, targetDirectory);\n    }"}, {"signature": "private Pageable createPageRequest(int page, int size, String dir, String sort)", "full": "private Pageable createPageRequest(int page, int size, String dir, String sort) {\n        return PageRequest.of(page-1,\n                               size,\n                               dir.equalsIgnoreCase(\"ASC\") ? Sort.Direction.ASC : Sort.Direction.DESC,\n                               sort);\n    }"}, {"signature": "private <X> Predicate fromFilter(ExtJsFilter filter, CriteriaBuilder cb, Path<X> path)", "full": "private <X> Predicate fromFilter(ExtJsFilter filter, CriteriaBuilder cb, Path<X> path) {\n        Timestamp ts = null;\n        switch (filter.getProperty()) {\n            case \"startTime\":\n            case \"endTime\":\n            case \"updatedOn\":\n            case \"createdOn\":\n                ts = new Timestamp(Long.parseLong(filter.getValue()));\n                break;\n        }\n\n        Path propertyPath = path.get(filter.getProperty());\n\n        Predicate pred = null;\n\n        switch (filter.getOperator()) {\n            case \"like\":\n                pred = cb.like(cb.lower(propertyPath), \"%\" + filter.getValue().toLowerCase() + \"%\");\n                break;\n            case \"lt\":\n                if (ts != null) {\n                    pred = cb.lessThan(propertyPath, ts);\n                }\n                else {\n                    pred = cb.lessThan(propertyPath, Double.valueOf(filter.getValue()));\n                }\n                break;\n            case \"gt\":\n                if (ts != null) {\n                    pred = cb.greaterThan(propertyPath, ts);\n                }\n                else {\n                    pred = cb.greaterThan(propertyPath, Double.valueOf(filter.getValue()));\n                }\n                break;\n            case \"eq\":\n                if (ts != null) {\n                    pred = cb.equal(propertyPath, ts);\n                }\n                else {\n                    pred = cb.equal(path.get(filter.getProperty()), Double.valueOf(filter.getValue()));\n                }\n                break;\n            case \"=\":\n                pred = cb.equal(path.get(filter.getProperty()), filter.getValue().equals(\"true\"));\n                break;\n            default:\n                break;\n        }\n\n        return pred;\n    }"}, {"signature": "private Predicate fullTextPredicate(final String text,\n                                        final String[] fields,\n                                        CriteriaBuilder cb,\n                                        Root<Bag> root)", "full": "private Predicate fullTextPredicate(final String text,\n                                        final String[] fields,\n                                        CriteriaBuilder cb,\n                                        Root<Bag> root) {\n        final String wildcardText = \"%\" + text.toLowerCase() + \"%\";\n        List<Predicate> preds = Lists.newArrayList();\n        for (String field : fields) {\n            switch(field) {\n                case \"messageType\":\n                    Join<Bag, MessageType> mtJoin = root.join(Bag_.messageTypes, JoinType.LEFT);\n                    preds.add(cb.like(cb.lower(mtJoin.get(MessageType_.name)), wildcardText));\n                    break;\n                case \"tags\":\n                    Join<Bag, Tag> tagJoin = root.join(Bag_.tags, JoinType.LEFT);\n                    preds.add(cb.like(cb.lower(tagJoin.get(Tag_.tag)), wildcardText));\n                    preds.add(cb.like(cb.lower(tagJoin.get(Tag_.value)), wildcardText));\n                    break;\n                case \"topicName\":\n                    Join<Bag, Topic> topicJoin = root.join(Bag_.topics, JoinType.LEFT);\n                    preds.add(cb.like(cb.lower(topicJoin.get(Topic_.topicName)), wildcardText));\n                    break;\n                default:\n                    preds.add(cb.like(cb.lower(root.get(field)), wildcardText));\n                    break;\n            }\n        }\n\n        return cb.or(preds.toArray(new Predicate[0]));\n    }"}, {"signature": "public BagList findBagsContainingText(final String text,\n                                          final String[] fields,\n                                          final ExtJsFilter[] filters,\n                                          int page,\n                                          int size,\n                                          String dir,\n                                          String sort)", "full": "@Transactional(readOnly = true)\n    public BagList findBagsContainingText(final String text,\n                                          final String[] fields,\n                                          final ExtJsFilter[] filters,\n                                          int page,\n                                          int size,\n                                          String dir,\n                                          String sort) {\n        myLogger.trace(\"Executing specification.\");\n\n        Page<Bag> bags;\n        Pageable pageReq = createPageRequest(page, size, dir, sort);\n\n        if ((text == null || text.trim().isEmpty() || fields == null || fields.length == 0) &&\n            (filters == null || filters.length == 0)) {\n            bags = myBagRepository.findAll(pageReq);\n        }\n        else {\n            bags = myBagRepository.findAll((root, query, cb) -> {\n                query.distinct(true);\n\n                List<Predicate> preds = Lists.newArrayList();\n                if (text != null && !text.trim().isEmpty() &&\n                    fields != null && fields.length != 0) {\n                    preds.add(fullTextPredicate(text, fields, cb, root));\n                }\n                if (filters != null && filters.length > 0) {\n                    for (ExtJsFilter filter : filters) {\n                        preds.add(fromFilter(filter, cb, root));\n                    }\n                }\n\n                if (preds.size() == 1) {\n                    return preds.get(0);\n                }\n                else {\n                    return cb.and(preds.toArray(new Predicate[0]));\n                }\n            }, pageReq);\n        }\n        myLogger.trace(\"Finished executing.\");\n\n        return new BagList(bags.getContent(), bags.getTotalElements());\n    }"}, {"signature": "public List<Double[]> getGpsCoordsForBags(final Collection<Long> bagIds)", "full": "@Transactional(readOnly = true)\n    public List<Double[]> getGpsCoordsForBags(final Collection<Long> bagIds) {\n        myLogger.debug(\"getGpsCoordsForBags: \" + Joiner.on(\", \").skipNulls().join(bagIds));\n\n        List<BagPosition> positions =\n                myBagPositionRepository.findByBagIdInOrderByPositionTimeAsc(bagIds);\n\n        List<Double[]> coords = positions.parallelStream().map(p -> new Double[] {\n                p.getLongitude(), p.getLatitude()}).collect(Collectors.toList());\n\n        myLogger.debug(\"Returning \" + coords.size() + \" points.\");\n\n        return coords;\n    }"}, {"signature": "public List<Long> getAllBagIds()", "full": "@Transactional(readOnly = true)\n    public List<Long> getAllBagIds() {\n        List<Bag> bags = myBagRepository.findAll();\n        List<Long> bagIds = Lists.newArrayListWithCapacity(bags.size());\n\n        bagIds.addAll(bags.parallelStream().map(Bag::getId).collect(Collectors.toList()));\n\n        return bagIds;\n    }"}, {"signature": "private List<GpsPosition> getAllGpsMessages(BagFile bag)", "full": "private List<GpsPosition> getAllGpsMessages(BagFile bag) {\n        List<GpsPosition> positions = Lists.newArrayList();\n\n        MessageHandler gpsHandler = ((message, conn) -> {\n            try {\n                positions.add(new GpsPosition(message.getField(\"latitude\"),\n                                              message.getField(\"longitude\"),\n                                              message.<com.github.swrirobotics.bags.reader.messages.serialization.MessageType>getField(\n                                                      \"header\").getField(\"stamp\")));\n            }\n            catch (UninitializedFieldException e) {\n                return false;\n            }\n            catch (NullPointerException e) {\n                return true;\n            }\n            return true;\n        });\n\n        try {\n            String[] gpsTopics = myConfigService.getConfiguration().getGpsTopics();\n            for (String topic : gpsTopics) {\n                bag.forMessagesOnTopic(topic, gpsHandler);\n                if (!positions.isEmpty()) {\n                    break;\n                }\n            }\n\n            if (positions.isEmpty()) {\n                bag.forFirstTopicWithMessagesOfType(\"sensor_msgs/NavSatFix\", gpsHandler);\n            }\n            if (positions.isEmpty()) {\n                bag.forFirstTopicWithMessagesOfType(\"gps_common/GPSFix\", gpsHandler);\n            }\n            if (positions.isEmpty()) {\n                bag.forFirstTopicWithMessagesOfType(\"marti_gps_common/GPSFix\", gpsHandler);\n            }\n        }\n        catch (BagReaderException e) {\n            e.printStackTrace();\n        }\n\n        return positions;\n    }"}, {"signature": "public String getVehicleName(BagFile bag)", "full": "public String getVehicleName(BagFile bag) {\n        String[] vehicleNames = myConfigService.getConfiguration().getVehicleNameTopics();\n        try {\n            for (String topic : vehicleNames) {\n                com.github.swrirobotics.bags.reader.messages.serialization.MessageType\n                        mt = bag.getFirstMessageOnTopic(topic);\n                if (mt != null) {\n                    return mt.<StringType>getField(\"data\").getValue().replaceAll(\"\\\\p{C}\", \"\").trim();\n                }\n            }\n        }\n        catch (BagReaderException | UninitializedFieldException e) {\n            }\n        return null;\n    }"}, {"signature": "private Map<String, String> getMetadata(BagFile bagFile)", "full": "private Map<String, String> getMetadata(BagFile bagFile) {\n        final Map<String, String> tags = Maps.newHashMap();\n        String[] topics = myConfigService.getConfiguration().getMetadataTopics();\n        try {\n            final Splitter tagSplitter = Splitter.on(':').limit(2).trimResults();\n            final Splitter.MapSplitter lineSplitter =\n                    Splitter.on(System.getProperty(\"line.separator\")).omitEmptyStrings().trimResults().withKeyValueSeparator(tagSplitter);\n            for (String topic : topics) {\n                bagFile.forMessagesOnTopic(topic, (message, connection) -> {\n                    try {\n                        String data = message.<StringType>getField(\"data\").getValue();\n                        myLogger.debug(\"Examining message: \" + data);\n                        tags.putAll(lineSplitter.split(data));\n                    }\n                    catch (UninitializedFieldException e) {\n                        }\n                    return true;\n                });\n            }\n        }\n        catch (BagReaderException | java.util.NoSuchElementException e) {\n            reportStatus(Status.State.ERROR,\n                    \"Unable to get metadata from bag file \" + bagFile.getPath() + \": \" + e.getLocalizedMessage());\n        }\n        return tags;\n    }"}, {"signature": "public List<String> getPaths()", "full": "public List<String> getPaths() {\n        Set<String> paths = new HashSet<>();\n        for (BagStorage storage : myBagStorages.values()) {\n            List<String> tmpPaths = myBagRepository.getDisinctPathsByStorageId(storage.getStorageId());\n            List<String> filteredPaths = new ArrayList<>();\n            for (String path : tmpPaths) {\n                filteredPaths.add(path.replaceFirst(storage.getRootPath(), \"\"));\n            }\n            paths.addAll(filteredPaths);\n        }\n        List<String> sortedPaths = Lists.newArrayList(paths);\n        sortedPaths.sort(String::compareToIgnoreCase);\n        return sortedPaths;\n    }"}, {"signature": "private Set<Tag> extractTagsFromBagFile(BagFile bagFile)", "full": "private Set<Tag> extractTagsFromBagFile(BagFile bagFile) {\n        Map<String, String> metadata = getMetadata(bagFile);\n        Set<Tag> tags = Sets.newHashSet();\n\n        final int MAX_VALUE_LENGTH = 255;\n\n        for (Map.Entry<String, String> entry : metadata.entrySet()) {\n            Tag tag = new Tag();\n            tag.setTag(entry.getKey());\n            String value = entry.getValue();\n            tag.setValue(value.length() > MAX_VALUE_LENGTH ?\n                                 value.substring(0, MAX_VALUE_LENGTH) : value);\n            tags.add(tag);\n        }\n\n        if (tags.size() > 0) {\n            myLogger.debug(\"Found \" + tags.size() + \" tags\");\n        }\n        return tags;\n    }"}, {"signature": "public void updateGpsPositionsForBagId(long bagId) throws NonexistentBagException", "full": "@Transactional\n    public void updateGpsPositionsForBagId(long bagId) throws NonexistentBagException {\n        try (BagWrapper wrapper = getBagWrapper(bagId)) {\n            BagFile bagFile = wrapper.getBagFile();\n\n            Bag bag = myBagRepository.getOne(bagId);\n            updateGpsPositions(bag, getAllGpsMessages(bagFile));\n            myBagRepository.save(bag);\n        }\n        catch (BagReaderException | IOException e) {\n            reportStatus(Status.State.ERROR,\n                         \"Unable to get GPS info for bag \" + bagId + \": \" + e.getLocalizedMessage());\n        }\n    }"}, {"signature": "public void updateGpsPositions(final Bag bag, Collection<GpsPosition> gpsPositions)", "full": "@Transactional\n    public void updateGpsPositions(final Bag bag, Collection<GpsPosition> gpsPositions) {\n        List<BagPosition> existingPositions = bag.getBagPositions();\n        if (!existingPositions.isEmpty()) {\n            myLogger.warn(\"Adding new GPS positions for a bag that already has \" +\n                                  \"some in the database is not supported.  \" +\n                                  \"Manually remove the old ones first.\");\n            bag.setHasPath(true);\n            return;\n        }\n\n        String msg = \"Inserting GPS positions for \" + bag.getFilename();\n        myLogger.debug(msg);\n        reportStatus(Status.State.WORKING, msg);\n        bag.setHasPath(!gpsPositions.isEmpty());\n        for (GpsPosition gpsPos : gpsPositions) {\n            BagPosition pos = new BagPosition();\n            pos.setBag(bag);\n            pos.setPosition(makePoint(gpsPos.latitude, gpsPos.longitude));\n            pos.setPositionTime(gpsPos.stamp);\n            pos = myBagPositionRepository.save(pos);\n            bag.getBagPositions().add(pos);\n        }\n        msg = \"Saved \" + gpsPositions.size() + \" GPS positions for \" +\n                bag.getFilename() + \".\";\n        myLogger.debug(msg);\n        reportStatus(Status.State.WORKING, msg);\n    }"}, {"signature": "public void removeTagForBag(Collection<String> tagNames,\n                                final Long bagId) throws NonexistentBagException", "full": "@Transactional\n    public void removeTagForBag(Collection<String> tagNames,\n                                final Long bagId) throws NonexistentBagException {\n        if (!myBagRepository.existsById(bagId)) {\n            throw new NonexistentBagException(\"No bag found with ID: \" + bagId);\n        }\n\n        myTagRepository.deleteByBagIdAndTagIn(bagId, tagNames);\n    }"}, {"signature": "public void setTagForBag(String tagName,\n                             final String value,\n                             final Long bagId) throws NonexistentBagException", "full": "@Transactional\n    public void setTagForBag(String tagName,\n                             final String value,\n                             final Long bagId) throws NonexistentBagException {\n        if (!myBagRepository.existsById(bagId)) {\n            throw new NonexistentBagException(\"No bag found with ID: \" + bagId);\n        }\n\n        tagName = tagName.trim();\n\n        Tag tag = myTagRepository.findByTagAndBagId(tagName, bagId);\n        if (tag == null) {\n            myLogger.debug(\"No tag found with key \" + tagName + \"; creating a new one.\");\n            tag = new Tag();\n            tag.setTag(tagName);\n            tag.setBagId(bagId);\n        }\n\n        tag.setValue(value == null ? \"\" : value.trim());\n        myLogger.debug(\"Setting value of tag with key '\" + tagName + \"' to '\" + tag.getValue() + \"'\");\n        myTagRepository.save(tag);\n    }"}, {"signature": "public Bag insertNewBag(final BagWrapper wrapper,\n                            final String md5sum,\n                            final String locationName,\n                            final List<GpsPosition> gpsPositions,\n                            final String storageId) throws BagReaderException, DuplicateBagException", "full": "@Transactional\n    public Bag insertNewBag(final BagWrapper wrapper,\n                            final String md5sum,\n                            final String locationName,\n                            final List<GpsPosition> gpsPositions,\n                            final String storageId) throws BagReaderException, DuplicateBagException {\n        Bag bag = myBagRepository.findByMd5sum(md5sum);\n\n        if (bag != null) {\n            throw new DuplicateBagException(\"Duplicate of: \" + bag.getStorageId() + \":\" +\n                bag.getPath() + bag.getFilename());\n        }\n\n        bag = new Bag();\n\n        BagFile bagFile = wrapper.getBagFile();\n        String absPath = wrapper.getPath() + wrapper.getFilename();\n\n        myLogger.info(\"Adding new bag: \" + absPath);\n        bag.setCreatedOn(new Timestamp(System.currentTimeMillis()));\n        bag.setPath(wrapper.getPath());\n        bag.setFilename(wrapper.getFilename());\n        bag.setMd5sum(md5sum);\n        bag.setCompressed(false);\n        bag.setDuration(bagFile.getDurationS());\n        bag.setStartTime(bagFile.getStartTime());\n        bag.setEndTime(bagFile.getEndTime());\n        bag.setIndexed(bagFile.isIndexed());\n        bag.setMessageCount(bagFile.getMessageCount());\n        bag.setMissing(false);\n        bag.setSize(bagFile.getPath().toFile().length());\n        bag.setStorageId(storageId);\n        bag.setVersion(bagFile.getVersion());\n        bag.setVehicle(getVehicleName(bagFile));\n        if (!gpsPositions.isEmpty()) {\n            GpsPosition pos = gpsPositions.get(0);\n            bag.setCoordinate(makePoint(pos.latitude, pos.longitude));\n        }\n        bag.setLocation(locationName);\n        bag = myBagRepository.save(bag);\n        myLogger.trace(\"Initial bag save for \" + absPath);\n\n        Map<String, MessageType> dbMessageTypes = addMessageTypesToBag(bagFile, bag);\n\n        addTopicsToBag(bagFile, bag, dbMessageTypes);\n        addTagsToBag(bagFile, bag);\n\n        updateGpsPositions(bag, gpsPositions);\n\n        return bag;\n    }"}, {"signature": "protected Map<String, MessageType> addMessageTypesToBag(final BagFile bagFile, final Bag bag)", "full": "@Transactional\n    protected Map<String, MessageType> addMessageTypesToBag(final BagFile bagFile, final Bag bag) {\n        myLogger.trace(\"Adding message types.\");\n        Multimap<String, String> messageTypes = bagFile.getMessageTypes();\n        Map<String, MessageType> dbMessageTypes = new HashMap<>();\n        for (Map.Entry<String, String> entry : messageTypes.entries()) {\n            MessageType mt = getMessageType(entry.getKey(), entry.getValue(), bag);\n            dbMessageTypes.put(entry.getKey(), mt);\n        }\n\n        return dbMessageTypes;\n    }"}, {"signature": "protected void addTopicsToBag(final BagFile bagFile,\n                                final Bag bag,\n                                final Map<String, MessageType> dbMessageTypes) throws BagReaderException", "full": "@Transactional\n    protected void addTopicsToBag(final BagFile bagFile,\n                                final Bag bag,\n                                final Map<String, MessageType> dbMessageTypes) throws BagReaderException {\n        myLogger.trace(\"Adding topics.\");\n        List<TopicInfo> topics = bagFile.getTopics();\n        for (TopicInfo topic : topics) {\n            MessageType dbType = dbMessageTypes.get(topic.getMessageType());\n            if (dbType == null) {\n                myLogger.trace(\"Need to add new message type. That's a little odd, \" +\n                               \"addMessageTypesToBag should've gotten them all.\");\n                dbType = getMessageType(\n                        topic.getMessageType(),\n                        topic.getMessageMd5Sum(),\n                        bag);\n                dbMessageTypes.put(topic.getMessageType(), dbType);\n            }\n            else {\n                myLogger.trace(\"Found cached message type.\");\n            }\n\n            myLogger.trace(\"Finding existing topics.\");\n            List<Topic> bagTopics = myTopicRepository.findByTopicNameAndBagId(topic.getName(), bag.getId());\n            Topic dbTopic;\n            if (!bagTopics.isEmpty()) {\n                dbTopic = bagTopics.get(0);\n            }\n            else {\n                dbTopic = new Topic();\n            }\n            dbTopic.setTopicName(topic.getName());\n            dbTopic.setType(dbType);\n            dbTopic.setMessageCount(topic.getMessageCount());\n            dbTopic.setConnectionCount(topic.getConnectionCount());\n            dbTopic.setBag(bag);\n            bag.getTopics().add(dbTopic);\n        }\n    }"}, {"signature": "public void addTagsToBag(final BagFile bagFile,\n                             final Bag bag)", "full": "@Transactional\n    public void addTagsToBag(final BagFile bagFile,\n                             final Bag bag) {\n        myLogger.trace(\"Adding tags to \" + bagFile.getPath());\n        Set<Tag> bagTags = extractTagsFromBagFile(bagFile);\n\n        for (Tag bagTag : bagTags) {\n            boolean found = false;\n            for (Tag dbTag : bag.getTags()) {\n                if (dbTag.getTag().equals(bagTag.getTag())) {\n                    found = true;\n                    if (!dbTag.getValue().equals(bagTag.getValue())) {\n                        myLogger.debug(\"Updating existing tag '\" + dbTag.getTag() +\n                                       \"': Old tag value: '\" + bagTag.getValue() +\n                                       \"'; New tag value: '\" + dbTag.getValue() + \"')\");\n                        dbTag.setValue(bagTag.getValue());\n                        myTagRepository.save(dbTag);\n                        break;\n                    }\n                }\n            }\n            if (!found) {\n                myLogger.debug(\"Saving new tag '\" + bagTag.getTag() + \": \" + bagTag.getValue() + \"'\");\n                bagTag.setBag(bag);\n                bag.getTags().add(bagTag);\n                myTagRepository.save(bagTag);\n            }\n        }\n    }"}, {"signature": "public void updateBagFile(final BagWrapper wrapper,\n                              final String storageId,\n                              final Map<String, Long> missingBagMd5sums)", "full": "public void updateBagFile(final BagWrapper wrapper,\n                              final String storageId,\n                              final Map<String, Long> missingBagMd5sums) {\n        String absPath = wrapper.getPath() + wrapper.getFilename();\n        myLogger.debug(\"Checking \" + absPath + \"...\");\n        reportStatus(Status.State.WORKING, \"Processing \" + absPath + \".\");\n\n        BagFile bagFile;\n        try {\n            bagFile = wrapper.getBagFile();\n        }\n        catch (BagReaderException e) {\n            myLogger.error(\"Error reading bag file.\", e);\n            reportStatus(Status.State.ERROR, \"Unable to read \" + absPath + \".  Check its permissions.\");\n            return;\n        }\n\n        if (!bagFile.getPath().toFile().canRead()) {\n            myLogger.error(\"Can't read file.\");\n            reportStatus(Status.State.ERROR, \"Unable to read \" + absPath + \".  Check its permissions.\");\n            return;\n        }\n\n        String md5sum;\n        Timer timer = new Timer();\n        try {\n            TimerTask updateTask = new TimerTask() {\n                @Override\n                public void run() {\n                    reportStatus(Status.State.WORKING,\n                                 \"Calculating MD5 Sum for \" + absPath + \"...\");\n                }\n            };\n            timer.scheduleAtFixedRate(updateTask, 0, 3000);\n\n            md5sum = bagFile.getUniqueIdentifier();\n            myLogger.debug(\"Calculated bag md5sum: \" + md5sum);\n        }\n        catch (BagReaderException e) {\n            myLogger.error(\"Unable to calculate MD5 sum for bag \" + absPath, e);\n            return;\n        }\n        finally {\n            timer.cancel();\n        }\n\n        Long bagId = missingBagMd5sums.get(md5sum);\n\n        if (bagId == null) {\n            Bag existingBag = myBagRepository.findByMd5sum(md5sum);\n            if (existingBag != null) {\n                String msg = \"File \" + absPath + \" is a duplicate of \" +\n                             existingBag.getStorageId() + \":\" + existingBag.getPath() + existingBag.getFilename() + \".\";\n                reportStatus(Status.State.ERROR, msg);\n                myLogger.warn(msg);\n                return;\n            }\n        }\n\n        String locationName = null;\n        List<GpsPosition> gpsPositions;\n        try {\n            bagFile = wrapper.getBagFile();\n\n            gpsPositions = getAllGpsMessages(bagFile);\n            if (!gpsPositions.isEmpty()) {\n                GpsPosition firstPos = gpsPositions.get(0);\n                locationName = myGeocodingService.getLocationName(firstPos.latitude, firstPos.longitude);\n            }\n        }\n        catch (BagReaderException e) {\n            myLogger.error(\"Error reading GPS messages from bag file:\", e);\n            return;\n        }\n\n        Bag newBag = null;\n        synchronized (myBagDbLock) {\n            try {\n                newBag = updateBagInDatabase(bagId, wrapper, md5sum, missingBagMd5sums, locationName, gpsPositions,\n                    storageId);\n                String msg = \"Done processing: \" + bagFile.getPath().toFile();\n                myLogger.debug(msg);\n                reportStatus(Status.State.IDLE, msg);\n            }\n            catch (BagReaderException | DuplicateBagException e) {\n                reportStatus(Status.State.ERROR, \"Error reading \" +\n                             absPath + \": \" + e.getLocalizedMessage());\n                myLogger.error(\"Error reading bag file: \" + absPath, e);\n            }\n        }\n\n        if (bagId == null && newBag != null) {\n            runAutomaticScripts(newBag);\n        }\n    }"}, {"signature": "private void runAutomaticScripts(Bag bag)", "full": "private void runAutomaticScripts(Bag bag) {\n        List<Script> scripts = myScriptService.getAutomaticScripts();\n\n        myLogger.debug(\"Running \" + scripts.size() + \" scripts on the bag file.\");\n        for (Script script : scripts) {\n            try {\n                if (myScriptService.bagMatchesCriteria(bag.getId(), script.getId())) {\n                    myLogger.info(\"Running script \" + script.getId()\n                        + \" [\" + script.getName() + \"] on new bag \" + bag.getId());\n                    myScriptService.runScript(script.getId(), Collections.singletonList(bag.getId()));\n                }\n                else {\n                    myLogger.debug(\"Bag \" + bag.getId() + \" did not match criteria for script \"\n                        + script.getId() + \" [\" + script.getName() + \"]\");\n                }\n            }\n            catch (ScriptRunException e) {\n                myLogger.warn(\"Error automatically running script\", e);\n            }\n            catch (NonexistentScriptException e) {\n                myLogger.error(\"Script did not exist; this should never happen\", e);\n            }\n            catch (NonexistentBagException e) {\n                myLogger.error(\"Bag did not exist; was it successfully inserted in the DB?\", e);\n            }\n        }\n    }"}, {"signature": "public Bag updateBagInDatabase(Long bagId,\n                                   final BagWrapper wrapper,\n                                   final String md5sum,\n                                   final Map<String, Long> missingBagMd5sums,\n                                   final String locationName,\n                                   final List<GpsPosition> gpsPositions,\n                                   final String storageId)\n            throws DuplicateBagException, BagReaderException", "full": "@Transactional\n    public Bag updateBagInDatabase(Long bagId,\n                                   final BagWrapper wrapper,\n                                   final String md5sum,\n                                   final Map<String, Long> missingBagMd5sums,\n                                   final String locationName,\n                                   final List<GpsPosition> gpsPositions,\n                                   final String storageId)\n            throws DuplicateBagException, BagReaderException {\n        Bag bag;\n        if (bagId == null) {\n            bag = insertNewBag(wrapper, md5sum, locationName, gpsPositions, storageId);\n        }\n        else {\n            if (missingBagMd5sums.remove(md5sum) != null) {\n                myLogger.info(\"Missing bag was found.\");\n            }\n            else {\n                myLogger.info(\"Force updating bag info.\");\n            }\n            bag = myBagRepository.findById(bagId).orElseThrow();\n            bag.setPath(wrapper.getPath());\n            bag.setFilename(wrapper.getFilename());\n            bag.setMissing(false);\n            bag.setMd5sum(md5sum);\n            bag.setStorageId(storageId);\n            addTagsToBag(wrapper.getBagFile(), bag);\n        }\n        myBagRepository.save(bag);\n        String msg = \"Committing: \" + wrapper.getPath() + wrapper.getFilename();\n        myLogger.debug(msg);\n        reportStatus(Status.State.WORKING, msg);\n\n        return bag;\n    }"}, {"signature": "public List<BagTreeNode> getTreePath(String targetPath) throws IOException", "full": "@Transactional(readOnly = true)\n    public List<BagTreeNode> getTreePath(String targetPath) throws IOException {\n        List<BagTreeNode> nodes = Lists.newArrayList();\n\n        for (BagStorage storage : myBagStorages.values()) {\n            nodes.addAll(storage.getTreeNodes(targetPath));\n        }\n\n        return nodes;\n    }"}, {"signature": "public BagCount[] checkFilteredBagCounts(String filterText)", "full": "@Transactional(readOnly = true)\n    public BagCount[] checkFilteredBagCounts(String filterText) {\n        TypedQuery<BagCount> query = myEM.createNamedQuery(\"Bag.countBagPaths\", BagCount.class);\n        query.setParameter(\"text\", filterText);\n        List<BagCount> results = query.getResultList();\n        return results.toArray(new BagCount[0]);\n    }"}, {"signature": "public void removeMissingBags()", "full": "@Transactional\n    public void removeMissingBags() {\n        myLogger.info(\"removeMissingBags()\");\n        reportStatus(Status.State.WORKING, \"Removing missing bag entries.\");\n        Query query = myEM.createQuery(\"delete from Bag b where b.missing = true\");\n        int numberRemoved = query.executeUpdate();\n        String msg = \"Removed \" + numberRemoved + \" missing bags.\";\n        myLogger.debug(msg);\n        reportStatus(Status.State.IDLE, msg);\n    }"}, {"signature": "private MessageType getMessageType(final String name,\n                                       final String md5sum,\n                                       final Bag bag)", "full": "private MessageType getMessageType(final String name,\n                                       final String md5sum,\n                                       final Bag bag) {\n        MessageTypeKey key = new MessageTypeKey();\n        key.name = name;\n        key.md5sum = md5sum;\n        MessageType dbType = myMTRepository.findById(key).orElse(null);\n        if (dbType == null) {\n            myLogger.info(\"Adding new MessageType to DB: \" +\n                                  name + \" / \" + md5sum);\n            dbType = new MessageType();\n            dbType.setMd5sum(md5sum);\n            dbType.setName(name);\n        }\n        else {\n            myLogger.debug(\"Found existing MessageType in DB: \" +\n                                   name + \" / \" + md5sum);\n        }\n        bag.getMessageTypes().add(dbType);\n        return dbType;\n    }"}, {"signature": "protected String getStatusProviderName() \n}", "full": "@Override\n    protected String getStatusProviderName() {\n        return \"Bag Service\";\n    }\n}"}], "class_attributes": [{"type": "BagRepository", "name": "myBagRepository"}, {"type": "BagPositionRepository", "name": "myBagPositionRepository"}, {"type": "MessageTypeRepository", "name": "myMTRepository"}, {"type": "TopicRepository", "name": "myTopicRepository"}, {"type": "TagRepository", "name": "myTagRepository"}, {"type": "ConfigService", "name": "myConfigService"}, {"type": "GeocodingService", "name": "myGeocodingService"}, {"type": "ScriptService", "name": "myScriptService"}, {"type": "EntityManager", "name": "myEM"}, {"type": "Map", "name": "myBagStorages"}, {"type": "Object", "name": "myBagDbLock"}, {"type": "int", "name": "rgba2rgb"}, {"type": "int", "name": "bgra2rgb"}, {"type": "GeometryFactory", "name": "myGeometryFactory"}, {"type": "Logger", "name": "myLogger"}]}
{"id": 1680576, "class_signatures": "class BSHType extends SimpleNode\n        implements BSHClassManager.Listener", "class_methods": [{"signature": "BSHType(int id)", "full": "BSHType(int id) {\n        super(id);\n    }"}, {"signature": "public void addArrayDimension()", "full": "public void addArrayDimension() {\n        arrayDims++;\n    }"}, {"signature": "SimpleNode getTypeNode()", "full": "SimpleNode getTypeNode() {\n        return (SimpleNode) jjtGetChild(0);\n    }"}, {"signature": "public String getTypeDescriptor(\n            CallStack callstack, Interpreter interpreter, String defaultPackage)", "full": "public String getTypeDescriptor(\n            CallStack callstack, Interpreter interpreter, String defaultPackage) {\n        if (descriptor != null) {\n            return descriptor;\n        }\n\n        String descriptor;\n        SimpleNode node = getTypeNode();\n        if (node instanceof BSHPrimitiveType) {\n            descriptor = getTypeDescriptor(((BSHPrimitiveType) node).type);\n        } else {\n            String clasName = ((BSHAmbiguousName) node).text;\n            BSHClassManager bcm = interpreter.getClassManager();\n            String definingClass = bcm.getClassBeingDefined(clasName);\n\n            Class clas = null;\n            if (definingClass == null) {\n                try {\n                    clas = ((BSHAmbiguousName) node).toClass(\n                            callstack, interpreter);\n                } catch (EvalError e) {\n                    }\n            } else {\n                clasName = definingClass;\n            }\n\n            if (clas != null) {\n                descriptor = getTypeDescriptor(clas);\n            } else {\n                if (defaultPackage == null || Name.isCompound(clasName)) {\n                    descriptor = \"L\" + clasName.replace('.', '/') + \";\";\n                } else {\n                    descriptor\n                            = \"L\" + defaultPackage.replace('.', '/') + \"/\" + clasName + \";\";\n                }\n            }\n        }\n\n        for (int i = 0; i < arrayDims; i++) {\n            descriptor = \"[\" + descriptor;\n        }\n\n        this.descriptor = descriptor;\n        return descriptor;\n    }"}, {"signature": "public Class getType(CallStack callstack, Interpreter interpreter)\n            throws EvalError", "full": "public Class getType(CallStack callstack, Interpreter interpreter)\n            throws EvalError {\n        if (type != null) {\n            return type;\n        }\n\n        SimpleNode node = getTypeNode();\n        if (node instanceof BSHPrimitiveType) {\n            baseType = ((BSHPrimitiveType) node).getType();\n        } else {\n            baseType = ((BSHAmbiguousName) node).toClass(\n                    callstack, interpreter);\n        }\n\n        if (arrayDims > 0) {\n            try {\n                int[] dims = new int[arrayDims]; Object obj = Array.newInstance(baseType, dims);\n                type = obj.getClass();\n            } catch (Exception e) {\n                throw new EvalError(\"Couldn't construct array type\",\n                        this, callstack);\n            }\n        } else {\n            type = baseType;\n        }\n\n        interpreter.getClassManager().addListener(this);\n\n        return type;\n    }"}, {"signature": "public Class getBaseType()", "full": "public Class getBaseType() {\n        return baseType;\n    }"}, {"signature": "public int getArrayDims()", "full": "public int getArrayDims() {\n        return arrayDims;\n    }"}, {"signature": "public void classLoaderChanged()", "full": "@Override\n    public void classLoaderChanged() {\n        type = null;\n        baseType = null;\n    }"}, {"signature": "public static String getTypeDescriptor(Class clas) \n}", "full": "public static String getTypeDescriptor(Class clas) {\n        if (clas == Boolean.TYPE) {\n            return \"Z\";\n        }\n        if (clas == Character.TYPE) {\n            return \"C\";\n        }\n        if (clas == Byte.TYPE) {\n            return \"B\";\n        }\n        if (clas == Short.TYPE) {\n            return \"S\";\n        }\n        if (clas == Integer.TYPE) {\n            return \"I\";\n        }\n        if (clas == Long.TYPE) {\n            return \"J\";\n        }\n        if (clas == Float.TYPE) {\n            return \"F\";\n        }\n        if (clas == Double.TYPE) {\n            return \"D\";\n        }\n        if (clas == Void.TYPE) {\n            return \"V\";\n        }\n        String name = clas.getName().replace('.', '/');\n\n        if (name.startsWith(\"[\") || name.endsWith(\";\")) {\n            return name;\n        } else {\n            return \"L\" + name.replace('.', '/') + \";\";\n        }\n    }\n}"}], "class_attributes": [{"type": "Class", "name": "baseType"}, {"type": "int", "name": "arrayDims"}, {"type": "Class", "name": "type"}, {"type": "String", "name": "descriptor"}]}
{"id": 1888819, "class_signatures": "public final class FileManager", "class_methods": [{"signature": "private FileManager()", "full": "private FileManager() {}"}, {"signature": "public static FileContents read(String file)", "full": "public static FileContents read(String file) {\n        List<String> data = new ArrayList<>();\n\n        if (!exists(file)) {\n            createFile(file);\n            return new FileContents(data);\n        }\n\n        try {\n            FileReader fileReader = new FileReader(file);\n            BufferedReader bufferedReader = new BufferedReader(fileReader);\n            bufferedReader.lines().forEach(data::add);\n            bufferedReader.close();\n        } catch (IOException ex) {\n            ClientAPI.LOGGER.warn(\"Unable to read from \" + file);\n        }\n\n        return new FileContents(data);\n    }"}, {"signature": "public static void write(List<String> data, String file)", "full": "public static void write(List<String> data, String file) {\n        if (!exists(file)) {\n            createFile(file);\n        }\n        try {\n            FileWriter fw = new FileWriter(file);\n            BufferedWriter bw = new BufferedWriter(fw);\n            for (int i = 0; i < data.size(); i++) {\n                if (i > 0)\n                    bw.newLine();\n\n                bw.write(data.get(i));\n            }\n            bw.close();\n        } catch (IOException e) {\n            ClientAPI.LOGGER.warn(\"Unable to write to \" + file);\n        }\n    }"}, {"signature": "public static void createFile(String file)", "full": "public static void createFile(String file) {\n        try {\n            Files.createDirectories(Paths.get(new File(file).getParent()));\n        } catch (IOException e) {\n            ClientAPI.LOGGER.warn(\"Unable to create parent directories\", e);\n            return;\n        }\n\n        try {\n            Files.createFile(Paths.get(file));\n        } catch (IOException e) {\n            ClientAPI.LOGGER.warn(\"Unable to create file\", e);\n        }\n    }"}, {"signature": "public static boolean exists(String file) \n}", "full": "public static boolean exists(String file) {\n        return Files.exists(Paths.get(file));\n    }\n}"}], "class_attributes": []}
{"id": 1968305, "class_signatures": "public class WorkStream extends Record", "class_methods": [{"signature": "public String getName()", "full": "public String getName() {\n        return name;\n    }"}, {"signature": "public void setName(String name)", "full": "public void setName(String name) {\n        this.name = name;\n    }"}, {"signature": "public String getInstructions()", "full": "public String getInstructions() {\n        return instructions;\n    }"}, {"signature": "public void setInstructions(String instructions)", "full": "public void setInstructions(String instructions) {\n        this.instructions = instructions;\n    }"}, {"signature": "public Set<ToolEntity> getAssignedEntities()", "full": "public Set<ToolEntity> getAssignedEntities() {\n        return assignedEntities;\n    }"}, {"signature": "public void setAssignedEntities(Set<ToolEntity> assignedEntities)", "full": "public void setAssignedEntities(Set<ToolEntity> assignedEntities) {\n        this.assignedEntities = assignedEntities;\n    }"}, {"signature": "public com.psddev.cms.tool.Search getSearch()", "full": "public com.psddev.cms.tool.Search getSearch() {\n        return search;\n    }"}, {"signature": "public void setSearch(com.psddev.cms.tool.Search search)", "full": "public void setSearch(com.psddev.cms.tool.Search search) {\n        this.search = search;\n    }"}, {"signature": "public Query getQuery()", "full": "public Query getQuery() {\n        return query == null && search != null ? search.toQuery() : query;\n    }"}, {"signature": "public void setQuery(Query query)", "full": "public void setQuery(Query query) {\n        this.query = query;\n    }"}, {"signature": "public boolean isIncompleteIfMatching()", "full": "public boolean isIncompleteIfMatching() {\n        return incompleteIfMatching;\n    }"}, {"signature": "public void setIncompleteIfMatching(boolean incompleteIfMatching)", "full": "public void setIncompleteIfMatching(boolean incompleteIfMatching) {\n        this.incompleteIfMatching = incompleteIfMatching;\n    }"}, {"signature": "public List<ToolUser> getUsers()", "full": "public List<ToolUser> getUsers() {\n        return currentItems != null\n                ? Query.from(ToolUser.class).where(\"_id = ?\", currentItems.keySet()).selectAll()\n                : new ArrayList<ToolUser>();\n    }"}, {"signature": "public Object getCurrentItem(ToolUser user)", "full": "public Object getCurrentItem(ToolUser user) {\n        ErrorUtils.errorIfNull(user, \"user\");\n\n        return currentItems != null\n                ? Query.from(Object.class).where(\"_id = ?\", currentItems.get(user.getId().toString())).first()\n                : null;\n    }"}, {"signature": "public long countIncomplete()", "full": "public long countIncomplete() {\n        return getQuery().clone()\n                .and(\"id != ?\", Query.from(Object.class).where(\"cms.workstream.completeIds ^= ?\", getId().toString() + \",\"))\n                .count();\n    }"}, {"signature": "public long countComplete()", "full": "public long countComplete() {\n        return Query.fromAll()\n                .where(\"cms.workstream.completeIds ^= ?\", getId().toString() + \",\")\n                .count();\n    }"}, {"signature": "public long countTotal()", "full": "public long countTotal() {\n        return countIncomplete() + countComplete();\n    }"}, {"signature": "public long countComplete(ToolUser user)", "full": "public long countComplete(ToolUser user) {\n        ErrorUtils.errorIfNull(user, \"user\");\n\n        return Query\n                .from(Object.class)\n                .where(\"cms.workstream.completeIds = ?\", getId().toString() + \",\" + user.getId().toString())\n                .count();\n    }"}, {"signature": "public long countSkipped(ToolUser user)", "full": "public long countSkipped(ToolUser user) {\n        ErrorUtils.errorIfNull(user, \"user\");\n        String userId = user.getId().toString();\n\n        if (skippedItems != null && skippedItems.get(userId) != null) {\n            return skippedItems.get(userId).size();\n        } else {\n            return 0L;\n        }\n    }"}, {"signature": "public boolean isWorking(ToolUser user)", "full": "public boolean isWorking(ToolUser user) {\n        ErrorUtils.errorIfNull(user, \"user\");\n\n        return currentItems != null\n                ? currentItems.get(user.getId().toString()) != null\n                : false;\n    }"}, {"signature": "public Object next(ToolUser user)", "full": "public Object next(ToolUser user) {\n        ErrorUtils.errorIfNull(user, \"user\");\n\n        String userId = user.getId().toString();\n        Site site = user.getCurrentSite();\n        Predicate siteItemsPredicate = null;\n\n        if (site != null) {\n            siteItemsPredicate = site.itemsPredicate();\n        }\n\n        State next = null;\n\n        if (currentItems != null) {\n            Query nextQuery = Query.from(Object.class)\n                    .where(\"_id = ?\", currentItems.get(userId));\n\n            if (siteItemsPredicate != null) {\n                nextQuery.and(siteItemsPredicate);\n            }\n\n            next = State.getInstance(nextQuery.first());\n        }\n\n        if (next != null\n                && (next.as(Data.class).isComplete(this)\n                || (skippedItems != null && skippedItems.get(userId) != null && skippedItems.get(userId).contains(next.getId())))) {\n            next = null;\n        }\n\n        if (next == null) {\n            Query<?> query = getQuery().clone()\n                    .and(\"id != ?\", Query.from(Object.class).where(\"cms.workstream.completeIds ^= ?\", getId().toString() + \",\"));\n\n            if (siteItemsPredicate != null) {\n                query.and(siteItemsPredicate);\n            }\n\n            if (currentItems != null) {\n                Set<UUID> currentItemIds = currentItems.values().stream()\n                        .filter(Objects::nonNull)\n                        .collect(Collectors.toSet());\n\n                if (!currentItemIds.isEmpty()) {\n                    query.and(\"_id != ?\", currentItemIds);\n                }\n            }\n\n            if (skippedItems != null) {\n                List<UUID> skippedItemIds = skippedItems.get(userId);\n\n                if (skippedItemIds != null) {\n                    Set<UUID> uniqueNonNullSkippedItemIds = skippedItemIds.stream()\n                            .filter(Objects::nonNull)\n                            .collect(Collectors.toSet());\n\n                    if (!skippedItemIds.isEmpty()) {\n                        query.and(\"_id != ?\", uniqueNonNullSkippedItemIds);\n                    }\n                }\n            }\n\n            next = State.getInstance(query.first());\n\n            if (next != null) {\n                getState().putAtomically(\"currentItems/\" + userId, next.getId());\n                save();\n            }\n        }\n\n        return next != null ? next.getOriginalObject() : null;\n    }"}, {"signature": "public void skip(ToolUser user, Object item)", "full": "public void skip(ToolUser user, Object item) {\n        ErrorUtils.errorIfNull(user, \"user\");\n\n        getState().addAtomically(\"skippedItems/\" + user.getId().toString(), State.getInstance(item).getId());\n        save();\n    }"}, {"signature": "public void stop(ToolUser user)", "full": "public void stop(ToolUser user) {\n        ErrorUtils.errorIfNull(user, \"user\");\n\n        String userId = user.getId().toString();\n\n        getState().putAtomically(\"currentItems/\" + userId, null);\n        getState().putAtomically(\"skippedItems/\" + userId, null);\n        save();\n    }"}], "class_attributes": [{"type": "String", "name": "name"}, {"type": "String", "name": "instructions"}, {"type": "com", "name": "search"}, {"type": "Query", "name": "query"}, {"type": "boolean", "name": "incompleteIfMatching"}, {"type": "Map", "name": "currentItems"}, {"type": "Set", "name": "assignedEntities"}, {"type": "Map", "name": "skippedItems"}]}
{"id": 2093621, "class_signatures": "JsonWriter implements Closeable, Flushable", "class_methods": [{"signature": "public JsonWriter(Writer out)", "full": "public JsonWriter(Writer out) {\n        if (out == null) {\n            throw new NullPointerException(\"out == null\");\n        }\n        this.out = out;\n    }"}, {"signature": "public final void setIndent(String indent)", "full": "public final void setIndent(String indent) {\n        if (indent.length() == 0) {\n            this.indent = null;\n            this.separator = \":\";\n        } else {\n            this.indent = indent;\n            this.separator = \": \";\n        }\n    }"}, {"signature": "public final void setLenient(boolean lenient)", "full": "public final void setLenient(boolean lenient) {\n        this.lenient = lenient;\n    }"}, {"signature": "public boolean isLenient()", "full": "public boolean isLenient() {\n        return lenient;\n    }"}, {"signature": "public final void setHtmlSafe(boolean htmlSafe)", "full": "public final void setHtmlSafe(boolean htmlSafe) {\n        this.htmlSafe = htmlSafe;\n    }"}, {"signature": "public final boolean isHtmlSafe()", "full": "public final boolean isHtmlSafe() {\n        return htmlSafe;\n    }"}, {"signature": "public final void setSerializeNulls(boolean serializeNulls)", "full": "public final void setSerializeNulls(boolean serializeNulls) {\n        this.serializeNulls = serializeNulls;\n    }"}, {"signature": "public final boolean getSerializeNulls()", "full": "public final boolean getSerializeNulls() {\n        return serializeNulls;\n    }"}, {"signature": "public JsonWriter beginArray() throws IOException", "full": "public JsonWriter beginArray() throws IOException {\n        writeDeferredName();\n        return open(EMPTY_ARRAY, \"[\");\n    }"}, {"signature": "public JsonWriter endArray() throws IOException", "full": "public JsonWriter endArray() throws IOException {\n        return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n    }"}, {"signature": "public JsonWriter beginObject() throws IOException", "full": "public JsonWriter beginObject() throws IOException {\n        writeDeferredName();\n        return open(EMPTY_OBJECT, \"{\");\n    }"}, {"signature": "public JsonWriter endObject() throws IOException", "full": "public JsonWriter endObject() throws IOException {\n        return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n    }"}, {"signature": "private JsonWriter open(int empty, String openBracket) throws IOException", "full": "private JsonWriter open(int empty, String openBracket) throws IOException {\n        beforeValue();\n        push(empty);\n        out.write(openBracket);\n        return this;\n    }"}, {"signature": "private JsonWriter close(int empty, int nonempty, String closeBracket)\n        throws IOException", "full": "private JsonWriter close(int empty, int nonempty, String closeBracket)\n        throws IOException {\n        int context = peek();\n        if (context != nonempty && context != empty) {\n            throw new IllegalStateException(\"Nesting problem.\");\n        }\n        if (deferredName != null) {\n            throw new IllegalStateException(\"Dangling name: \" + deferredName);\n        }\n\n        stackSize--;\n        if (context == nonempty) {\n            newline();\n        }\n        out.write(closeBracket);\n        return this;\n    }"}, {"signature": "private void push(int newTop)", "full": "private void push(int newTop) {\n        if (stackSize == stack.length) {\n            int[] newStack = new int[stackSize * 2];\n            System.arraycopy(stack, 0, newStack, 0, stackSize);\n            stack = newStack;\n        }\n        stack[stackSize++] = newTop;\n    }"}, {"signature": "private int peek()", "full": "private int peek() {\n        if (stackSize == 0) {\n            throw new IllegalStateException(\"JsonWriter is closed.\");\n        }\n        return stack[stackSize - 1];\n    }"}, {"signature": "private void replaceTop(int topOfStack)", "full": "private void replaceTop(int topOfStack) {\n        stack[stackSize - 1] = topOfStack;\n    }"}, {"signature": "public JsonWriter name(String name) throws IOException", "full": "public JsonWriter name(String name) throws IOException {\n        if (name == null) {\n            throw new NullPointerException(\"name == null\");\n        }\n        if (deferredName != null) {\n            throw new IllegalStateException();\n        }\n        if (stackSize == 0) {\n            throw new IllegalStateException(\"JsonWriter is closed.\");\n        }\n        deferredName = name;\n        return this;\n    }"}, {"signature": "private void writeDeferredName() throws IOException", "full": "private void writeDeferredName() throws IOException {\n        if (deferredName != null) {\n            beforeName();\n            string(deferredName);\n            deferredName = null;\n        }\n    }"}, {"signature": "public JsonWriter value(String value) throws IOException", "full": "public JsonWriter value(String value) throws IOException {\n        if (value == null) {\n            return nullValue();\n        }\n        writeDeferredName();\n        beforeValue();\n        string(value);\n        return this;\n    }"}, {"signature": "public JsonWriter jsonValue(String value) throws IOException", "full": "public JsonWriter jsonValue(String value) throws IOException {\n        if (value == null) {\n            return nullValue();\n        }\n        writeDeferredName();\n        beforeValue();\n        out.append(value);\n        return this;\n    }"}, {"signature": "public JsonWriter nullValue() throws IOException", "full": "public JsonWriter nullValue() throws IOException {\n        if (deferredName != null) {\n            if (serializeNulls) {\n                writeDeferredName();\n            } else {\n                deferredName = null;\n                return this; }\n        }\n        beforeValue();\n        out.write(\"null\");\n        return this;\n    }"}, {"signature": "public void flush() throws IOException", "full": "public void flush() throws IOException {\n        if (stackSize == 0) {\n            throw new IllegalStateException(\"JsonWriter is closed.\");\n        }\n        out.flush();\n    }"}, {"signature": "public void close() throws IOException", "full": "public void close() throws IOException {\n        out.close();\n\n        int size = stackSize;\n        if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {\n            throw new IOException(\"Incomplete document\");\n        }\n        stackSize = 0;\n    }"}, {"signature": "private void string(String value) throws IOException", "full": "private void string(String value) throws IOException {\n        String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n        out.write(\"\\\"\");\n        int last = 0;\n        int length = value.length();\n        for (int i = 0; i < length; i++) {\n            char c = value.charAt(i);\n            String replacement;\n            if (c < 128) {\n                replacement = replacements[c];\n                if (replacement == null) {\n                    continue;\n                }\n            } else if (c == '\\u2028') {\n                replacement = \"\\\\u2028\";\n            } else if (c == '\\u2029') {\n                replacement = \"\\\\u2029\";\n            } else {\n                continue;\n            }\n            if (last < i) {\n                out.write(value, last, i - last);\n            }\n            out.write(replacement);\n            last = i + 1;\n        }\n        if (last < length) {\n            out.write(value, last, length - last);\n        }\n        out.write(\"\\\"\");\n    }"}, {"signature": "private void newline() throws IOException", "full": "private void newline() throws IOException {\n        if (indent == null) {\n            return;\n        }\n\n        out.write(\"\\n\");\n        for (int i = 1, size = stackSize; i < size; i++) {\n            out.write(indent);\n        }\n    }"}, {"signature": "private void beforeName() throws IOException", "full": "private void beforeName() throws IOException {\n        int context = peek();\n        if (context == NONEMPTY_OBJECT) { out.write(',');\n        } else if (context != EMPTY_OBJECT) { throw new IllegalStateException(\"Nesting problem.\");\n        }\n        newline();\n        replaceTop(DANGLING_NAME);\n    }"}, {"signature": "void beforeValue() throws IOException \n}", "full": "@SuppressWarnings(\"fallthrough\")\n    void beforeValue() throws IOException {\n        switch (peek()) {\n            case NONEMPTY_DOCUMENT:\n                if (!lenient) {\n                    throw new IllegalStateException(\n                        \"JSON must have only one top-level value.\");\n                }\n                case EMPTY_DOCUMENT: replaceTop(NONEMPTY_DOCUMENT);\n                break;\n\n            case EMPTY_ARRAY: replaceTop(NONEMPTY_ARRAY);\n                newline();\n                break;\n\n            case NONEMPTY_ARRAY: out.append(',');\n                newline();\n                break;\n\n            case DANGLING_NAME: out.append(separator);\n                replaceTop(NONEMPTY_OBJECT);\n                break;\n\n            default:\n                throw new IllegalStateException(\"Nesting problem.\");\n        }\n    }\n}"}], "class_attributes": [{"type": "String", "name": "REPLACEMENT_CHARS"}, {"type": "String", "name": "HTML_SAFE_REPLACEMENT_CHARS"}, {"type": "Writer", "name": "out"}, {"type": "int", "name": "stack"}, {"type": "int", "name": "stackSize"}, {"type": "String", "name": "indent"}, {"type": "String", "name": "separator"}, {"type": "boolean", "name": "lenient"}, {"type": "boolean", "name": "htmlSafe"}, {"type": "String", "name": "deferredName"}, {"type": "boolean", "name": "serializeNulls"}]}
{"id": 2125149, "class_signatures": "public class TrendChannel extends Base", "class_methods": [{"signature": "public void zIndex()", "full": "public void zIndex() {\n        APIlib.getInstance().addJSLine(jsBase + \".zIndex();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel zIndex(Number zIndex)", "full": "public com.anychart.core.annotations.TrendChannel zIndex(Number zIndex) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".zIndex(%s);\", zIndex));\n\n        return this;\n    }"}, {"signature": "public com.anychart.graphics.vector.Layer container()", "full": "public com.anychart.graphics.vector.Layer container() {\n        return new com.anychart.graphics.vector.Layer(jsBase + \".container()\");\n    }"}, {"signature": "public void height()", "full": "public void height() {\n        APIlib.getInstance().addJSLine(jsBase + \".height();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel height(Number height)", "full": "public com.anychart.core.annotations.TrendChannel height(Number height) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".height(%s);\", height));\n\n        return this;\n    }"}, {"signature": "public void left()", "full": "public void left() {\n        APIlib.getInstance().addJSLine(jsBase + \".left();\");\n    }"}, {"signature": "protected TrendChannel()", "full": "protected TrendChannel() {\n\n    }"}, {"signature": "public TrendChannel(String jsChart)", "full": "public TrendChannel(String jsChart) {\n        jsBase = \"trendChannel\" + ++variableIndex;\n        APIlib.getInstance().addJSLine(jsBase + \" = \" + jsChart + \";\");\n    }"}, {"signature": "public static TrendChannel instantiate()", "full": "public static TrendChannel instantiate() {\n        return new TrendChannel(\"new anychart.core.annotations.trendChannel()\");\n    }"}, {"signature": "public String getJsBase()", "full": "public String getJsBase() {\n        return jsBase;\n    }"}, {"signature": "public void allowEdit()", "full": "public void allowEdit() {\n        APIlib.getInstance().addJSLine(jsBase + \".allowEdit();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel allowEdit(String value)", "full": "public com.anychart.core.annotations.TrendChannel allowEdit(String value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".allowEdit(%s);\", wrapQuotes(value)));\n\n        return this;\n    }"}, {"signature": "public void color()", "full": "public void color() {\n        APIlib.getInstance().addJSLine(jsBase + \".color();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel color(String color)", "full": "public com.anychart.core.annotations.TrendChannel color(String color) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".color(%s);\", wrapQuotes(color)));\n\n        return this;\n    }"}, {"signature": "public void fill()", "full": "public void fill() {\n        APIlib.getInstance().addJSLine(jsBase + \".fill();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel fill(com.anychart.graphics.vector.Fill color)", "full": "public com.anychart.core.annotations.TrendChannel fill(com.anychart.graphics.vector.Fill color) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fill(%s);\", (color != null) ? color.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel fill(String color, Number opacity)", "full": "public com.anychart.core.annotations.TrendChannel fill(String color, Number opacity) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fill(%s, %s);\", wrapQuotes(color), opacity));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel fill(com.anychart.graphics.vector.GradientKey keys, Number angle, Boolean mode, Number opacity)", "full": "public com.anychart.core.annotations.TrendChannel fill(com.anychart.graphics.vector.GradientKey keys, Number angle, Boolean mode, Number opacity) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fill(%s, %s, %s, %s);\", (keys != null) ? keys.getJsBase() : null, angle, mode, opacity));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel selected(String settings)", "full": "public com.anychart.core.annotations.TrendChannel selected(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".selected(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public void stroke()", "full": "public void stroke() {\n        APIlib.getInstance().addJSLine(jsBase + \".stroke();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel fill(com.anychart.graphics.vector.GradientKey keys, Number cx, Number cy, com.anychart.graphics.math.Rect mode, Number opacity, Number fx, Number fy)", "full": "public com.anychart.core.annotations.TrendChannel fill(com.anychart.graphics.vector.GradientKey keys, Number cx, Number cy, com.anychart.graphics.math.Rect mode, Number opacity, Number fx, Number fy) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fill(%s, %s, %s, %s, %s, %s, %s);\", (keys != null) ? keys.getJsBase() : null, cx, cy, (mode != null) ? mode.getJsBase() : null, opacity, fx, fy));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.SeparateChart getChart()", "full": "public com.anychart.core.SeparateChart getChart() {\n        return new com.anychart.core.SeparateChart(jsBase + \".getChart()\");\n    }"}, {"signature": "public com.anychart.core.stock.Plot getPlot()", "full": "public com.anychart.core.stock.Plot getPlot() {\n        return new com.anychart.core.stock.Plot(jsBase + \".getPlot()\");\n    }"}, {"signature": "public void getType()", "full": "public void getType() {\n        APIlib.getInstance().addJSLine(jsBase + \".getType();\");\n    }"}, {"signature": "public com.anychart.graphics.vector.PatternFill hatchFill()", "full": "public com.anychart.graphics.vector.PatternFill hatchFill() {\n        return new com.anychart.graphics.vector.PatternFill(jsBase + \".hatchFill()\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel hatchFill(com.anychart.graphics.vector.hatchfill.HatchFillType type, String color, Number thickness, Number size)", "full": "public com.anychart.core.annotations.TrendChannel hatchFill(com.anychart.graphics.vector.hatchfill.HatchFillType type, String color, Number thickness, Number size) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".hatchFill(%s, %s, %s, %s);\", (type != null) ? type.getJsBase() : null, wrapQuotes(color), thickness, size));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel hatchFill(String hatchFillFunction)", "full": "public com.anychart.core.annotations.TrendChannel hatchFill(String hatchFillFunction) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".hatchFill(%s);\", wrapQuotes(hatchFillFunction)));\n\n        return this;\n    }"}, {"signature": "public void hoverGap()", "full": "public void hoverGap() {\n        APIlib.getInstance().addJSLine(jsBase + \".hoverGap();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel hoverGap(String value)", "full": "public com.anychart.core.annotations.TrendChannel hoverGap(String value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".hoverGap(%s);\", wrapQuotes(value)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.StateSettings hovered()", "full": "public com.anychart.core.StateSettings hovered() {\n        return new com.anychart.core.StateSettings(jsBase + \".hovered()\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel hovered(String settings)", "full": "public com.anychart.core.annotations.TrendChannel hovered(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".hovered(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.MarkersFactory markers()", "full": "public com.anychart.core.ui.MarkersFactory markers() {\n        return new com.anychart.core.ui.MarkersFactory(jsBase + \".markers()\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel markers(String settings)", "full": "public com.anychart.core.annotations.TrendChannel markers(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".markers(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.StateSettings normal()", "full": "public com.anychart.core.StateSettings normal() {\n        return new com.anychart.core.StateSettings(jsBase + \".normal()\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel normal(String settings)", "full": "public com.anychart.core.annotations.TrendChannel normal(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".normal(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public void secondValueAnchor()", "full": "public void secondValueAnchor() {\n        APIlib.getInstance().addJSLine(jsBase + \".secondValueAnchor();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel secondValueAnchor(String value)", "full": "public com.anychart.core.annotations.TrendChannel secondValueAnchor(String value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".secondValueAnchor(%s);\", wrapQuotes(value)));\n\n        return this;\n    }"}, {"signature": "public void secondXAnchor()", "full": "public void secondXAnchor() {\n        APIlib.getInstance().addJSLine(jsBase + \".secondXAnchor();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel secondXAnchor(String value)", "full": "public com.anychart.core.annotations.TrendChannel secondXAnchor(String value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".secondXAnchor(%s);\", wrapQuotes(value)));\n\n        return this;\n    }"}, {"signature": "public void select()", "full": "public void select() {\n        APIlib.getInstance().addJSLine(jsBase + \".select();\");\n    }"}, {"signature": "public com.anychart.core.StateSettings selected()", "full": "public com.anychart.core.StateSettings selected() {\n        return new com.anychart.core.StateSettings(jsBase + \".selected()\");\n    }"}, {"signature": "public com.anychart.math.Rect getPixelBounds()", "full": "public com.anychart.math.Rect getPixelBounds() {\n        return new com.anychart.math.Rect(jsBase + \".getPixelBounds()\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel stroke(com.anychart.graphics.vector.Stroke color, Number thickness, String dashpattern, String lineJoin, String lineCap)", "full": "public com.anychart.core.annotations.TrendChannel stroke(com.anychart.graphics.vector.Stroke color, Number thickness, String dashpattern, String lineJoin, String lineCap) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".stroke(%s, %s, %s, %s, %s);\", (color != null) ? color.getJsBase() : null, thickness, wrapQuotes(dashpattern), wrapQuotes(lineJoin), wrapQuotes(lineCap)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel stroke(String settings)", "full": "public com.anychart.core.annotations.TrendChannel stroke(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".stroke(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public void thirdValueAnchor()", "full": "public void thirdValueAnchor() {\n        APIlib.getInstance().addJSLine(jsBase + \".thirdValueAnchor();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel thirdValueAnchor(String value)", "full": "public com.anychart.core.annotations.TrendChannel thirdValueAnchor(String value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".thirdValueAnchor(%s);\", wrapQuotes(value)));\n\n        return this;\n    }"}, {"signature": "public void thirdXAnchor()", "full": "public void thirdXAnchor() {\n        APIlib.getInstance().addJSLine(jsBase + \".thirdXAnchor();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel thirdXAnchor(String value)", "full": "public com.anychart.core.annotations.TrendChannel thirdXAnchor(String value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".thirdXAnchor(%s);\", wrapQuotes(value)));\n\n        return this;\n    }"}, {"signature": "public void valueAnchor()", "full": "public void valueAnchor() {\n        APIlib.getInstance().addJSLine(jsBase + \".valueAnchor();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel valueAnchor(String value)", "full": "public com.anychart.core.annotations.TrendChannel valueAnchor(String value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".valueAnchor(%s);\", wrapQuotes(value)));\n\n        return this;\n    }"}, {"signature": "public void xAnchor()", "full": "public void xAnchor() {\n        APIlib.getInstance().addJSLine(jsBase + \".xAnchor();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel xAnchor(String value)", "full": "public com.anychart.core.annotations.TrendChannel xAnchor(String value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".xAnchor(%s);\", wrapQuotes(value)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.scales.Ordinal xScale()", "full": "public com.anychart.scales.Ordinal xScale() {\n        return new com.anychart.scales.Ordinal(jsBase + \".xScale()\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel xScale(com.anychart.scales.Base settings)", "full": "public com.anychart.core.annotations.TrendChannel xScale(com.anychart.scales.Base settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".xScale(%s);\", (settings != null) ? settings.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public com.anychart.scales.Base yScale()", "full": "public com.anychart.scales.Base yScale() {\n        return new com.anychart.scales.Base(jsBase + \".yScale()\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel yScale(com.anychart.scales.Base settings)", "full": "public com.anychart.core.annotations.TrendChannel yScale(com.anychart.scales.Base settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".yScale(%s);\", (settings != null) ? settings.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void bottom()", "full": "public void bottom() {\n        APIlib.getInstance().addJSLine(jsBase + \".bottom();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel bottom(Number bottom)", "full": "public com.anychart.core.annotations.TrendChannel bottom(Number bottom) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".bottom(%s);\", bottom));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.utils.Bounds bounds()", "full": "public com.anychart.core.utils.Bounds bounds() {\n        return new com.anychart.core.utils.Bounds(jsBase + \".bounds()\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel bounds(com.anychart.utils.RectObj bounds)", "full": "public com.anychart.core.annotations.TrendChannel bounds(com.anychart.utils.RectObj bounds) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".bounds(%s);\", (bounds != null) ? bounds.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel bounds(Number x, Number y, Number width, Number height)", "full": "public com.anychart.core.annotations.TrendChannel bounds(Number x, Number y, Number width, Number height) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".bounds(%s, %s, %s, %s);\", x, y, width, height));\n\n        return this;\n    }"}, {"signature": "public void enabled()", "full": "public void enabled() {\n        APIlib.getInstance().addJSLine(jsBase + \".enabled();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel enabled(Boolean enabled)", "full": "public com.anychart.core.annotations.TrendChannel enabled(Boolean enabled) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".enabled(%s);\", enabled));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel width(Number width)", "full": "public com.anychart.core.annotations.TrendChannel width(Number width) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".width(%s);\", width));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel left(Number left)", "full": "public com.anychart.core.annotations.TrendChannel left(Number left) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".left(%s);\", left));\n\n        return this;\n    }"}, {"signature": "public void maxHeight()", "full": "public void maxHeight() {\n        APIlib.getInstance().addJSLine(jsBase + \".maxHeight();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel maxHeight(Number height)", "full": "public com.anychart.core.annotations.TrendChannel maxHeight(Number height) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".maxHeight(%s);\", height));\n\n        return this;\n    }"}, {"signature": "public void maxWidth()", "full": "public void maxWidth() {\n        APIlib.getInstance().addJSLine(jsBase + \".maxWidth();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel maxWidth(Number width)", "full": "public com.anychart.core.annotations.TrendChannel maxWidth(Number width) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".maxWidth(%s);\", width));\n\n        return this;\n    }"}, {"signature": "public void minHeight()", "full": "public void minHeight() {\n        APIlib.getInstance().addJSLine(jsBase + \".minHeight();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel minHeight(Number height)", "full": "public com.anychart.core.annotations.TrendChannel minHeight(Number height) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".minHeight(%s);\", height));\n\n        return this;\n    }"}, {"signature": "public void minWidth()", "full": "public void minWidth() {\n        APIlib.getInstance().addJSLine(jsBase + \".minWidth();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel minWidth(Number width)", "full": "public com.anychart.core.annotations.TrendChannel minWidth(Number width) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".minWidth(%s);\", width));\n\n        return this;\n    }"}, {"signature": "public void print(com.anychart.graphics.vector.PaperSize paperSizeOrOptions, Boolean landscape)", "full": "public void print(com.anychart.graphics.vector.PaperSize paperSizeOrOptions, Boolean landscape) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".print(%s, %s);\", (paperSizeOrOptions != null) ? paperSizeOrOptions.getJsBase() : null, landscape));\n    }"}, {"signature": "public void removeAllListeners(String type)", "full": "public void removeAllListeners(String type) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".removeAllListeners(%s);\", wrapQuotes(type)));\n    }"}, {"signature": "public void right()", "full": "public void right() {\n        APIlib.getInstance().addJSLine(jsBase + \".right();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel right(Number right)", "full": "public com.anychart.core.annotations.TrendChannel right(Number right) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".right(%s);\", right));\n\n        return this;\n    }"}, {"signature": "public void top()", "full": "public void top() {\n        APIlib.getInstance().addJSLine(jsBase + \".top();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel top(Number top)", "full": "public com.anychart.core.annotations.TrendChannel top(Number top) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".top(%s);\", top));\n\n        return this;\n    }"}, {"signature": "public void setOnClickListener(com.anychart.chart.common.listener.ListenersInterface.OnClickListener listener)", "full": "public void setOnClickListener(com.anychart.chart.common.listener.ListenersInterface.OnClickListener listener) {\n        StringBuilder js = new StringBuilder();\n\n        js.append(jsBase).append(\".listen('pointClick', function(e) {\");\n\n        if (listener.getFields() != null) {\n            js.append(\"var result = \");\n            for (String field : listener.getFields()) {\n                js.append(String.format(Locale.US, \"'%1$s' + ':' + e.point.get('%1$s') + ',' +\", field));\n            }\n            js.setLength(js.length() - 8);\n            js.append(\";\");\n\n            js.append(\"android.onClick(result);\");\n        } else {\n            js.append(\"android.onClick(null);\");\n        }\n        js.append(\"});\");\n\n        com.anychart.chart.common.listener.ListenersInterface.getInstance().setOnClickListener(listener);\n\n        APIlib.getInstance().addJSLine(js.toString());\n    }"}, {"signature": "public void setOnClickListener(com.anychart.chart.common.listener.ListenersInterface.OnClickListener listener, String type, String ePath)", "full": "public void setOnClickListener(com.anychart.chart.common.listener.ListenersInterface.OnClickListener listener, String type, String ePath) {\n        StringBuilder js = new StringBuilder();\n\n        js.append(jsBase).append(String.format(Locale.US, \".listen('%1$s', function(e) {\", type));\n\n        if (listener.getFields() != null) {\n            ePath = (ePath != null) ? ePath + \".\" : \"\";\n            js.append(\"var result = \");\n            for (String field : listener.getFields()) {\n                js.append(String.format(Locale.US, \"'%1$s' + ':' + e.%2$s%1$s + ',' +\", field, ePath));\n            }\n            js.setLength(js.length() - 8);\n            js.append(\";\");\n\n            js.append(\"android.onClick(result);\");\n        } else {\n            js.append(\"android.onClick(null);\");\n        }\n        js.append(\"});\");\n\n        com.anychart.chart.common.listener.ListenersInterface.getInstance().setOnClickListener(listener);\n\n        APIlib.getInstance().addJSLine(js.toString());\n    }"}, {"signature": "public void unlistenByKey(String key)", "full": "public void unlistenByKey(String key) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".unlistenByKey(%s);\", wrapQuotes(key)));\n    }"}, {"signature": "public void width()", "full": "public void width() {\n        APIlib.getInstance().addJSLine(jsBase + \".width();\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel container(com.anychart.graphics.vector.Layer element)", "full": "public com.anychart.core.annotations.TrendChannel container(com.anychart.graphics.vector.Layer element) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".container(%s);\", (element != null) ? element.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public com.anychart.math.Rect parentBounds()", "full": "public com.anychart.math.Rect parentBounds() {\n        return new com.anychart.math.Rect(jsBase + \".parentBounds()\");\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel parentBounds(com.anychart.math.Rect bounds)", "full": "public com.anychart.core.annotations.TrendChannel parentBounds(com.anychart.math.Rect bounds) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".parentBounds(%s);\", (bounds != null) ? bounds.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.annotations.TrendChannel parentBounds(Number left, Number top, Number width, Number height)", "full": "public com.anychart.core.annotations.TrendChannel parentBounds(Number left, Number top, Number width, Number height) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".parentBounds(%s, %s, %s, %s);\", left, top, width, height));\n\n        return this;\n    }"}, {"signature": "public Object xScale(Class scaleClass)", "full": "public Object xScale(Class scaleClass) {\n        Object instance = null;\n        try {\n            instance = scaleClass.getDeclaredConstructor(String.class).newInstance(jsBase + \".xScale()\");\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (java.lang.reflect.InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }"}, {"signature": "public Object yScale(Class scaleClass) \n\n}", "full": "public Object yScale(Class scaleClass) {\n        Object instance = null;\n        try {\n            instance = scaleClass.getDeclaredConstructor(String.class).newInstance(jsBase + \".yScale()\");\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (java.lang.reflect.InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        return instance;\n    }\n\n}"}], "class_attributes": []}
{"id": 2238897, "class_signatures": "public class SimplePipelineExecutor<R extends PipelineRequest, P extends Pipeline<R>>\n    implements PipelineExecutor<R,P>", "class_methods": [{"signature": "public SimplePipelineExecutor(ExecutorService executorService)", "full": "public SimplePipelineExecutor(ExecutorService executorService) {\n        this.executorService = executorService;\n    }"}, {"signature": "public SimplePipelineExecutor<R,P> setConcurrency(int concurrency)", "full": "@Override\n    public SimplePipelineExecutor<R,P> setConcurrency(int concurrency) {\n        this.concurrency = concurrency;\n        return this;\n    }"}, {"signature": "public SimplePipelineExecutor<R,P> setPipelineProvider(PipelineProvider<P> provider)", "full": "@Override\n    public SimplePipelineExecutor<R,P> setPipelineProvider(PipelineProvider<P> provider) {\n        this.provider = provider;\n        return this;\n    }"}, {"signature": "public SimplePipelineExecutor<R,P> setQueue(BlockingQueue<R> queue)", "full": "@Override\n    public SimplePipelineExecutor<R,P> setQueue(BlockingQueue<R> queue) {\n        if (queue == null) {\n            throw new IllegalArgumentException(\"null queue is not accepted\");\n        }\n        this.queue = queue;\n        return this;\n    }"}, {"signature": "public SimplePipelineExecutor<R,P> setSink(PipelineSink<R> sink)", "full": "@Override\n    public SimplePipelineExecutor<R,P> setSink(PipelineSink<R> sink) {\n        this.sink = sink;\n        return this;\n    }"}, {"signature": "public SimplePipelineExecutor<R,P> prepare()", "full": "@Override\n    public SimplePipelineExecutor<R,P> prepare() {\n        if (provider == null) {\n            throw new IllegalStateException(\"no provider set\");\n        }\n        if (queue == null) {\n            throw new IllegalStateException(\"no queue set\");\n        }\n        this.pipelines = new LinkedList<>();\n        if (concurrency < 1) {\n            concurrency = 1;\n        }\n        for (int i = 0; i < Math.min(concurrency, 256); i++) {\n            pipelines.add(provider.get().setQueue(queue));\n        }\n        return this;\n    }"}, {"signature": "public SimplePipelineExecutor<R,P> execute()", "full": "@Override\n    public SimplePipelineExecutor<R,P> execute() {\n        if (pipelines == null) {\n            prepare();\n        }\n        if (pipelines.isEmpty()) {\n            throw new IllegalStateException(\"pipelines empty\");\n        }\n        futures = new LinkedList<>();\n        for (Callable<R> pipeline : pipelines) {\n            futures.add(executorService.submit(pipeline));\n        }\n        return this;\n    }"}, {"signature": "public SimplePipelineExecutor<R,P> waitFor()\n            throws InterruptedException, ExecutionException", "full": "@Override\n    public SimplePipelineExecutor<R,P> waitFor()\n            throws InterruptedException, ExecutionException {\n        if (executorService == null || pipelines == null || futures == null || futures.isEmpty()) {\n            return this;\n        }\n        exceptions = new LinkedList<>();\n        for (Future<R> future : futures) {\n            R r = future.get();\n            if (sink != null && !future.isCancelled()) {\n                try {\n                    sink.sink(r);\n                } catch (IOException e) {\n                    exceptions.add(e);\n                }\n            }\n        }\n        return this;\n    }"}, {"signature": "public void shutdown() throws InterruptedException, IOException", "full": "@Override\n    public void shutdown() throws InterruptedException, IOException {\n    }"}, {"signature": "public Collection<Pipeline<R>> getPipelines()", "full": "@Override\n    public Collection<Pipeline<R>> getPipelines() {\n        return pipelines;\n    }"}, {"signature": "public List<Throwable> getExceptions() \n\n}", "full": "public List<Throwable> getExceptions() {\n        return exceptions;\n    }\n\n}"}], "class_attributes": [{"type": "ExecutorService", "name": "executorService"}, {"type": "BlockingQueue", "name": "queue"}, {"type": "Collection", "name": "pipelines"}, {"type": "Collection", "name": "futures"}, {"type": "PipelineProvider", "name": "provider"}, {"type": "PipelineSink", "name": "sink"}, {"type": "List", "name": "exceptions"}, {"type": "int", "name": "concurrency"}]}
{"id": 2261769, "class_signatures": "public class ECKey implements Serializable", "class_methods": [{"signature": "public ECKey()", "full": "public ECKey() {\n        this(secureRandom);\n    }"}, {"signature": "public ECKey(Provider provider, SecureRandom secureRandom)", "full": "public ECKey(Provider provider, SecureRandom secureRandom) {\n        this.provider = provider;\n\n        final KeyPairGenerator keyPairGen = ECKeyPairGenerator.getInstance(provider, secureRandom);\n        final KeyPair keyPair = keyPairGen.generateKeyPair();\n\n        this.privKey = keyPair.getPrivate();\n\n        final PublicKey pubKey = keyPair.getPublic();\n        if (pubKey instanceof BCECPublicKey) {\n            pub = ((BCECPublicKey) pubKey).getQ();\n        } else if (pubKey instanceof ECPublicKey) {\n            pub = extractPublicKey((ECPublicKey) pubKey);\n        } else {\n            throw new AssertionError(\n                    \"Expected Provider \" + provider.getName()\n                            + \" to produce a subtype of ECPublicKey, found \"\n                            + pubKey.getClass());\n        }\n    }"}, {"signature": "public ECKey(SecureRandom secureRandom)", "full": "public ECKey(SecureRandom secureRandom) {\n        this(GSCCastleProvider.getInstance(), secureRandom);\n    }"}, {"signature": "public ECKey(Provider provider, @Nullable PrivateKey privKey, ECPoint pub)", "full": "public ECKey(Provider provider, @Nullable PrivateKey privKey, ECPoint pub) {\n        this.provider = provider;\n\n        if (privKey == null || isECPrivateKey(privKey)) {\n            this.privKey = privKey;\n        } else {\n            throw new IllegalArgumentException(\n                    \"Expected EC private key, given a private key object with\" +\n                            \" class \"\n                            + privKey.getClass().toString() +\n                            \" and algorithm \"\n                            + privKey.getAlgorithm());\n        }\n\n        if (pub == null) {\n            throw new IllegalArgumentException(\"Public key may not be null\");\n        } else {\n            this.pub = pub;\n        }\n    }"}, {"signature": "private static ECPoint extractPublicKey(final ECPublicKey ecPublicKey)", "full": "private static ECPoint extractPublicKey(final ECPublicKey ecPublicKey) {\n        final java.security.spec.ECPoint publicPointW = ecPublicKey.getW();\n        final BigInteger xCoord = publicPointW.getAffineX();\n        final BigInteger yCoord = publicPointW.getAffineY();\n\n        return CURVE.getCurve().createPoint(xCoord, yCoord);\n    }"}, {"signature": "private static boolean isECPrivateKey(PrivateKey privKey)", "full": "private static boolean isECPrivateKey(PrivateKey privKey) {\n        return privKey instanceof ECPrivateKey || privKey.getAlgorithm()\n                .equals(\"EC\");\n    }"}, {"signature": "private static PrivateKey privateKeyFromBigInteger(BigInteger priv)", "full": "private static PrivateKey privateKeyFromBigInteger(BigInteger priv) {\n        if (priv == null) {\n            return null;\n        } else {\n            try {\n                return ECKeyFactory\n                        .getInstance(GSCCastleProvider.getInstance())\n                        .generatePrivate(new ECPrivateKeySpec(priv,\n                                CURVE_SPEC));\n            } catch (InvalidKeySpecException ex) {\n                throw new AssertionError(\"Assumed correct key spec statically\");\n            }\n        }\n    }"}, {"signature": "public static ECPoint compressPoint(ECPoint uncompressed)", "full": "public static ECPoint compressPoint(ECPoint uncompressed) {\n        return CURVE.getCurve().decodePoint(uncompressed.getEncoded(true));\n    }"}, {"signature": "public static ECPoint decompressPoint(ECPoint compressed)", "full": "public static ECPoint decompressPoint(ECPoint compressed) {\n        return CURVE.getCurve().decodePoint(compressed.getEncoded(false));\n    }"}, {"signature": "public boolean verify(byte[] data, byte[] signature)", "full": "public boolean verify(byte[] data, byte[] signature) {\n        return ECKey.verify(data, signature, getPubKey());\n    }"}, {"signature": "public static ECKey fromPrivate(BigInteger privKey)", "full": "public static ECKey fromPrivate(BigInteger privKey) {\n        return new ECKey(privKey, CURVE.getG().multiply(privKey));\n    }"}, {"signature": "public static ECKey fromPrivateAndPrecalculatedPublic(BigInteger priv,\n                                                          ECPoint pub)", "full": "public static ECKey fromPrivateAndPrecalculatedPublic(BigInteger priv,\n                                                          ECPoint pub) {\n        return new ECKey(priv, pub);\n    }"}, {"signature": "public static ECKey fromPublicOnly(ECPoint pub)", "full": "public static ECKey fromPublicOnly(ECPoint pub) {\n        return new ECKey(null, pub);\n    }"}, {"signature": "public static byte[] publicKeyFromPrivate(BigInteger privKey, boolean\n            compressed)", "full": "public static byte[] publicKeyFromPrivate(BigInteger privKey, boolean\n            compressed) {\n        ECPoint point = CURVE.getG().multiply(privKey);\n        return point.getEncoded(compressed);\n    }"}, {"signature": "public static byte[] computeAddress(byte[] pubBytes)", "full": "public static byte[] computeAddress(byte[] pubBytes) {\n        return Hash.sha3omit12(\n                Arrays.copyOfRange(pubBytes, 1, pubBytes.length));\n    }"}, {"signature": "public static byte[] pubBytesWithoutFormat(ECPoint pubPoint)", "full": "public static byte[] pubBytesWithoutFormat(ECPoint pubPoint) {\n        final byte[] pubBytes = pubPoint.getEncoded(false);\n        return Arrays.copyOfRange(pubBytes, 1, pubBytes.length);\n    }"}, {"signature": "public static ECKey fromNodeId(byte[] nodeId)", "full": "public static ECKey fromNodeId(byte[] nodeId) {\n        check(nodeId.length == 64, \"Expected a 64 byte node id\");\n        byte[] pubBytes = new byte[65];\n        System.arraycopy(nodeId, 0, pubBytes, 1, nodeId.length);\n        pubBytes[0] = 0x04; return ECKey.fromPublicOnly(pubBytes);\n    }"}, {"signature": "public static byte[] signatureToKeyBytes(byte[] messageHash, String\n            signatureBase64) throws SignatureException", "full": "public static byte[] signatureToKeyBytes(byte[] messageHash, String\n            signatureBase64) throws SignatureException {\n        byte[] signatureEncoded;\n        try {\n            signatureEncoded = Base64.decode(signatureBase64);\n        } catch (RuntimeException e) {\n            throw new SignatureException(\"Could not decode base64\", e);\n        }\n        if (signatureEncoded.length < 65) {\n            throw new SignatureException(\"Signature truncated, expected 65 \" +\n                    \"bytes and got \" + signatureEncoded.length);\n        }\n\n        return signatureToKeyBytes(\n                messageHash,\n                ECDSASignature.fromComponents(\n                        Arrays.copyOfRange(signatureEncoded, 1, 33),\n                        Arrays.copyOfRange(signatureEncoded, 33, 65),\n                        (byte) (signatureEncoded[0] & 0xFF)));\n    }"}, {"signature": "public static byte[] signatureToAddress(byte[] messageHash, String\n            signatureBase64) throws SignatureException", "full": "public static byte[] signatureToAddress(byte[] messageHash, String\n            signatureBase64) throws SignatureException {\n        return computeAddress(signatureToKeyBytes(messageHash,\n                signatureBase64));\n    }"}, {"signature": "public static ECKey signatureToKey(byte[] messageHash, String\n            signatureBase64) throws SignatureException", "full": "public static ECKey signatureToKey(byte[] messageHash, String\n            signatureBase64) throws SignatureException {\n        final byte[] keyBytes = signatureToKeyBytes(messageHash,\n                signatureBase64);\n        return ECKey.fromPublicOnly(keyBytes);\n    }"}, {"signature": "public static boolean verify(byte[] data, ECDSASignature signature,\n                                 byte[] pub)", "full": "public static boolean verify(byte[] data, ECDSASignature signature,\n                                 byte[] pub) {\n        ECDSASigner signer = new ECDSASigner();\n        ECPublicKeyParameters params = new ECPublicKeyParameters(CURVE\n                .getCurve().decodePoint(pub), CURVE);\n        signer.init(false, params);\n        try {\n            return signer.verifySignature(data, signature.r, signature.s);\n        } catch (NullPointerException npe) {\n            logger.error(\"Caught NPE inside bouncy castle\", npe);\n            return false;\n        }\n    }"}, {"signature": "public static boolean isPubKeyCanonical(byte[] pubkey)", "full": "public static boolean isPubKeyCanonical(byte[] pubkey) {\n        if (pubkey[0] == 0x04) {\n            return pubkey.length == 65;\n        } else if (pubkey[0] == 0x02 || pubkey[0] == 0x03) {\n            return pubkey.length == 33;\n        } else {\n            return false;\n        }\n    }"}, {"signature": "public static byte[] recoverPubBytesFromSignature(int recId,\n                                                      ECDSASignature sig,\n                                                      byte[] messageHash)", "full": "@Nullable\n    public static byte[] recoverPubBytesFromSignature(int recId,\n                                                      ECDSASignature sig,\n                                                      byte[] messageHash) {\n        check(recId >= 0, \"recId must be positive\");\n        check(sig.r.signum() >= 0, \"r must be positive\");\n        check(sig.s.signum() >= 0, \"s must be positive\");\n        check(messageHash != null, \"messageHash must not be null\");\n        BigInteger n = CURVE.getN();  BigInteger i = BigInteger.valueOf((long) recId / 2);\n        BigInteger x = sig.r.add(i.multiply(n));\n        ECCurve.Fp curve = (ECCurve.Fp) CURVE.getCurve();\n        BigInteger prime = curve.getQ();  if (x.compareTo(prime) >= 0) {\n            return null;\n        }\n        ECPoint R = decompressKey(x, (recId & 1) == 1);\n        if (!R.multiply(n).isInfinity()) {\n            return null;\n        }\n        BigInteger e = new BigInteger(1, messageHash);\n        BigInteger eInv = BigInteger.ZERO.subtract(e).mod(n);\n        BigInteger rInv = sig.r.modInverse(n);\n        BigInteger srInv = rInv.multiply(sig.s).mod(n);\n        BigInteger eInvrInv = rInv.multiply(eInv).mod(n);\n        ECPoint.Fp q = (ECPoint.Fp) ECAlgorithms.sumOfTwoMultiplies(CURVE\n                .getG(), eInvrInv, R, srInv);\n        return q.getEncoded(false);\n    }"}, {"signature": "public static byte[] recoverAddressFromSignature(int recId,\n                                                     ECDSASignature sig,\n                                                     byte[] messageHash)", "full": "@Nullable\n    public static byte[] recoverAddressFromSignature(int recId,\n                                                     ECDSASignature sig,\n                                                     byte[] messageHash) {\n        final byte[] pubBytes = recoverPubBytesFromSignature(recId, sig,\n                messageHash);\n        if (pubBytes == null) {\n            return null;\n        } else {\n            return computeAddress(pubBytes);\n        }\n    }"}, {"signature": "public static ECKey recoverFromSignature(int recId, ECDSASignature sig,\n                                             byte[] messageHash)", "full": "@Nullable\n    public static ECKey recoverFromSignature(int recId, ECDSASignature sig,\n                                             byte[] messageHash) {\n        final byte[] pubBytes = recoverPubBytesFromSignature(recId, sig,\n                messageHash);\n        if (pubBytes == null) {\n            return null;\n        } else {\n            return ECKey.fromPublicOnly(pubBytes);\n        }\n    }"}, {"signature": "private static ECPoint decompressKey(BigInteger xBN, boolean yBit)", "full": "private static ECPoint decompressKey(BigInteger xBN, boolean yBit) {\n        X9IntegerConverter x9 = new X9IntegerConverter();\n        byte[] compEnc = x9.integerToBytes(xBN, 1 + x9.getByteLength(CURVE\n                .getCurve()));\n        compEnc[0] = (byte) (yBit ? 0x03 : 0x02);\n        return CURVE.getCurve().decodePoint(compEnc);\n    }"}, {"signature": "private static void check(boolean test, String message)", "full": "private static void check(boolean test, String message) {\n        if (!test) {\n            throw new IllegalArgumentException(message);\n        }\n    }"}, {"signature": "public ECKey decompress()", "full": "public ECKey decompress() {\n        if (!pub.isCompressed()) {\n            return this;\n        } else {\n            return new ECKey(this.provider, this.privKey, decompressPoint(pub));\n        }\n    }"}, {"signature": "public ECKey compress()", "full": "public ECKey compress() {\n        if (pub.isCompressed()) {\n            return this;\n        } else {\n            return new ECKey(this.provider, this.privKey, compressPoint(pub));\n        }\n    }"}, {"signature": "public boolean isPubKeyOnly()", "full": "public boolean isPubKeyOnly() {\n        return privKey == null;\n    }"}, {"signature": "public boolean hasPrivKey()", "full": "public boolean hasPrivKey() {\n        return privKey != null;\n    }"}, {"signature": "public byte[] getAddress()", "full": "public byte[] getAddress() {\n        if (pubKeyHash == null) {\n            pubKeyHash = computeAddress(this.pub);\n        }\n        return pubKeyHash;\n    }"}, {"signature": "public byte[] getNodeId()", "full": "public byte[] getNodeId() {\n        if (nodeId == null) {\n            nodeId = pubBytesWithoutFormat(this.pub);\n        }\n        return nodeId;\n    }"}, {"signature": "public byte[] getPubKey()", "full": "public byte[] getPubKey() {\n        return pub.getEncoded(false);\n    }"}, {"signature": "public ECPoint getPubKeyPoint()", "full": "public ECPoint getPubKeyPoint() {\n        return pub;\n    }"}, {"signature": "public BigInteger getPrivKey()", "full": "public BigInteger getPrivKey() {\n        if (privKey == null) {\n            throw new MissingPrivateKeyException();\n        } else if (privKey instanceof BCECPrivateKey) {\n            return ((BCECPrivateKey) privKey).getD();\n        } else {\n            throw new MissingPrivateKeyException();\n        }\n    }"}, {"signature": "public boolean isCompressed()", "full": "public boolean isCompressed() {\n        return pub.isCompressed();\n    }"}, {"signature": "public String toString()", "full": "public String toString() {\n        StringBuilder b = new StringBuilder();\n        b.append(\"pub:\").append(Hex.toHexString(pub.getEncoded(false)));\n        return b.toString();\n    }"}, {"signature": "public String toStringWithPrivate()", "full": "public String toStringWithPrivate() {\n        StringBuilder b = new StringBuilder();\n        b.append(toString());\n        if (privKey != null && privKey instanceof BCECPrivateKey) {\n            b.append(\" priv:\").append(Hex.toHexString(((BCECPrivateKey)\n                    privKey).getD().toByteArray()));\n        }\n        return b.toString();\n    }"}, {"signature": "public ECDSASignature doSign(byte[] input)", "full": "public ECDSASignature doSign(byte[] input) {\n        if (input.length != 32) {\n            throw new IllegalArgumentException(\"Expected 32 byte input to \" +\n                    \"ECDSA signature, not \" + input.length);\n        }\n        if (privKey == null) {\n            throw new MissingPrivateKeyException();\n        }\n        if (privKey instanceof BCECPrivateKey) {\n            ECDSASigner signer = new ECDSASigner(new HMacDSAKCalculator(new\n                    SHA256Digest()));\n            ECPrivateKeyParameters privKeyParams = new ECPrivateKeyParameters\n                    (((BCECPrivateKey) privKey).getD(), CURVE);\n            signer.init(true, privKeyParams);\n            BigInteger[] components = signer.generateSignature(input);\n            return new ECDSASignature(components[0], components[1])\n                    .toCanonicalised();\n        } else {\n            try {\n                final Signature ecSig = ECSignatureFactory.getRawInstance\n                        (provider);\n                ecSig.initSign(privKey);\n                ecSig.update(input);\n                final byte[] derSignature = ecSig.sign();\n                return ECDSASignature.decodeFromDER(derSignature)\n                        .toCanonicalised();\n            } catch (SignatureException | InvalidKeyException ex) {\n                throw new RuntimeException(\"ECKey signing error\", ex);\n            }\n        }\n    }"}, {"signature": "public ECDSASignature sign(byte[] messageHash)", "full": "public ECDSASignature sign(byte[] messageHash) {\n        ECDSASignature sig = doSign(messageHash);\n        int recId = -1;\n        byte[] thisKey = this.pub.getEncoded(false);\n        for (int i = 0; i < 4; i++) {\n            byte[] k = ECKey.recoverPubBytesFromSignature(i, sig, messageHash);\n            if (k != null && Arrays.equals(k, thisKey)) {\n                recId = i;\n                break;\n            }\n        }\n        if (recId == -1) {\n            throw new RuntimeException(\"Could not construct a recoverable key\" +\n                    \". This should never happen.\");\n        }\n        sig.v = (byte) (recId + 27);\n        return sig;\n    }"}, {"signature": "public BigInteger keyAgreement(ECPoint otherParty)", "full": "public BigInteger keyAgreement(ECPoint otherParty) {\n        if (privKey == null) {\n            throw new MissingPrivateKeyException();\n        } else if (privKey instanceof BCECPrivateKey) {\n            final ECDHBasicAgreement agreement = new ECDHBasicAgreement();\n            agreement.init(new ECPrivateKeyParameters(((BCECPrivateKey)\n                    privKey).getD(), CURVE));\n            return agreement.calculateAgreement(new ECPublicKeyParameters\n                    (otherParty, CURVE));\n        } else {\n            try {\n                final KeyAgreement agreement = ECKeyAgreement.getInstance\n                        (this.provider);\n                agreement.init(this.privKey);\n                agreement.doPhase(\n                        ECKeyFactory.getInstance(this.provider)\n                                .generatePublic(new ECPublicKeySpec\n                                        (otherParty, CURVE_SPEC)),\n                        true);\n                return new BigInteger(1, agreement.generateSecret());\n            } catch (IllegalStateException | InvalidKeyException |\n                    InvalidKeySpecException ex) {\n                throw new RuntimeException(\"ECDH key agreement failure\", ex);\n            }\n        }\n    }"}, {"signature": "public byte[] decryptAES(byte[] cipher)", "full": "public byte[] decryptAES(byte[] cipher) {\n\n        if (privKey == null) {\n            throw new MissingPrivateKeyException();\n        }\n        if (!(privKey instanceof BCECPrivateKey)) {\n            throw new UnsupportedOperationException(\"Cannot use the private \" +\n                    \"key as an AES key\");\n        }\n\n        AESEngine engine = new AESEngine();\n        SICBlockCipher ctrEngine = new SICBlockCipher(engine);\n\n        KeyParameter key = new KeyParameter(BigIntegers.asUnsignedByteArray((\n                (BCECPrivateKey) privKey).getD()));\n        ParametersWithIV params = new ParametersWithIV(key, new byte[16]);\n\n        ctrEngine.init(false, params);\n\n        int i = 0;\n        byte[] out = new byte[cipher.length];\n        while (i < cipher.length) {\n            ctrEngine.processBlock(cipher, i, out, i);\n            i += engine.getBlockSize();\n            if (cipher.length - i < engine.getBlockSize()) {\n                break;\n            }\n        }\n\n        if (cipher.length - i > 0) {\n            byte[] tmpBlock = new byte[16];\n            System.arraycopy(cipher, i, tmpBlock, 0, cipher.length - i);\n            ctrEngine.processBlock(tmpBlock, 0, tmpBlock, 0);\n            System.arraycopy(tmpBlock, 0, out, i, cipher.length - i);\n        }\n\n        return out;\n    }"}, {"signature": "public boolean isPubKeyCanonical()", "full": "public boolean isPubKeyCanonical() {\n        return isPubKeyCanonical(pub.getEncoded(false));\n    }"}, {"signature": "public byte[] getPrivKeyBytes()", "full": "@Nullable\n    public byte[] getPrivKeyBytes() {\n        if (privKey == null) {\n            return null;\n        } else if (privKey instanceof BCECPrivateKey) {\n            return ByteUtil.bigIntegerToBytes(((BCECPrivateKey) privKey).getD(), 32);\n        } else {\n            return null;\n        }\n    }"}, {"signature": "public boolean equals(Object o)", "full": "@Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        ECKey ecKey = (ECKey) o;\n\n        if (privKey != null && !privKey.equals(ecKey.privKey)) {\n            return false;\n        }\n        return pub == null || pub.equals(ecKey.pub);\n    }"}, {"signature": "public int hashCode()", "full": "@Override\n    public int hashCode() {\n        return Arrays.hashCode(getPubKey());\n    }"}], "class_attributes": [{"type": "ECDomainParameters", "name": "CURVE"}, {"type": "ECParameterSpec", "name": "CURVE_SPEC"}, {"type": "BigInteger", "name": "HALF_CURVE_ORDER"}, {"type": "BigInteger", "name": "SECP256K1N"}, {"type": "SecureRandom", "name": "secureRandom"}, {"type": "long", "name": "serialVersionUID"}, {"type": "ECPoint", "name": "pub"}, {"type": "PrivateKey", "name": "privKey"}, {"type": "Provider", "name": "provider"}, {"type": "byte", "name": "pubKeyHash"}, {"type": "byte", "name": "nodeId"}]}
{"id": 2344580, "class_signatures": "public class ScoreboardHandler implements GenericMechanic", "class_methods": [{"signature": "public EnumPriority startPriority()", "full": "@Override\n    public EnumPriority startPriority() {\n        return EnumPriority.POPE;\n    }"}, {"signature": "public void startInitialization()", "full": "@Override\n    public void startInitialization() {\n        mainScoreboard = Bukkit.getScoreboardManager().getNewScoreboard();\n\n        Objective objective = mainScoreboard.registerNewObjective(\"mainScoreboard\", \"mainScoreboard\");\n        objective.setDisplaySlot(DisplaySlot.BELOW_NAME);\n        objective.setDisplayName(ChatColor.RED.toString() + \"\u00e2\u009d\u00a4\");\n    }"}, {"signature": "public void stopInvocation()", "full": "@Override\n    public void stopInvocation() {\n\n    }"}, {"signature": "public Scoreboard getPlayerScoreboardObject(Player player)", "full": "public Scoreboard getPlayerScoreboardObject(Player player) {\n        if (!(PLAYER_SCOREBOARDS.containsKey(player.getUniqueId()))) {\n            Scoreboard scoreboard = Bukkit.getScoreboardManager().getNewScoreboard();\n\n            registerHealth(scoreboard);\n\n            PLAYER_SCOREBOARDS.put(player.getUniqueId(), scoreboard);\n            player.setScoreboard(scoreboard);\n        }\n        return PLAYER_SCOREBOARDS.get(player.getUniqueId());\n    }"}, {"signature": "public void updatePlayerHP(Player player, int hp)", "full": "public void updatePlayerHP(Player player, int hp) {\n        for (Player player1 : Bukkit.getOnlinePlayers())\n            if (!Affair.isInParty(player1))\n                getPlayerScoreboardObject(player1).getObjective(DisplaySlot.BELOW_NAME).getScore(player.getName()).setScore(hp);\n\n        for (Party party : Affair.getParties()) {\n            Scoreboard scoreboard = party.getScoreboard();\n            scoreboard.getObjective(DisplaySlot.BELOW_NAME).getScore(player.getName()).setScore(hp);\n        }\nmainScoreboard.getObjective(DisplaySlot.BELOW_NAME).getScore(player.getName()).setScore(hp);\n    }"}, {"signature": "public void updatePlayerName(Player player)", "full": "public void updatePlayerName(Player player) {\n        PlayerWrapper pw = PlayerWrapper.getWrapper(player);\n        if (pw == null)\n            return;\n\n        ChatColor color = pw.getRank().isAtLeast(PlayerRank.TRIALGM) ? ChatColor.AQUA : pw.getAlignment().getNameColor();\n        player.setPlayerListName(color + player.getName());\n\n        String prefix = color + \"\";\n        String suffix = ChatColor.AQUA + \" [Lvl. \" + pw.getLevel() + \"]\";\n\n        GuildWrapper guild = pw.getGuild();\n        if (guild != null && guild.isAnAcceptedPlayer(player)) {\n            prefix = \"[\" + guild.getTag() + ChatColor.RESET + \"] \" + prefix;\n        }\n\n        for (Player update : Bukkit.getOnlinePlayers())\n            if (!Affair.isInParty(update))\n                updateTeam(getPlayerTeam(getPlayerScoreboardObject(update), player), player, prefix, suffix);\n\n        for (Party party : Affair.getParties())\n            updateTeam(getPlayerTeam(party.getScoreboard(), player), player, prefix, suffix);\n\n        updateTeam(getPlayerTeam(mainScoreboard, player), player, prefix, suffix);\n    }"}, {"signature": "private void updateTeam(Team team, Player player, String prefix, String suffix)", "full": "private void updateTeam(Team team, Player player, String prefix, String suffix) {\n        team.setPrefix(prefix);\n        team.setSuffix(suffix);\n        team.setOption(Team.Option.COLLISION_RULE, Team.OptionStatus.NEVER);\n        if (!team.hasEntry(player.getName()))\n            team.addEntry(player.getName());\n    }"}, {"signature": "public void registerHealth(Scoreboard scoreboard)", "full": "public void registerHealth(Scoreboard scoreboard) {\n        Objective objective = scoreboard.getObjective(\"playerScoreboard\") != null ? scoreboard.getObjective(\"playerScoreboard\") : scoreboard.registerNewObjective(\"playerScoreboard\", \"playerScoreboard\");\n        objective.setDisplaySlot(DisplaySlot.BELOW_NAME);\n        objective.setDisplayName(ChatColor.RED.toString() + \"\u00e2\u009d\u00a4\");\n    }"}, {"signature": "public void setCurrentPlayerLevels(Scoreboard scoreboard)", "full": "public void setCurrentPlayerLevels(Scoreboard scoreboard) {\n        for (Player player1 : Bukkit.getOnlinePlayers()) {\n            PlayerWrapper wrapper = PlayerWrapper.getPlayerWrapper(player1);\n            if (wrapper == null) {\n                continue;\n            }\n            int level = wrapper.getLevel();\n\n            Team team = getPlayerTeam(scoreboard, player1);\n            ChatColor chatColor = wrapper.getAlignment().getNameColor();\n            if (Rank.isTrialGM(player1))\n                chatColor = ChatColor.AQUA;\n\n            String guild = \"\";\n            GuildWrapper guildWrapper = GuildDatabase.getAPI().getPlayersGuildWrapper(player1.getUniqueId());\n            if (guildWrapper != null && guildWrapper.isAnAcceptedPlayer(player1)) {\n                String clanTag = guildWrapper.getTag();\nguild = ChatColor.translateAlternateColorCodes('&', ChatColor.RESET + \"[\" + clanTag + ChatColor.RESET + \"] \");\n            }\n            team.setPrefix(guild + chatColor);\n            team.setSuffix(ChatColor.AQUA + \" [Lvl. \" + level + \"]\");\n            team.setOption(Team.Option.COLLISION_RULE, Team.OptionStatus.NEVER);\n\n            PlayerRank rank = Rank.getRank(player1);\n            player1.setPlayerListName(rank.getChatColor() + player1.getName());\n            if (!team.hasEntry(player1.getName())) {\n                team.addEntry(player1.getName());\n            }\n        }\n    }"}, {"signature": "public Team getPlayerTeam(Scoreboard scoreboard, Player player)", "full": "public Team getPlayerTeam(Scoreboard scoreboard, Player player) {\n        if (scoreboard.getTeam(player.getName()) == null) {\n            Team team = scoreboard.registerNewTeam(player.getName());\n            team.setOption(Team.Option.COLLISION_RULE, Team.OptionStatus.NEVER);\n            return team;\n        }\n        return scoreboard.getTeam(player.getName());\n    }"}, {"signature": "private Team getMainScoreboardTeam(Scoreboard scoreboard, String name)", "full": "private Team getMainScoreboardTeam(Scoreboard scoreboard, String name) {\n        if (mainScoreboard.getTeam(name) == null) {\n            Team mainTeam = mainScoreboard.registerNewTeam(name);\n            mainTeam.setOption(Team.Option.COLLISION_RULE, Team.OptionStatus.NEVER);\n        }\n        if (scoreboard.getTeam(name) == null) {\n            Team scTeam = scoreboard.registerNewTeam(name);\n            scTeam.setOption(Team.Option.COLLISION_RULE, Team.OptionStatus.NEVER);\n            return scTeam;\n        }\n        return scoreboard.getTeam(name);\n    }"}, {"signature": "public void matchMainScoreboard(Player player)", "full": "public void matchMainScoreboard(Player player) {\n        Scoreboard scoreboard = getPlayerScoreboardObject(player);\n        for (Team team : mainScoreboard.getTeams()) {\n            Team currentTeam = getMainScoreboardTeam(scoreboard, team.getName());\n            currentTeam.setAllowFriendlyFire(team.allowFriendlyFire());\n            currentTeam.setCanSeeFriendlyInvisibles(team.canSeeFriendlyInvisibles());\n            currentTeam.setDisplayName(team.getDisplayName());\n            currentTeam.setPrefix(team.getPrefix());\n            currentTeam.setSuffix(team.getSuffix());\n            team.getEntries().forEach(currentTeam::addEntry);\n        }\n    }"}, {"signature": "public void removePlayerScoreboard(Player player) \n}", "full": "public void removePlayerScoreboard(Player player) {\n        if (PLAYER_SCOREBOARDS.containsKey(player.getUniqueId())) {\n            PLAYER_SCOREBOARDS.remove(player.getUniqueId());\n        }\n    }\n}"}], "class_attributes": [{"type": "ScoreboardHandler", "name": "instance"}, {"type": "HashMap", "name": "PLAYER_SCOREBOARDS"}, {"type": "Scoreboard", "name": "mainScoreboard"}]}
{"id": 2364685, "class_signatures": "public class AnalysisResult extends CmiTree", "class_methods": [{"signature": "AnalysisResult()", "full": "AnalysisResult() {\n\t\tsuper();\n\n\t\t_ccpds = new ArrayList<Map<Variable, Function>>();\n\t\t_order = new ArrayList<Variable>();\n\t\t_pmi = new HashMap<Variable, Double>();\n\t\t_selectedManifests = new ArrayList<Variable>();\n\t}"}, {"signature": "static AnalysisResult load(String filename, BayesNet model)\n\t\t\tthrows IOException", "full": "static AnalysisResult load(String filename, BayesNet model)\n\t\t\tthrows IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(\n\t\t\t\tnew FileInputStream(filename), \"UTF8\"));\n\n\t\tAnalysisResult result = new AnalysisResult();\n\n\t\tString[] tokens;\n\n\t\tString line = in.readLine();\n\t\twhile (line.startsWith(\"% CCPDs\")) {\n\t\t\tMap<Variable, Function> ccpds = new HashMap<Variable, Function>();\n\n\t\t\twhile (!(line = in.readLine()).startsWith(\"%\")) {\n\t\t\t\ttokens = line.split(\" \");\n\t\t\t\tVariable manifest = model.getNodeByName(tokens[0])\n\t\t\t\t\t\t.getVariable();\n\t\t\t\tFunction ccpd = Function.createUniformDistribution(manifest);\n\t\t\t\tdouble[] cells = ccpd.getCells();\n\t\t\t\tfor (int i = 1; i < tokens.length; i++) {\n\t\t\t\t\tcells[i - 1] = Double.parseDouble(tokens[i]);\n\t\t\t\t}\n\t\t\t\tccpds.put(manifest, ccpd);\n\t\t\t}\n\n\t\t\tresult._ccpds.add(ccpds);\n\t\t}\n\n\t\tresult.parsePreOrderString(in.readLine(), model);\n\n\t\tin.readLine();\n\t\tresult._largestMaxCmiPercent = Double.parseDouble(in.readLine());\n\n\t\tin.readLine();\n\t\ttokens = in.readLine().split(\" \");\n\t\tfor (String token : tokens) {\n\t\t\tresult._order.add(model.getNodeByName(token).getVariable());\n\t\t}\n\n\t\tin.readLine();\n\t\twhile (!(line = in.readLine()).startsWith(\"%\")) {\n\t\t\ttokens = line.split(\" \");\n\t\t\tresult._pmi.put(model.getNodeByName(tokens[0]).getVariable(),\n\t\t\t\t\tDouble.parseDouble(tokens[1]));\n\t\t}\n\n\t\ttokens = in.readLine().split(\" \");\n\t\tArrayList<Variable> latents = new ArrayList<Variable>();\n\t\tfor (String token : tokens) {\n\t\t\tlatents.add(model.getNodeByName(token).getVariable());\n\t\t}\n\t\tresult._prior = Function.createFunction(latents);\n\n\t\ttokens = in.readLine().split(\" \");\n\t\tArrayList<Double> cells = new ArrayList<Double>();\n\t\tfor (String token : tokens) {\n\t\t\tcells.add(Double.parseDouble(token));\n\t\t}\n\t\tresult._prior.setCells(latents, cells);\n\n\t\tin.readLine();\n\t\ttokens = in.readLine().split(\" \");\n\t\tfor (String token : tokens) {\n\t\t\tresult._selectedManifests.add(model.getNodeByName(token)\n\t\t\t\t\t.getVariable());\n\t\t}\n\n\t\tin.readLine();\n\t\tresult._selectedMaxCmiPercent = Double.parseDouble(in.readLine());\n\n\t\tin.readLine();\n\t\tresult._tmi = Double.parseDouble(in.readLine());\n\n\t\treturn result;\n\t}"}, {"signature": "public int getLatentCardinality()", "full": "public int getLatentCardinality() {\n\t\treturn _prior.getDomainSize();\n\t}"}, {"signature": "public String getLatentName()", "full": "public String getLatentName() {\n\t\tStringBuffer str = new StringBuffer();\n\n\t\tfor (Variable latent : _prior.getVariables()) {\n\t\t\tstr.append(latent.getName());\n\t\t}\n\n\t\treturn str.toString();\n\t}"}, {"signature": "Set<Variable> getLatents()", "full": "Set<Variable> getLatents() {\n\t\tSet<Variable> latents = new HashSet<Variable>();\n\n\t\tfor (Variable latent : _prior.getVariables()) {\n\t\t\tlatents.add(latent);\n\t\t}\n\n\t\treturn latents;\n\t}"}, {"signature": "public List<Variable> getNaturalOrder()", "full": "public List<Variable> getNaturalOrder() {\n\t\treturn _order;\n\t}"}, {"signature": "public Function getPrior()", "full": "public Function getPrior() {\n\t\treturn _prior;\n\t}"}, {"signature": "public List<Function> getSelectedCcpds(int index)", "full": "public List<Function> getSelectedCcpds(int index) {\n\t\tList<Function> selectedCcpds = new ArrayList<Function>();\n\t\tMap<Variable, Function> ccpds = _ccpds.get(index);\n\n\t\tfor (Variable manifest : _selectedManifests) {\n\t\t\tselectedCcpds.add(ccpds.get(manifest));\n\t\t}\n\n\t\treturn selectedCcpds;\n\t}"}, {"signature": "public List<Double> getSelectedCmiSeq()", "full": "public List<Double> getSelectedCmiSeq() {\n\t\treturn getMaxSubPathValues(_selectedManifests);\n\t}"}, {"signature": "public List<Variable> getSelectedManifests()", "full": "public List<Variable> getSelectedManifests() {\n\t\treturn _selectedManifests;\n\t}"}, {"signature": "public double getSelectedMaxCmiPercent()", "full": "public double getSelectedMaxCmiPercent() {\n\t\treturn _selectedMaxCmiPercent;\n\t}"}, {"signature": "public List<Double> getSelectedPmiSeq()", "full": "public List<Double> getSelectedPmiSeq() {\n\t\tList<Double> pmiSeq = new ArrayList<Double>();\n\n\t\tfor (Variable manifest : _selectedManifests) {\n\t\t\tpmiSeq.add(_pmi.get(manifest));\n\t\t}\n\n\t\treturn pmiSeq;\n\t}"}, {"signature": "public String getStateName(int index)", "full": "public String getStateName(int index) {\n\t\tStringBuffer str = new StringBuffer();\n\n\t\tList<Variable> latents = _prior.getVariables();\n\t\tint nLatents = _prior.getDimension();\n\t\tint[] states = new int[nLatents];\n\t\t_prior.computeStates(index, states);\n\n\t\tfor (int i = 0; i < nLatents; i++) {\n\t\t\tVariable latent = latents.get(i);\n\n\t\t\tstr.append(latent.getName());\n\t\t\tstr.append(\"=\");\n\t\t\tstr.append(latent.getStates().get(states[i]));\n\n\t\t\tif (i < nLatents - 1) {\n\t\t\t\tstr.append(\", \");\n\t\t\t}\n\t\t}\n\n\t\treturn str.toString();\n\t}"}, {"signature": "public double getTmi()", "full": "public double getTmi() {\n\t\treturn _tmi;\n\t}"}, {"signature": "void save(String filename) throws FileNotFoundException,\n\t\t\tUnsupportedEncodingException", "full": "void save(String filename) throws FileNotFoundException,\n\t\t\tUnsupportedEncodingException {\n\t\tPrintWriter out = new PrintWriter(new BufferedWriter(\n\t\t\t\tnew OutputStreamWriter(new FileOutputStream(filename), \"UTF8\")));\n\n\t\tfor (int i = 0; i < _ccpds.size(); i++) {\n\t\t\tout.println(\"% CCPDs for State \" + getStateName(i));\n\n\t\t\tMap<Variable, Function> ccpds = _ccpds.get(i);\n\t\t\tfor (Variable manifest : ccpds.keySet()) {\n\t\t\t\tout.print(manifest.getName());\n\t\t\t\tfor (double prob : ccpds.get(manifest).getCells()) {\n\t\t\t\t\tout.print(\" \" + prob);\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\n\t\tout.println(\"% CMI Tree in Pre-Order\");\n\t\tout.println(toPreOrderString());\n\n\t\tout.println(\"% Largest Maximum CMI Percent\");\n\t\tout.println(_largestMaxCmiPercent);\n\n\t\tout.println(\"% Natural Order of Manifest Variables\");\n\t\tfor (Variable manifest : _order) {\n\t\t\tout.print(manifest.getName() + \" \");\n\t\t}\n\t\tout.println();\n\n\t\tout.println(\"% PMI\");\n\t\tfor (Variable manifest : _pmi.keySet()) {\n\t\t\tout.println(manifest.getName() + \" \" + _pmi.get(manifest));\n\t\t}\n\n\t\tout.println(\"% Prior Distribution\");\n\n\t\tfor (Variable latent : _prior.getVariables()) {\n\t\t\tout.print(latent.getName() + \" \");\n\t\t}\n\t\tout.println();\n\n\t\tfor (double prob : _prior.getCells()) {\n\t\t\tout.print(prob + \" \");\n\t\t}\n\t\tout.println();\n\n\t\tout.println(\"% Selected Manifest Variables\");\n\t\tfor (Variable manifest : _selectedManifests) {\n\t\t\tout.print(manifest.getName() + \" \");\n\t\t}\n\t\tout.println();\n\n\t\tout.println(\"% Selected Maximum CMI Percent\");\n\t\tout.println(_selectedMaxCmiPercent);\n\n\t\tout.println(\"% TMI\");\n\t\tout.println(_tmi);\n\n\t\tout.close();\n\t}"}, {"signature": "public String toString() \n\n}", "full": "public String toString() {\n\t\tStringBuffer str = new StringBuffer();\n\n\t\tNumberFormat nf = NumberFormat.getInstance();\n\t\tnf.setMaximumFractionDigits(0);\n\n\t\tfor (Variable latent : _prior.getVariables()) {\n\t\t\tstr.append(latent.getName());\n\t\t\tstr.append(\" \");\n\t\t}\n\n\t\tstr.append(\"[\");\n\n\t\tList<Variable> latents = _prior.getVariables();\n\t\tint nLatents = _prior.getDimension();\n\t\tint[] states = new int[nLatents];\n\t\tint card = getLatentCardinality();\n\n\t\tfor (int i = 0; i < card; i++) {\n\t\t\t_prior.computeStates(i, states);\n\n\t\t\tfor (int j = 0; j < nLatents; j++) {\n\t\t\t\tstr.append(latents.get(j).getStates().get(states[j]));\n\t\t\t}\n\n\t\t\tif (i < card - 1) {\n\t\t\t\tstr.append(\";\");\n\t\t\t}\n\t\t}\n\n\t\tstr.append(\"|\");\n\n\t\tdouble[] prior = _prior.getCells();\n\n\t\tfor (int i = 0; i < card; i++) {\n\t\t\tstr.append(nf.format(prior[i] * 100));\n\n\t\t\tif (i < card - 1) {\n\t\t\t\tstr.append(\";\");\n\t\t\t}\n\t\t}\n\n\t\tstr.append(\"]: \");\n\n\t\tint nManifests = _selectedManifests.size();\n\t\tList<Double> pmiSeq = getSelectedPmiSeq();\n\t\tList<Double> cmiSeq = getSelectedCmiSeq();\n\n\t\tfor (int i = 0; i < nManifests; i++) {\n\t\t\tVariable manifest = _selectedManifests.get(i);\n\n\t\t\tstr.append(manifest.getName());\n\t\t\tstr.append(\" [\");\n\n\t\t\tfor (int j = 0; j < card; j++) {\n\t\t\t\tstr\n\t\t\t\t\t\t.append(nf.format(_ccpds.get(j).get(manifest)\n\t\t\t\t\t\t\t\t.getCells()[1] * 100));\n\n\t\t\t\tif (j < card - 1) {\n\t\t\t\t\tstr.append(\";\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstr.append(\"|\");\n\n\t\t\tstr.append(nf.format(pmiSeq.get(i) * 100 / _tmi));\n\t\t\tstr.append(\";\");\n\t\t\tstr.append(nf.format(cmiSeq.get(i) * 100 / _tmi));\n\n\t\t\tstr.append(\"]\");\n\t\t\tif (i < nManifests - 1) {\n\t\t\t\tstr.append(\", \");\n\t\t\t}\n\t\t}\n\n\t\treturn str.toString();\n\t}\n\n}"}], "class_attributes": [{"type": "List", "name": "_ccpds"}, {"type": "double", "name": "_largestMaxCmiPercent"}, {"type": "List", "name": "_order"}, {"type": "Map", "name": "_pmi"}, {"type": "Function", "name": "_prior"}, {"type": "List", "name": "_selectedManifests"}, {"type": "double", "name": "_selectedMaxCmiPercent"}, {"type": "double", "name": "_tmi"}]}
{"id": 2390056, "class_signatures": "public class Legend extends Text", "class_methods": [{"signature": "protected Legend()", "full": "protected Legend() {\n\n    }"}, {"signature": "public Legend(String jsChart)", "full": "public Legend(String jsChart) {\n        jsBase = \"legend\" + ++variableIndex;\n        APIlib.getInstance().addJSLine(jsBase + \" = \" + jsChart + \";\");\n    }"}, {"signature": "public static Legend instantiate()", "full": "public static Legend instantiate() {\n        return new Legend(\"new anychart.core.ui.legend()\");\n    }"}, {"signature": "public String getJsBase()", "full": "public String getJsBase() {\n        return jsBase;\n    }"}, {"signature": "public void align()", "full": "public void align() {\n        APIlib.getInstance().addJSLine(jsBase + \".align();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend align(com.anychart.enums.Align align)", "full": "public com.anychart.core.ui.Legend align(com.anychart.enums.Align align) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".align(%s);\", (align != null) ? align.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.Background background()", "full": "public com.anychart.core.ui.Background background() {\n        return new com.anychart.core.ui.Background(jsBase + \".background()\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend background(String settings)", "full": "public com.anychart.core.ui.Legend background(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".background(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public void disablePointerEvents()", "full": "public void disablePointerEvents() {\n        APIlib.getInstance().addJSLine(jsBase + \".disablePointerEvents();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend disablePointerEvents(Boolean enabled)", "full": "public com.anychart.core.ui.Legend disablePointerEvents(Boolean enabled) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".disablePointerEvents(%s);\", enabled));\n\n        return this;\n    }"}, {"signature": "public void drag()", "full": "public void drag() {\n        APIlib.getInstance().addJSLine(jsBase + \".drag();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend drag(Boolean enabled)", "full": "public com.anychart.core.ui.Legend drag(Boolean enabled) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".drag(%s);\", enabled));\n\n        return this;\n    }"}, {"signature": "public void enabled()", "full": "public void enabled() {\n        APIlib.getInstance().addJSLine(jsBase + \".enabled();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend enabled(Boolean enabled)", "full": "public com.anychart.core.ui.Legend enabled(Boolean enabled) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".enabled(%s);\", enabled));\n\n        return this;\n    }"}, {"signature": "public void fontColor()", "full": "public void fontColor() {\n        APIlib.getInstance().addJSLine(jsBase + \".fontColor();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend fontColor(String color)", "full": "public com.anychart.core.ui.Legend fontColor(String color) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fontColor(%s);\", wrapQuotes(color)));\n\n        return this;\n    }"}, {"signature": "public void fontDecoration()", "full": "public void fontDecoration() {\n        APIlib.getInstance().addJSLine(jsBase + \".fontDecoration();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend fontDecoration(com.anychart.graphics.vector.text.Decoration value)", "full": "public com.anychart.core.ui.Legend fontDecoration(com.anychart.graphics.vector.text.Decoration value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fontDecoration(%s);\", (value != null) ? value.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void fontFamily()", "full": "public void fontFamily() {\n        APIlib.getInstance().addJSLine(jsBase + \".fontFamily();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend fontFamily(String family)", "full": "public com.anychart.core.ui.Legend fontFamily(String family) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fontFamily(%s);\", wrapQuotes(family)));\n\n        return this;\n    }"}, {"signature": "public void fontOpacity()", "full": "public void fontOpacity() {\n        APIlib.getInstance().addJSLine(jsBase + \".fontOpacity();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend maxWidth(Number width)", "full": "public com.anychart.core.ui.Legend maxWidth(Number width) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".maxWidth(%s);\", width));\n\n        return this;\n    }"}, {"signature": "public void items()", "full": "public void items() {\n        APIlib.getInstance().addJSLine(jsBase + \".items();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend items(com.anychart.core.ui.legend.LegendItemProvider[] itemsList)", "full": "public com.anychart.core.ui.Legend items(com.anychart.core.ui.legend.LegendItemProvider[] itemsList) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".items(%s);\", arrayToString(itemsList)));\n\n        return this;\n    }"}, {"signature": "public void itemsFormat()", "full": "public void itemsFormat() {\n        APIlib.getInstance().addJSLine(jsBase + \".itemsFormat();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend itemsFormat(String format)", "full": "public com.anychart.core.ui.Legend itemsFormat(String format) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".itemsFormat(%s);\", wrapQuotes(format)));\n\n        return this;\n    }"}, {"signature": "public void itemsFormatter()", "full": "public void itemsFormatter() {\n        APIlib.getInstance().addJSLine(jsBase + \".itemsFormatter();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend itemsFormatter(com.anychart.core.ui.legend.LegendItemProvider[] formatterFunction)", "full": "public com.anychart.core.ui.Legend itemsFormatter(com.anychart.core.ui.legend.LegendItemProvider[] formatterFunction) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".itemsFormatter(%s);\", arrayToString(formatterFunction)));\n\n        return this;\n    }"}, {"signature": "public void itemsLayout()", "full": "public void itemsLayout() {\n        APIlib.getInstance().addJSLine(jsBase + \".itemsLayout();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend itemsLayout(com.anychart.enums.LegendLayout layout)", "full": "public com.anychart.core.ui.Legend itemsLayout(com.anychart.enums.LegendLayout layout) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".itemsLayout(%s);\", (layout != null) ? layout.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void itemsSourceMode()", "full": "public void itemsSourceMode() {\n        APIlib.getInstance().addJSLine(jsBase + \".itemsSourceMode();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend itemsSourceMode(com.anychart.enums.LegendItemsSourceMode mode)", "full": "public com.anychart.core.ui.Legend itemsSourceMode(com.anychart.enums.LegendItemsSourceMode mode) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".itemsSourceMode(%s);\", (mode != null) ? mode.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void itemsSpacing()", "full": "public void itemsSpacing() {\n        APIlib.getInstance().addJSLine(jsBase + \".itemsSpacing();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend itemsSpacing(String spacing)", "full": "public com.anychart.core.ui.Legend itemsSpacing(String spacing) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".itemsSpacing(%s);\", wrapQuotes(spacing)));\n\n        return this;\n    }"}, {"signature": "public void letterSpacing()", "full": "public void letterSpacing() {\n        APIlib.getInstance().addJSLine(jsBase + \".letterSpacing();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend letterSpacing(String spacing)", "full": "public com.anychart.core.ui.Legend letterSpacing(String spacing) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".letterSpacing(%s);\", wrapQuotes(spacing)));\n\n        return this;\n    }"}, {"signature": "public void lineHeight()", "full": "public void lineHeight() {\n        APIlib.getInstance().addJSLine(jsBase + \".lineHeight();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend lineHeight(String height)", "full": "public com.anychart.core.ui.Legend lineHeight(String height) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".lineHeight(%s);\", wrapQuotes(height)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.utils.Margin margin()", "full": "public com.anychart.core.utils.Margin margin() {\n        return new com.anychart.core.utils.Margin(jsBase + \".margin()\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend margin(Number[] margin)", "full": "public com.anychart.core.ui.Legend margin(Number[] margin) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".margin(%s);\", Arrays.toString(margin)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.Legend margin(String value1, String value2, String value3, String value4)", "full": "public com.anychart.core.ui.Legend margin(String value1, String value2, String value3, String value4) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".margin(%s, %s, %s, %s);\", wrapQuotes(value1), wrapQuotes(value2), wrapQuotes(value3), wrapQuotes(value4)));\n\n        return this;\n    }"}, {"signature": "public void maxHeight()", "full": "public void maxHeight() {\n        APIlib.getInstance().addJSLine(jsBase + \".maxHeight();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend maxHeight(Number height)", "full": "public com.anychart.core.ui.Legend maxHeight(Number height) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".maxHeight(%s);\", height));\n\n        return this;\n    }"}, {"signature": "public void maxWidth()", "full": "public void maxWidth() {\n        APIlib.getInstance().addJSLine(jsBase + \".maxWidth();\");\n    }"}, {"signature": "public com.anychart.core.utils.Padding padding()", "full": "public com.anychart.core.utils.Padding padding() {\n        return new com.anychart.core.utils.Padding(jsBase + \".padding()\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend padding(Number[] padding)", "full": "public com.anychart.core.ui.Legend padding(Number[] padding) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".padding(%s);\", Arrays.toString(padding)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.Legend padding(String value1, String value2, String value3, String value4)", "full": "public com.anychart.core.ui.Legend padding(String value1, String value2, String value3, String value4) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".padding(%s, %s, %s, %s);\", wrapQuotes(value1), wrapQuotes(value2), wrapQuotes(value3), wrapQuotes(value4)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.Paginator paginator()", "full": "public com.anychart.core.ui.Paginator paginator() {\n        return new com.anychart.core.ui.Paginator(jsBase + \".paginator()\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend paginator(String settings)", "full": "public com.anychart.core.ui.Legend paginator(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".paginator(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public void position()", "full": "public void position() {\n        APIlib.getInstance().addJSLine(jsBase + \".position();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend position(com.anychart.enums.Orientation position)", "full": "public com.anychart.core.ui.Legend position(com.anychart.enums.Orientation position) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".position(%s);\", (position != null) ? position.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void positionMode()", "full": "public void positionMode() {\n        APIlib.getInstance().addJSLine(jsBase + \".positionMode();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend fontOpacity(Number opacity)", "full": "public com.anychart.core.ui.Legend fontOpacity(Number opacity) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fontOpacity(%s);\", opacity));\n\n        return this;\n    }"}, {"signature": "public void fontSize()", "full": "public void fontSize() {\n        APIlib.getInstance().addJSLine(jsBase + \".fontSize();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend fontSize(String size)", "full": "public com.anychart.core.ui.Legend fontSize(String size) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fontSize(%s);\", wrapQuotes(size)));\n\n        return this;\n    }"}, {"signature": "public void fontStyle()", "full": "public void fontStyle() {\n        APIlib.getInstance().addJSLine(jsBase + \".fontStyle();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend fontStyle(com.anychart.graphics.vector.text.FontStyle style)", "full": "public com.anychart.core.ui.Legend fontStyle(com.anychart.graphics.vector.text.FontStyle style) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fontStyle(%s);\", (style != null) ? style.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void fontVariant()", "full": "public void fontVariant() {\n        APIlib.getInstance().addJSLine(jsBase + \".fontVariant();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend fontVariant(com.anychart.graphics.vector.text.FontVariant value)", "full": "public com.anychart.core.ui.Legend fontVariant(com.anychart.graphics.vector.text.FontVariant value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fontVariant(%s);\", (value != null) ? value.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void fontWeight()", "full": "public void fontWeight() {\n        APIlib.getInstance().addJSLine(jsBase + \".fontWeight();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend fontWeight(String weight)", "full": "public com.anychart.core.ui.Legend fontWeight(String weight) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".fontWeight(%s);\", wrapQuotes(weight)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.math.Rect getPixelBounds()", "full": "public com.anychart.math.Rect getPixelBounds() {\n        return new com.anychart.math.Rect(jsBase + \".getPixelBounds()\");\n    }"}, {"signature": "public com.anychart.math.Rect getRemainingBounds()", "full": "public com.anychart.math.Rect getRemainingBounds() {\n        return new com.anychart.math.Rect(jsBase + \".getRemainingBounds()\");\n    }"}, {"signature": "public void hAlign()", "full": "public void hAlign() {\n        APIlib.getInstance().addJSLine(jsBase + \".hAlign();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend hAlign(com.anychart.graphics.vector.text.HAlign align)", "full": "public com.anychart.core.ui.Legend hAlign(com.anychart.graphics.vector.text.HAlign align) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".hAlign(%s);\", (align != null) ? align.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void height()", "full": "public void height() {\n        APIlib.getInstance().addJSLine(jsBase + \".height();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend height(Number height)", "full": "public com.anychart.core.ui.Legend height(Number height) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".height(%s);\", height));\n\n        return this;\n    }"}, {"signature": "public void hoverCursor()", "full": "public void hoverCursor() {\n        APIlib.getInstance().addJSLine(jsBase + \".hoverCursor();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend hoverCursor(com.anychart.enums.Cursor cursorTypr)", "full": "public com.anychart.core.ui.Legend hoverCursor(com.anychart.enums.Cursor cursorTypr) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".hoverCursor(%s);\", (cursorTypr != null) ? cursorTypr.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void iconSize()", "full": "public void iconSize() {\n        APIlib.getInstance().addJSLine(jsBase + \".iconSize();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend iconSize(Number size)", "full": "public com.anychart.core.ui.Legend iconSize(Number size) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".iconSize(%s);\", size));\n\n        return this;\n    }"}, {"signature": "public void iconTextSpacing()", "full": "public void iconTextSpacing() {\n        APIlib.getInstance().addJSLine(jsBase + \".iconTextSpacing();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend iconTextSpacing(String spacing)", "full": "public com.anychart.core.ui.Legend iconTextSpacing(String spacing) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".iconTextSpacing(%s);\", wrapQuotes(spacing)));\n\n        return this;\n    }"}, {"signature": "public void inverted()", "full": "public void inverted() {\n        APIlib.getInstance().addJSLine(jsBase + \".inverted();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend inverted(Boolean enabled)", "full": "public com.anychart.core.ui.Legend inverted(Boolean enabled) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".inverted(%s);\", enabled));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.Legend positionMode(com.anychart.enums.LegendPositionMode mode)", "full": "public com.anychart.core.ui.Legend positionMode(com.anychart.enums.LegendPositionMode mode) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".positionMode(%s);\", (mode != null) ? mode.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void print(com.anychart.graphics.vector.PaperSize paperSizeOrOptions, Boolean landscape)", "full": "public void print(com.anychart.graphics.vector.PaperSize paperSizeOrOptions, Boolean landscape) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".print(%s, %s);\", (paperSizeOrOptions != null) ? paperSizeOrOptions.getJsBase() : null, landscape));\n    }"}, {"signature": "public void removeAllListeners(String type)", "full": "public void removeAllListeners(String type) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".removeAllListeners(%s);\", wrapQuotes(type)));\n    }"}, {"signature": "public void selectable()", "full": "public void selectable() {\n        APIlib.getInstance().addJSLine(jsBase + \".selectable();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend selectable(Boolean enabled)", "full": "public com.anychart.core.ui.Legend selectable(Boolean enabled) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".selectable(%s);\", enabled));\n\n        return this;\n    }"}, {"signature": "public void textDirection()", "full": "public void textDirection() {\n        APIlib.getInstance().addJSLine(jsBase + \".textDirection();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend textDirection(com.anychart.graphics.vector.text.Direction direction)", "full": "public com.anychart.core.ui.Legend textDirection(com.anychart.graphics.vector.text.Direction direction) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".textDirection(%s);\", (direction != null) ? direction.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void textIndent()", "full": "public void textIndent() {\n        APIlib.getInstance().addJSLine(jsBase + \".textIndent();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend textIndent(Number indent)", "full": "public com.anychart.core.ui.Legend textIndent(Number indent) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".textIndent(%s);\", indent));\n\n        return this;\n    }"}, {"signature": "public void textOverflow()", "full": "public void textOverflow() {\n        APIlib.getInstance().addJSLine(jsBase + \".textOverflow();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend textOverflow(com.anychart.graphics.vector.text.TextOverflow value)", "full": "public com.anychart.core.ui.Legend textOverflow(com.anychart.graphics.vector.text.TextOverflow value) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".textOverflow(%s);\", (value != null) ? value.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void textSettings()", "full": "public void textSettings() {\n        APIlib.getInstance().addJSLine(jsBase + \".textSettings();\");\n    }"}, {"signature": "public void textSettings(String name)", "full": "public void textSettings(String name) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".textSettings(%s);\", wrapQuotes(name)));\n    }"}, {"signature": "public com.anychart.core.ui.Legend textSettings(String name, String settings)", "full": "public com.anychart.core.ui.Legend textSettings(String name, String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".textSettings(%s, %s);\", wrapQuotes(name), wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.Title title()", "full": "public com.anychart.core.ui.Title title() {\n        return new com.anychart.core.ui.Title(jsBase + \".title()\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend title(Boolean settings)", "full": "public com.anychart.core.ui.Legend title(Boolean settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".title(%s);\", settings));\n\n        return this;\n    }"}, {"signature": "public void titleFormat()", "full": "public void titleFormat() {\n        APIlib.getInstance().addJSLine(jsBase + \".titleFormat();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend titleFormat(String format)", "full": "public com.anychart.core.ui.Legend titleFormat(String format) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".titleFormat(%s);\", wrapQuotes(format)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.Separator titleSeparator()", "full": "public com.anychart.core.ui.Separator titleSeparator() {\n        return new com.anychart.core.ui.Separator(jsBase + \".titleSeparator()\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend titleSeparator(String settings)", "full": "public com.anychart.core.ui.Legend titleSeparator(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".titleSeparator(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.Tooltip tooltip()", "full": "public com.anychart.core.ui.Tooltip tooltip() {\n        return new com.anychart.core.ui.Tooltip(jsBase + \".tooltip()\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend tooltip(String settings)", "full": "public com.anychart.core.ui.Legend tooltip(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".tooltip(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }"}, {"signature": "public void setOnClickListener(com.anychart.chart.common.listener.ListenersInterface.OnClickListener listener)", "full": "public void setOnClickListener(com.anychart.chart.common.listener.ListenersInterface.OnClickListener listener) {\n        StringBuilder js = new StringBuilder();\n\n        js.append(jsBase).append(\".listen('pointClick', function(e) {\");\n\n        if (listener.getFields() != null) {\n            js.append(\"var result = \");\n            for (String field : listener.getFields()) {\n                js.append(String.format(Locale.US, \"'%1$s' + ':' + e.point.get('%1$s') + ',' +\", field));\n            }\n            js.setLength(js.length() - 8);\n            js.append(\";\");\n\n            js.append(\"android.onClick(result);\");\n        } else {\n            js.append(\"android.onClick(null);\");\n        }\n        js.append(\"});\");\n\n        com.anychart.chart.common.listener.ListenersInterface.getInstance().setOnClickListener(listener);\n\n        APIlib.getInstance().addJSLine(js.toString());\n    }"}, {"signature": "public void setOnClickListener(com.anychart.chart.common.listener.ListenersInterface.OnClickListener listener, String type, String ePath)", "full": "public void setOnClickListener(com.anychart.chart.common.listener.ListenersInterface.OnClickListener listener, String type, String ePath) {\n        StringBuilder js = new StringBuilder();\n\n        js.append(jsBase).append(String.format(Locale.US, \".listen('%1$s', function(e) {\", type));\n\n        if (listener.getFields() != null) {\n            ePath = (ePath != null) ? ePath + \".\" : \"\";\n            js.append(\"var result = \");\n            for (String field : listener.getFields()) {\n                js.append(String.format(Locale.US, \"'%1$s' + ':' + e.%2$s%1$s + ',' +\", field, ePath));\n            }\n            js.setLength(js.length() - 8);\n            js.append(\";\");\n\n            js.append(\"android.onClick(result);\");\n        } else {\n            js.append(\"android.onClick(null);\");\n        }\n        js.append(\"});\");\n\n        com.anychart.chart.common.listener.ListenersInterface.getInstance().setOnClickListener(listener);\n\n        APIlib.getInstance().addJSLine(js.toString());\n    }"}, {"signature": "public void unlistenByKey(String key)", "full": "public void unlistenByKey(String key) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".unlistenByKey(%s);\", wrapQuotes(key)));\n    }"}, {"signature": "public void useHtml()", "full": "public void useHtml() {\n        APIlib.getInstance().addJSLine(jsBase + \".useHtml();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend useHtml(Boolean enabled)", "full": "public com.anychart.core.ui.Legend useHtml(Boolean enabled) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".useHtml(%s);\", enabled));\n\n        return this;\n    }"}, {"signature": "public void vAlign()", "full": "public void vAlign() {\n        APIlib.getInstance().addJSLine(jsBase + \".vAlign();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend vAlign(com.anychart.graphics.vector.text.VAlign align)", "full": "public com.anychart.core.ui.Legend vAlign(com.anychart.graphics.vector.text.VAlign align) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".vAlign(%s);\", (align != null) ? align.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void width()", "full": "public void width() {\n        APIlib.getInstance().addJSLine(jsBase + \".width();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend width(Number width)", "full": "public com.anychart.core.ui.Legend width(Number width) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".width(%s);\", width));\n\n        return this;\n    }"}, {"signature": "public void wordBreak()", "full": "public void wordBreak() {\n        APIlib.getInstance().addJSLine(jsBase + \".wordBreak();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend wordBreak(com.anychart.enums.WordBreak mode)", "full": "public com.anychart.core.ui.Legend wordBreak(com.anychart.enums.WordBreak mode) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".wordBreak(%s);\", (mode != null) ? mode.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void wordWrap()", "full": "public void wordWrap() {\n        APIlib.getInstance().addJSLine(jsBase + \".wordWrap();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend wordWrap(com.anychart.enums.WordWrap mode)", "full": "public com.anychart.core.ui.Legend wordWrap(com.anychart.enums.WordWrap mode) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".wordWrap(%s);\", (mode != null) ? mode.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public void zIndex()", "full": "public void zIndex() {\n        APIlib.getInstance().addJSLine(jsBase + \".zIndex();\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend zIndex(Number zIndex)", "full": "public com.anychart.core.ui.Legend zIndex(Number zIndex) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".zIndex(%s);\", zIndex));\n\n        return this;\n    }"}, {"signature": "public com.anychart.graphics.vector.Layer container()", "full": "public com.anychart.graphics.vector.Layer container() {\n        return new com.anychart.graphics.vector.Layer(jsBase + \".container()\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend container(com.anychart.graphics.vector.Layer element)", "full": "public com.anychart.core.ui.Legend container(com.anychart.graphics.vector.Layer element) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".container(%s);\", (element != null) ? element.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public com.anychart.math.Rect parentBounds()", "full": "public com.anychart.math.Rect parentBounds() {\n        return new com.anychart.math.Rect(jsBase + \".parentBounds()\");\n    }"}, {"signature": "public com.anychart.core.ui.Legend parentBounds(com.anychart.math.Rect bounds)", "full": "public com.anychart.core.ui.Legend parentBounds(com.anychart.math.Rect bounds) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".parentBounds(%s);\", (bounds != null) ? bounds.getJsBase() : null));\n\n        return this;\n    }"}, {"signature": "public com.anychart.core.ui.Legend parentBounds(Number left, Number top, Number width, Number height) \n\n}", "full": "public com.anychart.core.ui.Legend parentBounds(Number left, Number top, Number width, Number height) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".parentBounds(%s, %s, %s, %s);\", left, top, width, height));\n\n        return this;\n    }\n\n}"}], "class_attributes": []}
{"id": 2645549, "class_signatures": "public class ASortedMap<K,V> extends TreeMap<K,V>", "class_methods": [{"signature": "public ASortedMap()", "full": "public ASortedMap() {\n\t\tsuper();\n\t}"}, {"signature": "public ASortedMap(Comparator<K> c)", "full": "public ASortedMap(Comparator<K> c) {\n\t\tsuper(c);\n\t}"}, {"signature": "public static <K,V> ASortedMap<K,V> create()", "full": "public static <K,V> ASortedMap<K,V> create() {\n\t\treturn new ASortedMap<>();\n\t}"}, {"signature": "public static <K,V> ASortedMap<K,V> of(K key, V value)", "full": "public static <K,V> ASortedMap<K,V> of(K key, V value) {\n\t\treturn new ASortedMap<K,V>().a(key, value);\n\t}"}, {"signature": "public static <K,V> ASortedMap<K,V> of(Map<K,V> copy)", "full": "public static <K,V> ASortedMap<K,V> of(Map<K,V> copy) {\n\t\treturn new ASortedMap<>(copy);\n\t}"}, {"signature": "public static <K,V> SortedMap<K,V> unmodifiable(Map<K,V> c)", "full": "public static <K,V> SortedMap<K,V> unmodifiable(Map<K,V> c) {\n\t\tif (c == null || c.isEmpty())\n\t\t\treturn Collections.emptySortedMap();\n\t\treturn new ASortedMap<>(c).unmodifiable();\n\t}"}, {"signature": "public static <K,V> ASortedMap<K,V> nullable(Map<K,V> c)", "full": "public static <K,V> ASortedMap<K,V> nullable(Map<K,V> c) {\n\t\treturn c == null ? null : of(c);\n\t}"}, {"signature": "public ASortedMap<K,V> append(K key, V value)", "full": "public ASortedMap<K,V> append(K key, V value) {\n\t\tput(key, value);\n\t\treturn this;\n\t}"}, {"signature": "public ASortedMap<K,V> append(Map<K,V> values)", "full": "public ASortedMap<K,V> append(Map<K,V> values) {\n\t\tsuper.putAll(values);\n\t\treturn this;\n\t}"}, {"signature": "public ASortedMap<K,V> a(K key, V value)", "full": "public ASortedMap<K,V> a(K key, V value) {\n\t\treturn append(key, value);\n\t}"}, {"signature": "public ASortedMap<K,V> a(Map<K,V> values)", "full": "public ASortedMap<K,V> a(Map<K,V> values) {\n\t\treturn append(values);\n\t}"}, {"signature": "public ASortedMap<K,V> appendIf(boolean flag, K key, V value)", "full": "public ASortedMap<K,V> appendIf(boolean flag, K key, V value) {\n\t\tif (flag)\n\t\t\tappend(key, value);\n\t\treturn this;\n\t}"}, {"signature": "public SortedMap<K,V> unmodifiable()", "full": "public SortedMap<K,V> unmodifiable() {\n\t\treturn isEmpty() ? emptySortedMap() : unmodifiableSortedMap(this);\n\t}"}, {"signature": "public String asString(WriterSerializer ws)", "full": "public String asString(WriterSerializer ws) {\n\t\treturn ws.toString(this);\n\t}"}, {"signature": "public String asJson() \n}", "full": "public String asJson() {\n\t\treturn SimpleJsonSerializer.DEFAULT.toString(this);\n\t}\n}"}], "class_attributes": [{"type": "long", "name": "serialVersionUID"}]}
{"id": 2752281, "class_signatures": "public class MethodInvoker", "class_methods": [{"signature": "public MethodInvoker(Method m, MethodExecStats stats)", "full": "public MethodInvoker(Method m, MethodExecStats stats) {\n\t\tthis.m = MethodInfo.of(m);\n\t\tthis.stats = stats;\n\t}"}, {"signature": "public MethodInfo inner()", "full": "public MethodInfo inner() {\n\t\treturn m;\n\t}"}, {"signature": "public Object invoke(Object o, Object...args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException", "full": "public Object invoke(Object o, Object...args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n\t\tlong startTime = System.nanoTime();\n\t\tstats.started();\n\t\ttry {\n\t\t\treturn m.inner().invoke(o, args);\n\t\t} catch (IllegalAccessException|IllegalArgumentException e) {\n\t\t\tstats.error(e);\n\t\t\tthrow e;\n\t\t} catch (InvocationTargetException e) {\n\t\t\tstats.error(e.getTargetException());\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tstats.finished(System.nanoTime() - startTime);\n\t\t}\n\t}"}, {"signature": "public ClassInfo getDeclaringClass()", "full": "public ClassInfo getDeclaringClass() {\n\t\treturn m.getDeclaringClass();\n\t}"}, {"signature": "public String getFullName()", "full": "public String getFullName() {\n\t\treturn m.getFullName();\n\t}"}, {"signature": "public MethodExecStats getStats() \n}", "full": "public MethodExecStats getStats() {\n\t\treturn stats;\n\t}\n}"}], "class_attributes": [{"type": "MethodInfo", "name": "m"}, {"type": "MethodExecStats", "name": "stats"}]}
{"id": 2878100, "class_signatures": "public class CacheConfig implements Cloneable", "class_methods": [{"signature": "public CacheConfig()", "full": "@Deprecated\n    public CacheConfig() {\n        super();\n        this.maxObjectSize = DEFAULT_MAX_OBJECT_SIZE_BYTES;\n        this.maxCacheEntries = DEFAULT_MAX_CACHE_ENTRIES;\n        this.maxUpdateRetries = DEFAULT_MAX_UPDATE_RETRIES;\n        this.allow303Caching = DEFAULT_303_CACHING_ENABLED;\n        this.weakETagOnPutDeleteAllowed = DEFAULT_WEAK_ETAG_ON_PUTDELETE_ALLOWED;\n        this.heuristicCachingEnabled = DEFAULT_HEURISTIC_CACHING_ENABLED;\n        this.heuristicCoefficient = DEFAULT_HEURISTIC_COEFFICIENT;\n        this.heuristicDefaultLifetime = DEFAULT_HEURISTIC_LIFETIME;\n        this.isSharedCache = true;\n        this.asynchronousWorkersMax = DEFAULT_ASYNCHRONOUS_WORKERS_MAX;\n        this.asynchronousWorkersCore = DEFAULT_ASYNCHRONOUS_WORKERS_CORE;\n        this.asynchronousWorkerIdleLifetimeSecs = DEFAULT_ASYNCHRONOUS_WORKER_IDLE_LIFETIME_SECS;\n        this.revalidationQueueSize = DEFAULT_REVALIDATION_QUEUE_SIZE;\n    }"}, {"signature": "CacheConfig(\n            final long maxObjectSize,\n            final int maxCacheEntries,\n            final int maxUpdateRetries,\n            final boolean allow303Caching,\n            final boolean weakETagOnPutDeleteAllowed,\n            final boolean heuristicCachingEnabled,\n            final float heuristicCoefficient,\n            final long heuristicDefaultLifetime,\n            final boolean isSharedCache,\n            final int asynchronousWorkersMax,\n            final int asynchronousWorkersCore,\n            final int asynchronousWorkerIdleLifetimeSecs,\n            final int revalidationQueueSize,\n            final boolean neverCacheHTTP10ResponsesWithQuery)", "full": "CacheConfig(\n            final long maxObjectSize,\n            final int maxCacheEntries,\n            final int maxUpdateRetries,\n            final boolean allow303Caching,\n            final boolean weakETagOnPutDeleteAllowed,\n            final boolean heuristicCachingEnabled,\n            final float heuristicCoefficient,\n            final long heuristicDefaultLifetime,\n            final boolean isSharedCache,\n            final int asynchronousWorkersMax,\n            final int asynchronousWorkersCore,\n            final int asynchronousWorkerIdleLifetimeSecs,\n            final int revalidationQueueSize,\n            final boolean neverCacheHTTP10ResponsesWithQuery) {\n        super();\n        this.maxObjectSize = maxObjectSize;\n        this.maxCacheEntries = maxCacheEntries;\n        this.maxUpdateRetries = maxUpdateRetries;\n        this.allow303Caching = allow303Caching;\n        this.weakETagOnPutDeleteAllowed = weakETagOnPutDeleteAllowed;\n        this.heuristicCachingEnabled = heuristicCachingEnabled;\n        this.heuristicCoefficient = heuristicCoefficient;\n        this.heuristicDefaultLifetime = heuristicDefaultLifetime;\n        this.isSharedCache = isSharedCache;\n        this.asynchronousWorkersMax = asynchronousWorkersMax;\n        this.asynchronousWorkersCore = asynchronousWorkersCore;\n        this.asynchronousWorkerIdleLifetimeSecs = asynchronousWorkerIdleLifetimeSecs;\n        this.revalidationQueueSize = revalidationQueueSize;\n    }"}, {"signature": "public int getMaxObjectSizeBytes()", "full": "@Deprecated\n    public int getMaxObjectSizeBytes() {\n        return maxObjectSize > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) maxObjectSize;\n    }"}, {"signature": "public void setMaxObjectSizeBytes(final int maxObjectSizeBytes)", "full": "@Deprecated\n    public void setMaxObjectSizeBytes(final int maxObjectSizeBytes) {\n        if (maxObjectSizeBytes > Integer.MAX_VALUE) {\n            this.maxObjectSize = Integer.MAX_VALUE;\n        } else {\n            this.maxObjectSize = maxObjectSizeBytes;\n        }\n    }"}, {"signature": "public long getMaxObjectSize()", "full": "public long getMaxObjectSize() {\n        return maxObjectSize;\n    }"}, {"signature": "public void setMaxObjectSize(final long maxObjectSize)", "full": "@Deprecated\n    public void setMaxObjectSize(final long maxObjectSize) {\n        this.maxObjectSize = maxObjectSize;\n    }"}, {"signature": "public boolean isNeverCacheHTTP10ResponsesWithQuery()", "full": "public boolean isNeverCacheHTTP10ResponsesWithQuery() {\n        return neverCacheHTTP10ResponsesWithQuery;\n    }"}, {"signature": "public int getMaxCacheEntries()", "full": "public int getMaxCacheEntries() {\n        return maxCacheEntries;\n    }"}, {"signature": "public void setMaxCacheEntries(final int maxCacheEntries)", "full": "@Deprecated\n    public void setMaxCacheEntries(final int maxCacheEntries) {\n        this.maxCacheEntries = maxCacheEntries;\n    }"}, {"signature": "public int getMaxUpdateRetries()", "full": "public int getMaxUpdateRetries(){\n        return maxUpdateRetries;\n    }"}, {"signature": "public void setMaxUpdateRetries(final int maxUpdateRetries)", "full": "@Deprecated\n    public void setMaxUpdateRetries(final int maxUpdateRetries){\n        this.maxUpdateRetries = maxUpdateRetries;\n    }"}, {"signature": "public boolean is303CachingEnabled()", "full": "public boolean is303CachingEnabled() {\n        return allow303Caching;\n    }"}, {"signature": "public boolean isWeakETagOnPutDeleteAllowed()", "full": "public boolean isWeakETagOnPutDeleteAllowed() {\n        return weakETagOnPutDeleteAllowed;\n    }"}, {"signature": "public boolean isHeuristicCachingEnabled()", "full": "public boolean isHeuristicCachingEnabled() {\n        return heuristicCachingEnabled;\n    }"}, {"signature": "public void setHeuristicCachingEnabled(final boolean heuristicCachingEnabled)", "full": "@Deprecated\n    public void setHeuristicCachingEnabled(final boolean heuristicCachingEnabled) {\n        this.heuristicCachingEnabled = heuristicCachingEnabled;\n    }"}, {"signature": "public float getHeuristicCoefficient()", "full": "public float getHeuristicCoefficient() {\n        return heuristicCoefficient;\n    }"}, {"signature": "public void setHeuristicCoefficient(final float heuristicCoefficient)", "full": "@Deprecated\n    public void setHeuristicCoefficient(final float heuristicCoefficient) {\n        this.heuristicCoefficient = heuristicCoefficient;\n    }"}, {"signature": "public long getHeuristicDefaultLifetime()", "full": "public long getHeuristicDefaultLifetime() {\n        return heuristicDefaultLifetime;\n    }"}, {"signature": "public void setHeuristicDefaultLifetime(final long heuristicDefaultLifetimeSecs)", "full": "@Deprecated\n    public void setHeuristicDefaultLifetime(final long heuristicDefaultLifetimeSecs) {\n        this.heuristicDefaultLifetime = heuristicDefaultLifetimeSecs;\n    }"}, {"signature": "public boolean isSharedCache()", "full": "public boolean isSharedCache() {\n        return isSharedCache;\n    }"}, {"signature": "public void setSharedCache(final boolean isSharedCache)", "full": "@Deprecated\n    public void setSharedCache(final boolean isSharedCache) {\n        this.isSharedCache = isSharedCache;\n    }"}, {"signature": "public int getAsynchronousWorkersMax()", "full": "public int getAsynchronousWorkersMax() {\n        return asynchronousWorkersMax;\n    }"}, {"signature": "public void setAsynchronousWorkersMax(final int max)", "full": "@Deprecated\n    public void setAsynchronousWorkersMax(final int max) {\n        this.asynchronousWorkersMax = max;\n    }"}, {"signature": "public int getAsynchronousWorkersCore()", "full": "public int getAsynchronousWorkersCore() {\n        return asynchronousWorkersCore;\n    }"}, {"signature": "public void setAsynchronousWorkersCore(final int min)", "full": "@Deprecated\n    public void setAsynchronousWorkersCore(final int min) {\n        this.asynchronousWorkersCore = min;\n    }"}, {"signature": "public int getAsynchronousWorkerIdleLifetimeSecs()", "full": "public int getAsynchronousWorkerIdleLifetimeSecs() {\n        return asynchronousWorkerIdleLifetimeSecs;\n    }"}, {"signature": "public void setAsynchronousWorkerIdleLifetimeSecs(final int secs)", "full": "@Deprecated\n    public void setAsynchronousWorkerIdleLifetimeSecs(final int secs) {\n        this.asynchronousWorkerIdleLifetimeSecs = secs;\n    }"}, {"signature": "public int getRevalidationQueueSize()", "full": "public int getRevalidationQueueSize() {\n        return revalidationQueueSize;\n    }"}, {"signature": "public void setRevalidationQueueSize(final int size)", "full": "@Deprecated\n    public void setRevalidationQueueSize(final int size) {\n        this.revalidationQueueSize = size;\n    }"}, {"signature": "protected CacheConfig clone() throws CloneNotSupportedException", "full": "@Override\n    protected CacheConfig clone() throws CloneNotSupportedException {\n        return (CacheConfig) super.clone();\n    }"}, {"signature": "public static Builder custom()", "full": "public static Builder custom() {\n        return new Builder();\n    }"}, {"signature": "public static Builder copy(final CacheConfig config)", "full": "public static Builder copy(final CacheConfig config) {\n        Args.notNull(config, \"Cache config\");\n        return new Builder()\n            .setMaxObjectSize(config.getMaxObjectSize())\n            .setMaxCacheEntries(config.getMaxCacheEntries())\n            .setMaxUpdateRetries(config.getMaxUpdateRetries())\n            .setHeuristicCachingEnabled(config.isHeuristicCachingEnabled())\n            .setHeuristicCoefficient(config.getHeuristicCoefficient())\n            .setHeuristicDefaultLifetime(config.getHeuristicDefaultLifetime())\n            .setSharedCache(config.isSharedCache())\n            .setAsynchronousWorkersMax(config.getAsynchronousWorkersMax())\n            .setAsynchronousWorkersCore(config.getAsynchronousWorkersCore())\n            .setAsynchronousWorkerIdleLifetimeSecs(config.getAsynchronousWorkerIdleLifetimeSecs())\n            .setRevalidationQueueSize(config.getRevalidationQueueSize())\n            .setNeverCacheHTTP10ResponsesWithQueryString(config.isNeverCacheHTTP10ResponsesWithQuery());\n    }"}, {"signature": "public String toString() \n\n}", "full": "@Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder();\n        builder.append(\"[maxObjectSize=\").append(this.maxObjectSize)\n                .append(\", maxCacheEntries=\").append(this.maxCacheEntries)\n                .append(\", maxUpdateRetries=\").append(this.maxUpdateRetries)\n                .append(\", 303CachingEnabled=\").append(this.allow303Caching)\n                .append(\", weakETagOnPutDeleteAllowed=\").append(this.weakETagOnPutDeleteAllowed)\n                .append(\", heuristicCachingEnabled=\").append(this.heuristicCachingEnabled)\n                .append(\", heuristicCoefficient=\").append(this.heuristicCoefficient)\n                .append(\", heuristicDefaultLifetime=\").append(this.heuristicDefaultLifetime)\n                .append(\", isSharedCache=\").append(this.isSharedCache)\n                .append(\", asynchronousWorkersMax=\").append(this.asynchronousWorkersMax)\n                .append(\", asynchronousWorkersCore=\").append(this.asynchronousWorkersCore)\n                .append(\", asynchronousWorkerIdleLifetimeSecs=\").append(this.asynchronousWorkerIdleLifetimeSecs)\n                .append(\", revalidationQueueSize=\").append(this.revalidationQueueSize)\n                .append(\", neverCacheHTTP10ResponsesWithQuery=\").append(this.neverCacheHTTP10ResponsesWithQuery)\n                .append(\"]\");\n        return builder.toString();\n    }\n\n}"}], "class_attributes": [{"type": "int", "name": "DEFAULT_MAX_OBJECT_SIZE_BYTES"}, {"type": "int", "name": "DEFAULT_MAX_CACHE_ENTRIES"}, {"type": "int", "name": "DEFAULT_MAX_UPDATE_RETRIES"}, {"type": "boolean", "name": "DEFAULT_303_CACHING_ENABLED"}, {"type": "boolean", "name": "DEFAULT_WEAK_ETAG_ON_PUTDELETE_ALLOWED"}, {"type": "boolean", "name": "DEFAULT_HEURISTIC_CACHING_ENABLED"}, {"type": "float", "name": "DEFAULT_HEURISTIC_COEFFICIENT"}, {"type": "long", "name": "DEFAULT_HEURISTIC_LIFETIME"}, {"type": "int", "name": "DEFAULT_ASYNCHRONOUS_WORKERS_MAX"}, {"type": "int", "name": "DEFAULT_ASYNCHRONOUS_WORKERS_CORE"}, {"type": "int", "name": "DEFAULT_ASYNCHRONOUS_WORKER_IDLE_LIFETIME_SECS"}, {"type": "int", "name": "DEFAULT_REVALIDATION_QUEUE_SIZE"}, {"type": "CacheConfig", "name": "DEFAULT"}, {"type": "long", "name": "maxObjectSize"}, {"type": "int", "name": "maxCacheEntries"}, {"type": "int", "name": "maxUpdateRetries"}, {"type": "boolean", "name": "allow303Caching"}, {"type": "boolean", "name": "weakETagOnPutDeleteAllowed"}, {"type": "boolean", "name": "heuristicCachingEnabled"}, {"type": "float", "name": "heuristicCoefficient"}, {"type": "long", "name": "heuristicDefaultLifetime"}, {"type": "boolean", "name": "isSharedCache"}, {"type": "int", "name": "asynchronousWorkersMax"}, {"type": "int", "name": "asynchronousWorkersCore"}, {"type": "int", "name": "asynchronousWorkerIdleLifetimeSecs"}, {"type": "int", "name": "revalidationQueueSize"}, {"type": "boolean", "name": "neverCacheHTTP10ResponsesWithQuery"}]}
{"id": 2957999, "class_signatures": "public class PackagingOptions implements com.android.builder.model.PackagingOptions", "class_methods": [{"signature": "public Set<String> getExcludes()", "full": "@Override\n    @NonNull\n    @Input\n    public Set<String> getExcludes() {\n        return Sets.newHashSet(excludes);\n    }"}, {"signature": "public void setExcludes(Set<String> excludes)", "full": "public void setExcludes(Set<String> excludes) {\n        this.excludes = Sets.newHashSet(excludes);\n    }"}, {"signature": "public void exclude(String path)", "full": "public void exclude(String path) {\n        excludes.add(path);\n    }"}, {"signature": "public Set<String> getPickFirsts()", "full": "@Override\n    @NonNull\n    @Input\n    public Set<String> getPickFirsts() {\n        return Sets.newHashSet(pickFirsts);\n    }"}, {"signature": "public void setPickFirsts(Set<String> pickFirsts)", "full": "public void setPickFirsts(Set<String> pickFirsts) {\n        this.pickFirsts = Sets.newHashSet(pickFirsts);\n    }"}, {"signature": "public void pickFirst(String path)", "full": "public void pickFirst(String path) {\n        pickFirsts.add(path);\n    }"}, {"signature": "public Set<String> getMerges()", "full": "@Override\n    @NonNull\n    @Input\n    public Set<String> getMerges() {\n        return Sets.newHashSet(merges);\n    }"}, {"signature": "public void setMerges(Set<String> merges)", "full": "public void setMerges(Set<String> merges) {\n        this.merges = Sets.newHashSet(merges);\n    }"}, {"signature": "public void merge(String path) \n}", "full": "public void merge(String path) {\n        merges.add(path);\n    }\n}"}], "class_attributes": [{"type": "Set", "name": "excludes"}, {"type": "Set", "name": "pickFirsts"}, {"type": "Set", "name": "merges"}]}
{"id": 4118692, "class_signatures": "class CountingInputStream extends FilterInputStream", "class_methods": [{"signature": "public CountingInputStream(final InputStream stream)", "full": "public CountingInputStream(final InputStream stream) {\n        super(stream);\n        this.markPos = 0;\n        this.readCount = 0;\n    }"}, {"signature": "private synchronized void bytesRead(final long amountRead)", "full": "private synchronized void bytesRead(final long amountRead) {\n        if (amountRead >= 0)\n        {\n            this.readCount += amountRead;\n        }\n    }"}, {"signature": "public synchronized long getReadCount()", "full": "public synchronized long getReadCount() {\n        return this.readCount;\n    }"}, {"signature": "public synchronized void mark(final int readlimit)", "full": "@Override\n    public synchronized void mark(final int readlimit) {\n        super.mark(readlimit);\n        this.markPos = this.readCount;\n    }"}, {"signature": "public int read() throws IOException", "full": "@Override\n    public int read() throws IOException {\n        final int result = super.read();\n        bytesRead(1);\n        return result;\n    }"}, {"signature": "public int read(final byte[] destination, final int off, final int len)\n            throws IOException", "full": "@Override\n    public int read(final byte[] destination, final int off, final int len)\n            throws IOException {\n        final int result = super.read(destination, off, len);\n        bytesRead(result);\n        return result;\n    }"}, {"signature": "public synchronized void reset() throws IOException", "full": "@Override\n    public synchronized void reset() throws IOException {\n        super.reset();\n        synchronized (this) {\n            this.readCount = this.markPos;\n        }\n    }"}, {"signature": "public long skip(final long amount) throws IOException \n\n}", "full": "@Override\n    public long skip(final long amount) throws IOException {\n        final long skipped = super.skip(amount);\n        bytesRead(skipped);\n        return skipped;\n    }\n\n}"}], "class_attributes": [{"type": "long", "name": "markPos"}, {"type": "long", "name": "readCount"}]}
{"id": 4204781, "class_signatures": "abstract class AbstractFileTrackImporter extends DefaultHandler implements TrackImporter", "class_methods": [{"signature": "private void cleanImport() \n}", "full": "private void cleanImport() {\n    for (long trackId : trackIds) {\n      myTracksProviderUtils.deleteTrack(context, trackId);\n    }\n  }\n}"}, {"signature": "AbstractFileTrackImporter(\n      Context context, long importTrackId, MyTracksProviderUtils myTracksProviderUtils)", "full": "AbstractFileTrackImporter(\n      Context context, long importTrackId, MyTracksProviderUtils myTracksProviderUtils) {\n    this.context = context;\n    this.importTrackId = importTrackId;\n    this.myTracksProviderUtils = myTracksProviderUtils;\n    this.recordingDistanceInterval = PreferencesUtils.getInt(context,\n        R.string.recording_distance_interval_key,\n        PreferencesUtils.RECORDING_DISTANCE_INTERVAL_DEFAULT);\n    this.weight = PreferencesUtils.getFloat(\n        context, R.string.weight_key, PreferencesUtils.getDefaultWeight(context));\n    trackIds = new ArrayList<Long>();\n    waypoints = new ArrayList<Waypoint>();\n  }"}, {"signature": "public void setDocumentLocator(Locator locator)", "full": "@Override\n  public void setDocumentLocator(Locator locator) {\n    this.locator = locator;\n  }"}, {"signature": "public void characters(char[] ch, int start, int length) throws SAXException", "full": "@Override\n  public void characters(char[] ch, int start, int length) throws SAXException {\n    String newContent = new String(ch, start, length);\n    if (content == null) {\n      content = newContent;\n    } else {\n      content += newContent;\n    }\n  }"}, {"signature": "public long importFile(InputStream inputStream)", "full": "@Override\n  public long importFile(InputStream inputStream) {\n    try {\n      SAXParser saxParser = SAXParserFactory.newInstance().newSAXParser();\n      long start = System.currentTimeMillis();\n\n      saxParser.parse(inputStream, this);\n      Log.d(TAG, \"Total import time: \" + (System.currentTimeMillis() - start) + \"ms\");\n      if (trackIds.size() != 1) {\n        Log.d(TAG, trackIds.size() + \" tracks imported\");\n        cleanImport();\n        return -1L;\n      }\n      return trackIds.get(0);\n    } catch (IOException e) {\n      Log.e(TAG, \"Unable to import file\", e);\n      cleanImport();\n      return -1L;\n    } catch (ParserConfigurationException e) {\n      Log.e(TAG, \"Unable to import file\", e);\n      cleanImport();\n      return -1L;\n    } catch (SAXException e) {\n      Log.e(TAG, \"Unable to import file\", e);\n      cleanImport();\n      return -1L;\n    }\n  }"}, {"signature": "protected void onFileEnd()", "full": "protected void onFileEnd() {\n    int size = trackIds.size();\n    if (size == 0) {\n      return;\n    }\n    long trackId = trackIds.get(size - 1);\n    Track track = myTracksProviderUtils.getTrack(trackId);\n    if (track == null) {\n      return;\n    }\n\n    int waypointPosition = -1;\n    Waypoint waypoint = null;\n    Location location = null;\n    TripStatisticsUpdater trackTripStatisticstrackUpdater = new TripStatisticsUpdater(\n        track.getTripStatistics().getStartTime());\n    TripStatisticsUpdater markerTripStatisticsUpdater = new TripStatisticsUpdater(\n        track.getTripStatistics().getStartTime());\n    LocationIterator locationIterator = null;\n    ActivityType activityType = CalorieUtils.getActivityType(context, track.getCategory());\n    \n    try {\n      locationIterator = myTracksProviderUtils.getTrackPointLocationIterator(\n          track.getId(), -1L, false, MyTracksProviderUtils.DEFAULT_LOCATION_FACTORY);\n\n      while (true) {\n        if (waypoint == null) {\n          waypointPosition++;\n          waypoint = waypointPosition < waypoints.size() ? waypoints.get(waypointPosition) : null;\n          if (waypoint == null) {\n            return;\n          }\n        }\n        if (location == null) {\n          if (!locationIterator.hasNext()) {\n            return;\n          }\n          location = locationIterator.next();\n          trackTripStatisticstrackUpdater.addLocation(\n              location, recordingDistanceInterval, false, ActivityType.INVALID, 0.0);\n          markerTripStatisticsUpdater.addLocation(\n              location, recordingDistanceInterval, true, activityType, weight);\n        }\n        if (waypoint.getLocation().getTime() > location.getTime()) {\n          location = null;\n        } else if (waypoint.getLocation().getTime() < location.getTime()) {\n          waypoint = null;\n        } else {\n          if (!LocationUtils.isValidLocation(location)) {\n            location = null;\n            continue;\n          }\n\n          if (location.getLatitude() == waypoint.getLocation().getLatitude()\n              && location.getLongitude() == waypoint.getLocation().getLongitude()) {\n\n            TripStatistics tripStatistics;\n            String waypointDescription;\n            String icon;\n            if (waypoint.getType() == WaypointType.STATISTICS) {\n              tripStatistics = markerTripStatisticsUpdater.getTripStatistics();\n              markerTripStatisticsUpdater = new TripStatisticsUpdater(location.getTime());\n              waypointDescription = new DescriptionGeneratorImpl(context)\n                  .generateWaypointDescription(tripStatistics);\n              icon = context.getString(R.string.marker_statistics_icon_url);\n            } else {\n              tripStatistics = null;\n              waypointDescription = waypoint.getDescription();\n              icon = context.getString(R.string.marker_waypoint_icon_url);\n            }\n\n            double length = trackTripStatisticstrackUpdater.getTripStatistics().getTotalDistance();\n            long duration = trackTripStatisticstrackUpdater.getTripStatistics().getTotalTime();\n\n            Waypoint newWaypoint = new Waypoint(waypoint.getName(), waypointDescription,\n                waypoint.getCategory(), icon, track.getId(), waypoint.getType(), length, duration,\n                -1L, -1L, location, tripStatistics, waypoint.getPhotoUrl());\n            myTracksProviderUtils.insertWaypoint(newWaypoint);\n          }\n\n          waypoint = null;\n        }\n      }\n    } finally {\n      if (locationIterator != null) {\n        locationIterator.close();\n      }\n    }\n  }"}, {"signature": "protected void onTrackStart() throws SAXException", "full": "protected void onTrackStart() throws SAXException {\n    trackData = new TrackData();\n    long trackId;\n    if (importTrackId == -1L) {\n      Uri uri = myTracksProviderUtils.insertTrack(trackData.track);\n      trackId = Long.parseLong(uri.getLastPathSegment());\n    } else {\n      if (trackIds.size() > 0) {\n        throw new SAXException(createErrorMessage(\n            \"Cannot import more than one track to an existing track \" + importTrackId));\n      }\n      trackId = importTrackId;\n      myTracksProviderUtils.clearTrack(context, trackId);\n    }\n    trackIds.add(trackId);\n    trackData.track.setId(trackId);\n  }"}, {"signature": "protected void onTrackEnd()", "full": "protected void onTrackEnd() {\n    flushLocations(trackData);\n    if (name != null) {\n      trackData.track.setName(name);\n    }\n    if (description != null) {\n      trackData.track.setDescription(description);\n    }\n    if (category != null) {\n      trackData.track.setCategory(category);\n      trackData.track.setIcon(TrackIconUtils.getIconValue(context, category));\n    }\n    if (trackData.tripStatisticsUpdater == null) {\n      trackData.tripStatisticsUpdater = new TripStatisticsUpdater(trackData.importTime);\n      trackData.tripStatisticsUpdater.updateTime(trackData.importTime);\n    }\n    trackData.track.setTripStatistics(trackData.tripStatisticsUpdater.getTripStatistics());\n    trackData.track.setNumberOfPoints(trackData.numberOfLocations);\n    myTracksProviderUtils.updateTrack(trackData.track);\n    insertFirstWaypoint(trackData.track);\n  }"}, {"signature": "protected void onTrackSegmentStart()", "full": "protected void onTrackSegmentStart() {\n    trackData.numberOfSegments++;\n\n    if (trackData.numberOfSegments > 1 && trackData.lastLocationInCurrentSegment != null) {\n      insertLocation(createLocation(TrackRecordingService.PAUSE_LATITUDE, 0.0, 0.0,\n          trackData.lastLocationInCurrentSegment.getTime()));\n    }\n    trackData.lastLocationInCurrentSegment = null;\n  }"}, {"signature": "protected void addWaypoint(WaypointType type) throws SAXException", "full": "protected void addWaypoint(WaypointType type) throws SAXException {\n    if (time == null) {\n      return;\n    }\n\n    Waypoint waypoint = new Waypoint();\n    Location location = createLocation();\n\n    if (!LocationUtils.isValidLocation(location)) {\n      throw new SAXException(createErrorMessage(\"Invalid location detected: \" + location));\n    }\n    waypoint.setLocation(location);\n\n    if (name != null) {\n      waypoint.setName(name);\n    }\n    if (description != null) {\n      waypoint.setDescription(description);\n    }\n    if (category != null) {\n      waypoint.setCategory(category);\n    }\n    waypoint.setType(type);\n    \n    if (photoUrl != null) {\n      waypoint.setPhotoUrl(photoUrl);\n    }\n    waypoints.add(waypoint);\n  }"}, {"signature": "protected Location getTrackPoint() throws SAXException", "full": "protected Location getTrackPoint() throws SAXException {\n    Location location = createLocation();\n\n    if (trackData.lastLocationInCurrentSegment != null\n        && trackData.lastLocationInCurrentSegment.getTime() != 0) {\n      long timeDifference = location.getTime() - trackData.lastLocationInCurrentSegment.getTime();\n\n      if (timeDifference <= 0) {\n        Log.w(TAG, \"Time difference not postive.\");\n      } else {\n\n        double duration = timeDifference * UnitConversions.MS_TO_S;\n        double speed = trackData.lastLocationInCurrentSegment.distanceTo(location) / duration;\n        location.setSpeed((float) speed);\n      }\n      location.setBearing(trackData.lastLocationInCurrentSegment.bearingTo(location));\n    }\n\n    if (!LocationUtils.isValidLocation(location)) {\n      throw new SAXException(createErrorMessage(\"Invalid location detected: \" + location));\n    }\n\n    if (trackData.numberOfSegments > 1 && trackData.lastLocationInCurrentSegment == null) {\n      insertLocation(\n          createLocation(TrackRecordingService.RESUME_LATITUDE, 0.0, 0.0, location.getTime()));\n    }\n    trackData.lastLocationInCurrentSegment = location;\n    return location;\n  }"}, {"signature": "protected void insertTrackPoint(Location location)", "full": "protected void insertTrackPoint(Location location) {\n    insertLocation(location);\n\n    if (trackData.track.getStartId() == -1L) {\n      flushLocations(trackData);\n    }\n  }"}, {"signature": "protected String createErrorMessage(String message)", "full": "protected String createErrorMessage(String message) {\n    return String.format(Locale.US, \"Parsing error at line: %d column: %d. %s\",\n        locator.getLineNumber(), locator.getColumnNumber(), message);\n  }"}, {"signature": "protected String getPhotoUrl(String fileName)", "full": "protected String getPhotoUrl(String fileName) {\n    if (importTrackId == -1L) {\n      return null;\n    }\n    File dir = FileUtils.getPhotoDir(importTrackId);\n    File file = new File(dir, fileName);\n    return Uri.fromFile(file).toString();    \n  }"}, {"signature": "private Location createLocation() throws SAXException", "full": "private Location createLocation() throws SAXException {\n    if (latitude == null || longitude == null) {\n      return null;\n    }\n    double latitudeValue;\n    double longitudeValue;\n    try {\n      latitudeValue = Double.parseDouble(latitude);\n      longitudeValue = Double.parseDouble(longitude);\n    } catch (NumberFormatException e) {\n      throw new SAXException(createErrorMessage(String.format(\n          Locale.US, \"Unable to parse latitude longitude: %s %s\", latitude, longitude)), e);\n    }\n    Double altitudeValue = null;\n    if (altitude != null) {\n      try {\n        altitudeValue = Double.parseDouble(altitude);\n      } catch (NumberFormatException e) {\n        throw new SAXException(\n            createErrorMessage(String.format(Locale.US, \"Unable to parse altitude: %s\", altitude)),\n            e);\n      }\n    }\n    \n    long timeValue;\n    if (time == null) {\n      timeValue = trackData.importTime;\n    } else {\n      try {\n        timeValue = StringUtils.getTime(time);\n      } catch (IllegalArgumentException e) {\n        throw new SAXException(\n            createErrorMessage(String.format(Locale.US, \"Unable to parse time: %s\", time)), e);\n      }\n    }\n    return createLocation(latitudeValue, longitudeValue, altitudeValue, timeValue);\n  }"}, {"signature": "private Location createLocation(\n      double latitudeValue, double longitudeValue, Double altitudeValue, long timeValue)", "full": "private Location createLocation(\n      double latitudeValue, double longitudeValue, Double altitudeValue, long timeValue) {\n    Location location = new Location(LocationManager.GPS_PROVIDER);\n    location.setLatitude(latitudeValue);\n    location.setLongitude(longitudeValue);\n    if (altitudeValue != null) {\n      location.setAltitude(altitudeValue);      \n    } else {\n      location.removeAltitude();\n    }\n    location.setTime(timeValue);\n    location.removeAccuracy();\n    location.removeBearing();\n    location.removeSpeed();\n    return location;\n  }"}, {"signature": "private void insertLocation(Location location)", "full": "private void insertLocation(Location location) {\n    if (trackData.tripStatisticsUpdater == null) {\n      trackData.tripStatisticsUpdater = new TripStatisticsUpdater(\n          location.getTime() != -1L ? location.getTime() : trackData.importTime);\n    }\n    ActivityType activityType = CalorieUtils.getActivityType(context, category);\n    trackData.tripStatisticsUpdater.addLocation(\n        location, recordingDistanceInterval, true, activityType, weight);\n\n    trackData.bufferedLocations[trackData.numBufferedLocations] = location;\n    trackData.numBufferedLocations++;\n    trackData.numberOfLocations++;\n\n    if (trackData.numBufferedLocations >= MAX_BUFFERED_LOCATIONS) {\n      flushLocations(trackData);\n    }\n  }"}, {"signature": "private void flushLocations(TrackData data)", "full": "private void flushLocations(TrackData data) {\n    if (data.numBufferedLocations <= 0) {\n      return;\n    }\n    myTracksProviderUtils.bulkInsertTrackPoint(\n        data.bufferedLocations, data.numBufferedLocations, data.track.getId());\n    data.numBufferedLocations = 0;\n    if (data.track.getStartId() == -1L) {\n      data.track.setStartId(myTracksProviderUtils.getFirstTrackPointId(data.track.getId()));\n    }\n    data.track.setStopId(myTracksProviderUtils.getLastTrackPointId(data.track.getId()));\n  }"}, {"signature": "private void insertFirstWaypoint(Track track)", "full": "private void insertFirstWaypoint(Track track) {\n    String waypointName = context.getString(R.string.marker_split_name_format, 0);\n    String waypointCategory = \"\";\n    TripStatisticsUpdater updater = new TripStatisticsUpdater(\n        track.getTripStatistics().getStartTime());\n    TripStatistics tripStatistics = updater.getTripStatistics();\n    String waypointDescription = new DescriptionGeneratorImpl(context).generateWaypointDescription(\n        tripStatistics);\n    String icon = context.getString(R.string.marker_statistics_icon_url);\n    double length = 0.0;\n    long duration = 0L;\n    Location waypointLocation = new Location(\"\");\n    waypointLocation.setLatitude(100);\n    waypointLocation.setLongitude(180);\n    Waypoint waypoint = new Waypoint(waypointName, waypointDescription, waypointCategory, icon,\n        track.getId(), WaypointType.STATISTICS, length, duration, -1L, -1L, waypointLocation,\n        tripStatistics, \"\");\n    myTracksProviderUtils.insertWaypoint(waypoint);\n  }"}], "class_attributes": [{"type": "String", "name": "TAG"}, {"type": "int", "name": "MAX_BUFFERED_LOCATIONS"}, {"type": "Context", "name": "context"}, {"type": "long", "name": "importTrackId"}, {"type": "MyTracksProviderUtils", "name": "myTracksProviderUtils"}, {"type": "int", "name": "recordingDistanceInterval"}, {"type": "double", "name": "weight"}, {"type": "List", "name": "trackIds"}, {"type": "List", "name": "waypoints"}, {"type": "TrackData", "name": "trackData"}, {"type": "Locator", "name": "locator"}, {"type": "String", "name": "content"}, {"type": "String", "name": "name"}, {"type": "String", "name": "description"}, {"type": "String", "name": "category"}, {"type": "String", "name": "latitude"}, {"type": "String", "name": "longitude"}, {"type": "String", "name": "altitude"}, {"type": "String", "name": "time"}, {"type": "String", "name": "waypointType"}, {"type": "String", "name": "photoUrl"}]}
{"id": 4350479, "class_signatures": "public class SignatureRequest", "class_methods": [{"signature": "public SignatureRequest()", "full": "public SignatureRequest() {\n    }"}, {"signature": "public SignatureRequest(String signatureType, String objectKey)", "full": "public SignatureRequest(String signatureType, String objectKey) {\n        setSignatureType(signatureType);\n        this.objectKey = objectKey;\n    }"}, {"signature": "public String getBucketName()", "full": "public String getBucketName() {\n        return bucketName;\n    }"}, {"signature": "public void setBucketName(String bucketName)", "full": "public void setBucketName(String bucketName) {\n        this.bucketName = bucketName;\n    }"}, {"signature": "public String getObjectKey()", "full": "public String getObjectKey() {\n        return objectKey;\n    }"}, {"signature": "public void setObjectKey(String objectKey)", "full": "public void setObjectKey(String objectKey) {\n        this.objectKey = objectKey;\n    }"}, {"signature": "public Map getObjectMetadata()", "full": "public Map getObjectMetadata() {\n        return objectMetadata;\n    }"}, {"signature": "public void setObjectMetadata(Map objectMetadata)", "full": "public void setObjectMetadata(Map objectMetadata) {\n        this.objectMetadata.putAll(objectMetadata);\n    }"}, {"signature": "public void addObjectMetadata(String metadataName, String metadataValue)", "full": "public void addObjectMetadata(String metadataName, String metadataValue) {\n        this.objectMetadata.put(metadataName, metadataValue);\n    }"}, {"signature": "public String getSignatureType()", "full": "public String getSignatureType() {\n        return signatureType;\n    }"}, {"signature": "public void setSignatureType(String signatureType)", "full": "public void setSignatureType(String signatureType) {\n        if (!SIGNATURE_TYPE_GET.equals(signatureType)\n            && !SIGNATURE_TYPE_HEAD.equals(signatureType)\n            && !SIGNATURE_TYPE_PUT.equals(signatureType)\n            && !SIGNATURE_TYPE_DELETE.equals(signatureType)\n            && !SIGNATURE_TYPE_ACL_LOOKUP.equals(signatureType)\n            && !SIGNATURE_TYPE_ACL_UPDATE.equals(signatureType))\n        {\n            throw new IllegalArgumentException(\"Illegal signature type: \" + signatureType);\n        }\n        this.signatureType = signatureType;\n    }"}, {"signature": "public void signRequest(String signedUrl)", "full": "public void signRequest(String signedUrl) {\n        this.signedUrl = signedUrl;\n    }"}, {"signature": "public String getSignedUrl()", "full": "public String getSignedUrl() {\n        return this.signedUrl;\n    }"}, {"signature": "public void declineRequest(String reason)", "full": "public void declineRequest(String reason) {\n        this.declineReason = reason;\n    }"}, {"signature": "public String getDeclineReason()", "full": "public String getDeclineReason() {\n        return this.declineReason;\n    }"}, {"signature": "public boolean isSigned()", "full": "public boolean isSigned() {\n        return getSignedUrl() != null;\n    }"}, {"signature": "public S3Object buildObject() \n\n}", "full": "public S3Object buildObject() {\n        S3Object object = new S3Object(getObjectKey());\n        object.addAllMetadata(getObjectMetadata());\n        return object;\n    }\n\n}"}], "class_attributes": [{"type": "String", "name": "SIGNATURE_TYPE_GET"}, {"type": "String", "name": "SIGNATURE_TYPE_HEAD"}, {"type": "String", "name": "SIGNATURE_TYPE_PUT"}, {"type": "String", "name": "SIGNATURE_TYPE_DELETE"}, {"type": "String", "name": "SIGNATURE_TYPE_ACL_LOOKUP"}, {"type": "String", "name": "SIGNATURE_TYPE_ACL_UPDATE"}, {"type": "String", "name": "signatureType"}, {"type": "String", "name": "objectKey"}, {"type": "String", "name": "bucketName"}, {"type": "Map", "name": "objectMetadata"}, {"type": "String", "name": "signedUrl"}, {"type": "String", "name": "declineReason"}]}
{"id": 4413079, "class_signatures": "public interface Media", "class_methods": [{"signature": "public void removePTZConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"RemovePTZConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/RemovePTZConfiguration\")\n    @RequestWrapper(localName = \"RemovePTZConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemovePTZConfiguration\")\n    @ResponseWrapper(localName = \"RemovePTZConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemovePTZConfigurationResponse\")\n    public void removePTZConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void removeVideoSourceConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"RemoveVideoSourceConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/RemoveVideoSourceConfiguration\")\n    @RequestWrapper(localName = \"RemoveVideoSourceConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveVideoSourceConfiguration\")\n    @ResponseWrapper(localName = \"RemoveVideoSourceConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveVideoSourceConfigurationResponse\")\n    public void removeVideoSourceConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void stopMulticastStreaming(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"StopMulticastStreaming\", action = \"http://www.onvif.org/ver10/media/wsdl/StopMulticastStreaming\")\n    @RequestWrapper(localName = \"StopMulticastStreaming\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.StopMulticastStreaming\")\n    @ResponseWrapper(localName = \"StopMulticastStreamingResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.StopMulticastStreamingResponse\")\n    public void stopMulticastStreaming(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void setAudioOutputConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.AudioOutputConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );", "full": "@WebMethod(operationName = \"SetAudioOutputConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/SetAudioOutputConfiguration\")\n    @RequestWrapper(localName = \"SetAudioOutputConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetAudioOutputConfiguration\")\n    @ResponseWrapper(localName = \"SetAudioOutputConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetAudioOutputConfigurationResponse\")\n    public void setAudioOutputConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.AudioOutputConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );"}, {"signature": "public org.onvif.ver10.schema.MediaUri getSnapshotUri(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetSnapshotUri\", action = \"http://www.onvif.org/ver10/media/wsdl/GetSnapshotUri\")\n    @RequestWrapper(localName = \"GetSnapshotUri\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetSnapshotUri\")\n    @ResponseWrapper(localName = \"GetSnapshotUriResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetSnapshotUriResponse\")\n    @WebResult(name = \"MediaUri\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.MediaUri getSnapshotUri(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void addVideoAnalyticsConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"AddVideoAnalyticsConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/AddVideoAnalyticsConfiguration\")\n    @RequestWrapper(localName = \"AddVideoAnalyticsConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddVideoAnalyticsConfiguration\")\n    @ResponseWrapper(localName = \"AddVideoAnalyticsConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddVideoAnalyticsConfigurationResponse\")\n    public void addVideoAnalyticsConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public void startMulticastStreaming(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"StartMulticastStreaming\", action = \"http://www.onvif.org/ver10/media/wsdl/StartMulticastStreaming\")\n    @RequestWrapper(localName = \"StartMulticastStreaming\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.StartMulticastStreaming\")\n    @ResponseWrapper(localName = \"StartMulticastStreamingResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.StartMulticastStreamingResponse\")\n    public void startMulticastStreaming(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void removeVideoEncoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"RemoveVideoEncoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/RemoveVideoEncoderConfiguration\")\n    @RequestWrapper(localName = \"RemoveVideoEncoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveVideoEncoderConfiguration\")\n    @ResponseWrapper(localName = \"RemoveVideoEncoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveVideoEncoderConfigurationResponse\")\n    public void removeVideoEncoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public org.onvif.ver10.schema.MediaUri getStreamUri(\n\n        @WebParam(name = \"StreamSetup\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.StreamSetup streamSetup,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetStreamUri\", action = \"http://www.onvif.org/ver10/media/wsdl/GetStreamUri\")\n    @RequestWrapper(localName = \"GetStreamUri\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetStreamUri\")\n    @ResponseWrapper(localName = \"GetStreamUriResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetStreamUriResponse\")\n    @WebResult(name = \"MediaUri\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.MediaUri getStreamUri(\n\n        @WebParam(name = \"StreamSetup\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.StreamSetup streamSetup,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public org.onvif.ver10.schema.Profile createProfile(\n\n        @WebParam(name = \"Name\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String name,\n        @WebParam(name = \"Token\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String token\n    );", "full": "@WebMethod(operationName = \"CreateProfile\", action = \"http://www.onvif.org/ver10/media/wsdl/CreateProfile\")\n    @RequestWrapper(localName = \"CreateProfile\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.CreateProfile\")\n    @ResponseWrapper(localName = \"CreateProfileResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.CreateProfileResponse\")\n    @WebResult(name = \"Profile\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.Profile createProfile(\n\n        @WebParam(name = \"Name\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String name,\n        @WebParam(name = \"Token\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String token\n    );"}, {"signature": "public void addVideoSourceConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"AddVideoSourceConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/AddVideoSourceConfiguration\")\n    @RequestWrapper(localName = \"AddVideoSourceConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddVideoSourceConfiguration\")\n    @ResponseWrapper(localName = \"AddVideoSourceConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddVideoSourceConfigurationResponse\")\n    public void addVideoSourceConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public org.onvif.ver10.schema.VideoEncoderConfiguration getVideoEncoderConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"GetVideoEncoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/GetVideoEncoderConfiguration\")\n    @RequestWrapper(localName = \"GetVideoEncoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoEncoderConfiguration\")\n    @ResponseWrapper(localName = \"GetVideoEncoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoEncoderConfigurationResponse\")\n    @WebResult(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.VideoEncoderConfiguration getVideoEncoderConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public org.onvif.ver10.media.wsdl.Capabilities getServiceCapabilities()\n;", "full": "@WebMethod(operationName = \"GetServiceCapabilities\", action = \"http://www.onvif.org/ver10/media/wsdl/GetServiceCapabilities\")\n    @RequestWrapper(localName = \"GetServiceCapabilities\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetServiceCapabilities\")\n    @ResponseWrapper(localName = \"GetServiceCapabilitiesResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetServiceCapabilitiesResponse\")\n    @WebResult(name = \"Capabilities\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.media.wsdl.Capabilities getServiceCapabilities()\n;"}, {"signature": "public org.onvif.ver10.schema.VideoEncoderConfigurationOptions getVideoEncoderConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetVideoEncoderConfigurationOptions\", action = \"http://www.onvif.org/ver10/media/wsdl/GetVideoEncoderConfigurationOptions\")\n    @RequestWrapper(localName = \"GetVideoEncoderConfigurationOptions\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoEncoderConfigurationOptions\")\n    @ResponseWrapper(localName = \"GetVideoEncoderConfigurationOptionsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoEncoderConfigurationOptionsResponse\")\n    @WebResult(name = \"Options\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.VideoEncoderConfigurationOptions getVideoEncoderConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public CreateOSDResponse createOSD(\n\n        @WebParam(partName = \"parameters\", name = \"CreateOSD\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        CreateOSD parameters\n    );", "full": "@WebMethod(operationName = \"CreateOSD\", action = \"http://www.onvif.org/ver10/media/wsdl/CreateOSD\")\n    @SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)\n    @WebResult(name = \"CreateOSDResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", partName = \"parameters\")\n    public CreateOSDResponse createOSD(\n\n        @WebParam(partName = \"parameters\", name = \"CreateOSD\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        CreateOSD parameters\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.VideoSourceConfiguration> getVideoSourceConfigurations()\n;", "full": "@WebMethod(operationName = \"GetVideoSourceConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetVideoSourceConfigurations\")\n    @RequestWrapper(localName = \"GetVideoSourceConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSourceConfigurations\")\n    @ResponseWrapper(localName = \"GetVideoSourceConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSourceConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.VideoSourceConfiguration> getVideoSourceConfigurations()\n;"}, {"signature": "public java.util.List<org.onvif.ver10.schema.OSDConfiguration> getOSDs(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"GetOSDs\", action = \"http://www.onvif.org/ver10/media/wsdl/GetOSDs\")\n    @RequestWrapper(localName = \"GetOSDs\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetOSDs\")\n    @ResponseWrapper(localName = \"GetOSDsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetOSDsResponse\")\n    @WebResult(name = \"OSDs\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.OSDConfiguration> getOSDs(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public void removeAudioEncoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"RemoveAudioEncoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/RemoveAudioEncoderConfiguration\")\n    @RequestWrapper(localName = \"RemoveAudioEncoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveAudioEncoderConfiguration\")\n    @ResponseWrapper(localName = \"RemoveAudioEncoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveAudioEncoderConfigurationResponse\")\n    public void removeAudioEncoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioEncoderConfiguration> getCompatibleAudioEncoderConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetCompatibleAudioEncoderConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetCompatibleAudioEncoderConfigurations\")\n    @RequestWrapper(localName = \"GetCompatibleAudioEncoderConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleAudioEncoderConfigurations\")\n    @ResponseWrapper(localName = \"GetCompatibleAudioEncoderConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleAudioEncoderConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioEncoderConfiguration> getCompatibleAudioEncoderConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public org.onvif.ver10.schema.AudioEncoderConfiguration getAudioEncoderConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"GetAudioEncoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioEncoderConfiguration\")\n    @RequestWrapper(localName = \"GetAudioEncoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioEncoderConfiguration\")\n    @ResponseWrapper(localName = \"GetAudioEncoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioEncoderConfigurationResponse\")\n    @WebResult(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.AudioEncoderConfiguration getAudioEncoderConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public org.onvif.ver10.schema.AudioOutputConfiguration getAudioOutputConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"GetAudioOutputConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioOutputConfiguration\")\n    @RequestWrapper(localName = \"GetAudioOutputConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioOutputConfiguration\")\n    @ResponseWrapper(localName = \"GetAudioOutputConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioOutputConfigurationResponse\")\n    @WebResult(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.AudioOutputConfiguration getAudioOutputConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public void setSynchronizationPoint(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"SetSynchronizationPoint\", action = \"http://www.onvif.org/ver10/media/wsdl/SetSynchronizationPoint\")\n    @RequestWrapper(localName = \"SetSynchronizationPoint\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetSynchronizationPoint\")\n    @ResponseWrapper(localName = \"SetSynchronizationPointResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetSynchronizationPointResponse\")\n    public void setSynchronizationPoint(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void addAudioSourceConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"AddAudioSourceConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/AddAudioSourceConfiguration\")\n    @RequestWrapper(localName = \"AddAudioSourceConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddAudioSourceConfiguration\")\n    @ResponseWrapper(localName = \"AddAudioSourceConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddAudioSourceConfigurationResponse\")\n    public void addAudioSourceConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public void addAudioOutputConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"AddAudioOutputConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/AddAudioOutputConfiguration\")\n    @RequestWrapper(localName = \"AddAudioOutputConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddAudioOutputConfiguration\")\n    @ResponseWrapper(localName = \"AddAudioOutputConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddAudioOutputConfigurationResponse\")\n    public void addAudioOutputConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.MetadataConfiguration> getCompatibleMetadataConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetCompatibleMetadataConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetCompatibleMetadataConfigurations\")\n    @RequestWrapper(localName = \"GetCompatibleMetadataConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleMetadataConfigurations\")\n    @ResponseWrapper(localName = \"GetCompatibleMetadataConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleMetadataConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.MetadataConfiguration> getCompatibleMetadataConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public org.onvif.ver10.schema.MetadataConfigurationOptions getMetadataConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetMetadataConfigurationOptions\", action = \"http://www.onvif.org/ver10/media/wsdl/GetMetadataConfigurationOptions\")\n    @RequestWrapper(localName = \"GetMetadataConfigurationOptions\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetMetadataConfigurationOptions\")\n    @ResponseWrapper(localName = \"GetMetadataConfigurationOptionsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetMetadataConfigurationOptionsResponse\")\n    @WebResult(name = \"Options\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.MetadataConfigurationOptions getMetadataConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void setAudioDecoderConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.AudioDecoderConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );", "full": "@WebMethod(operationName = \"SetAudioDecoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/SetAudioDecoderConfiguration\")\n    @RequestWrapper(localName = \"SetAudioDecoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetAudioDecoderConfiguration\")\n    @ResponseWrapper(localName = \"SetAudioDecoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetAudioDecoderConfigurationResponse\")\n    public void setAudioDecoderConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.AudioDecoderConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );"}, {"signature": "public org.onvif.ver10.schema.AudioOutputConfigurationOptions getAudioOutputConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetAudioOutputConfigurationOptions\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioOutputConfigurationOptions\")\n    @RequestWrapper(localName = \"GetAudioOutputConfigurationOptions\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioOutputConfigurationOptions\")\n    @ResponseWrapper(localName = \"GetAudioOutputConfigurationOptionsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioOutputConfigurationOptionsResponse\")\n    @WebResult(name = \"Options\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.AudioOutputConfigurationOptions getAudioOutputConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void setVideoSourceConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.VideoSourceConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );", "full": "@WebMethod(operationName = \"SetVideoSourceConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/SetVideoSourceConfiguration\")\n    @RequestWrapper(localName = \"SetVideoSourceConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetVideoSourceConfiguration\")\n    @ResponseWrapper(localName = \"SetVideoSourceConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetVideoSourceConfigurationResponse\")\n    public void setVideoSourceConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.VideoSourceConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioOutputConfiguration> getCompatibleAudioOutputConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetCompatibleAudioOutputConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetCompatibleAudioOutputConfigurations\")\n    @RequestWrapper(localName = \"GetCompatibleAudioOutputConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleAudioOutputConfigurations\")\n    @ResponseWrapper(localName = \"GetCompatibleAudioOutputConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleAudioOutputConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioOutputConfiguration> getCompatibleAudioOutputConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.VideoEncoderConfiguration> getVideoEncoderConfigurations()\n;", "full": "@WebMethod(operationName = \"GetVideoEncoderConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetVideoEncoderConfigurations\")\n    @RequestWrapper(localName = \"GetVideoEncoderConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoEncoderConfigurations\")\n    @ResponseWrapper(localName = \"GetVideoEncoderConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoEncoderConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.VideoEncoderConfiguration> getVideoEncoderConfigurations()\n;"}, {"signature": "public void setVideoAnalyticsConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.VideoAnalyticsConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );", "full": "@WebMethod(operationName = \"SetVideoAnalyticsConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/SetVideoAnalyticsConfiguration\")\n    @RequestWrapper(localName = \"SetVideoAnalyticsConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetVideoAnalyticsConfiguration\")\n    @ResponseWrapper(localName = \"SetVideoAnalyticsConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetVideoAnalyticsConfigurationResponse\")\n    public void setVideoAnalyticsConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.VideoAnalyticsConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );"}, {"signature": "public org.onvif.ver10.schema.AudioEncoderConfigurationOptions getAudioEncoderConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetAudioEncoderConfigurationOptions\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioEncoderConfigurationOptions\")\n    @RequestWrapper(localName = \"GetAudioEncoderConfigurationOptions\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioEncoderConfigurationOptions\")\n    @ResponseWrapper(localName = \"GetAudioEncoderConfigurationOptionsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioEncoderConfigurationOptionsResponse\")\n    @WebResult(name = \"Options\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.AudioEncoderConfigurationOptions getAudioEncoderConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.Profile> getProfiles()\n;", "full": "@WebMethod(operationName = \"GetProfiles\", action = \"http://www.onvif.org/ver10/media/wsdl/GetProfiles\")\n    @RequestWrapper(localName = \"GetProfiles\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetProfiles\")\n    @ResponseWrapper(localName = \"GetProfilesResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetProfilesResponse\")\n    @WebResult(name = \"Profiles\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.Profile> getProfiles()\n;"}, {"signature": "public void addMetadataConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"AddMetadataConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/AddMetadataConfiguration\")\n    @RequestWrapper(localName = \"AddMetadataConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddMetadataConfiguration\")\n    @ResponseWrapper(localName = \"AddMetadataConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddMetadataConfigurationResponse\")\n    public void addMetadataConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public void setAudioEncoderConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.AudioEncoderConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );", "full": "@WebMethod(operationName = \"SetAudioEncoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/SetAudioEncoderConfiguration\")\n    @RequestWrapper(localName = \"SetAudioEncoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetAudioEncoderConfiguration\")\n    @ResponseWrapper(localName = \"SetAudioEncoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetAudioEncoderConfigurationResponse\")\n    public void setAudioEncoderConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.AudioEncoderConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );"}, {"signature": "public org.onvif.ver10.schema.VideoSourceConfigurationOptions getVideoSourceConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetVideoSourceConfigurationOptions\", action = \"http://www.onvif.org/ver10/media/wsdlGetVideoSourceConfigurationOptions/\")\n    @RequestWrapper(localName = \"GetVideoSourceConfigurationOptions\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSourceConfigurationOptions\")\n    @ResponseWrapper(localName = \"GetVideoSourceConfigurationOptionsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSourceConfigurationOptionsResponse\")\n    @WebResult(name = \"Options\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.VideoSourceConfigurationOptions getVideoSourceConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void getGuaranteedNumberOfVideoEncoderInstances(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(mode = WebParam.Mode.OUT, name = \"TotalNumber\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        javax.xml.ws.Holder<java.lang.Integer> totalNumber,\n        @WebParam(mode = WebParam.Mode.OUT, name = \"JPEG\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        javax.xml.ws.Holder<java.lang.Integer> jpeg,\n        @WebParam(mode = WebParam.Mode.OUT, name = \"H264\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        javax.xml.ws.Holder<java.lang.Integer> h264,\n        @WebParam(mode = WebParam.Mode.OUT, name = \"MPEG4\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        javax.xml.ws.Holder<java.lang.Integer> mpeg4\n    );", "full": "@WebMethod(operationName = \"GetGuaranteedNumberOfVideoEncoderInstances\", action = \"http://www.onvif.org/ver10/media/wsdl/GetGuaranteedNumberOfVideoEncoderInstances\")\n    @RequestWrapper(localName = \"GetGuaranteedNumberOfVideoEncoderInstances\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetGuaranteedNumberOfVideoEncoderInstances\")\n    @ResponseWrapper(localName = \"GetGuaranteedNumberOfVideoEncoderInstancesResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetGuaranteedNumberOfVideoEncoderInstancesResponse\")\n    public void getGuaranteedNumberOfVideoEncoderInstances(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(mode = WebParam.Mode.OUT, name = \"TotalNumber\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        javax.xml.ws.Holder<java.lang.Integer> totalNumber,\n        @WebParam(mode = WebParam.Mode.OUT, name = \"JPEG\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        javax.xml.ws.Holder<java.lang.Integer> jpeg,\n        @WebParam(mode = WebParam.Mode.OUT, name = \"H264\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        javax.xml.ws.Holder<java.lang.Integer> h264,\n        @WebParam(mode = WebParam.Mode.OUT, name = \"MPEG4\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        javax.xml.ws.Holder<java.lang.Integer> mpeg4\n    );"}, {"signature": "public org.onvif.ver10.schema.Profile getProfile(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetProfile\", action = \"http://www.onvif.org/ver10/media/wsdlGetProfile/\")\n    @RequestWrapper(localName = \"GetProfile\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetProfile\")\n    @ResponseWrapper(localName = \"GetProfileResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetProfileResponse\")\n    @WebResult(name = \"Profile\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.Profile getProfile(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public org.onvif.ver10.schema.VideoAnalyticsConfiguration getVideoAnalyticsConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"GetVideoAnalyticsConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/GetVideoAnalyticsConfiguration\")\n    @RequestWrapper(localName = \"GetVideoAnalyticsConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoAnalyticsConfiguration\")\n    @ResponseWrapper(localName = \"GetVideoAnalyticsConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoAnalyticsConfigurationResponse\")\n    @WebResult(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.VideoAnalyticsConfiguration getVideoAnalyticsConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioOutputConfiguration> getAudioOutputConfigurations()\n;", "full": "@WebMethod(operationName = \"GetAudioOutputConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioOutputConfigurations\")\n    @RequestWrapper(localName = \"GetAudioOutputConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioOutputConfigurations\")\n    @ResponseWrapper(localName = \"GetAudioOutputConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioOutputConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioOutputConfiguration> getAudioOutputConfigurations()\n;"}, {"signature": "public SetOSDResponse setOSD(\n\n        @WebParam(partName = \"parameters\", name = \"SetOSD\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        SetOSD parameters\n    );", "full": "@WebMethod(operationName = \"SetOSD\", action = \"http://www.onvif.org/ver10/media/wsdl/SetOSD\")\n    @SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)\n    @WebResult(name = \"SetOSDResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", partName = \"parameters\")\n    public SetOSDResponse setOSD(\n\n        @WebParam(partName = \"parameters\", name = \"SetOSD\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        SetOSD parameters\n    );"}, {"signature": "public void addPTZConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"AddPTZConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/AddPTZConfiguration\")\n    @RequestWrapper(localName = \"AddPTZConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddPTZConfiguration\")\n    @ResponseWrapper(localName = \"AddPTZConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddPTZConfigurationResponse\")\n    public void addPTZConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioOutput> getAudioOutputs()\n;", "full": "@WebMethod(operationName = \"GetAudioOutputs\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioOutputs\")\n    @RequestWrapper(localName = \"GetAudioOutputs\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioOutputs\")\n    @ResponseWrapper(localName = \"GetAudioOutputsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioOutputsResponse\")\n    @WebResult(name = \"AudioOutputs\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioOutput> getAudioOutputs()\n;"}, {"signature": "public java.util.List<org.onvif.ver10.schema.VideoAnalyticsConfiguration> getCompatibleVideoAnalyticsConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetCompatibleVideoAnalyticsConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetCompatibleVideoAnalyticsConfigurations\")\n    @RequestWrapper(localName = \"GetCompatibleVideoAnalyticsConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleVideoAnalyticsConfigurations\")\n    @ResponseWrapper(localName = \"GetCompatibleVideoAnalyticsConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleVideoAnalyticsConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.VideoAnalyticsConfiguration> getCompatibleVideoAnalyticsConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.VideoAnalyticsConfiguration> getVideoAnalyticsConfigurations()\n;", "full": "@WebMethod(operationName = \"GetVideoAnalyticsConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetVideoAnalyticsConfigurations\")\n    @RequestWrapper(localName = \"GetVideoAnalyticsConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoAnalyticsConfigurations\")\n    @ResponseWrapper(localName = \"GetVideoAnalyticsConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoAnalyticsConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.VideoAnalyticsConfiguration> getVideoAnalyticsConfigurations()\n;"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioSourceConfiguration> getCompatibleAudioSourceConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetCompatibleAudioSourceConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetCompatibleAudioSourceConfigurations\")\n    @RequestWrapper(localName = \"GetCompatibleAudioSourceConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleAudioSourceConfigurations\")\n    @ResponseWrapper(localName = \"GetCompatibleAudioSourceConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleAudioSourceConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioSourceConfiguration> getCompatibleAudioSourceConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.media.wsdl.VideoSourceMode> getVideoSourceModes(\n\n        @WebParam(name = \"VideoSourceToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String videoSourceToken\n    );", "full": "@WebMethod(operationName = \"GetVideoSourceModes\", action = \"http://www.onvif.org/ver10/media/wsdl/GetVideoSourceModes\")\n    @RequestWrapper(localName = \"GetVideoSourceModes\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSourceModes\")\n    @ResponseWrapper(localName = \"GetVideoSourceModesResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSourceModesResponse\")\n    @WebResult(name = \"VideoSourceModes\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.media.wsdl.VideoSourceMode> getVideoSourceModes(\n\n        @WebParam(name = \"VideoSourceToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String videoSourceToken\n    );"}, {"signature": "public org.onvif.ver10.schema.AudioSourceConfigurationOptions getAudioSourceConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetAudioSourceConfigurationOptions\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioSourceConfigurationOptions\")\n    @RequestWrapper(localName = \"GetAudioSourceConfigurationOptions\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioSourceConfigurationOptions\")\n    @ResponseWrapper(localName = \"GetAudioSourceConfigurationOptionsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioSourceConfigurationOptionsResponse\")\n    @WebResult(name = \"Options\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.AudioSourceConfigurationOptions getAudioSourceConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioSource> getAudioSources()\n;", "full": "@WebMethod(operationName = \"GetAudioSources\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioSources\")\n    @RequestWrapper(localName = \"GetAudioSources\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioSources\")\n    @ResponseWrapper(localName = \"GetAudioSourcesResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioSourcesResponse\")\n    @WebResult(name = \"AudioSources\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioSource> getAudioSources()\n;"}, {"signature": "public java.util.List<org.onvif.ver10.schema.VideoSource> getVideoSources()\n;", "full": "@WebMethod(operationName = \"GetVideoSources\", action = \"http://www.onvif.org/ver10/media/wsdlGetVideoSources/\")\n    @RequestWrapper(localName = \"GetVideoSources\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSources\")\n    @ResponseWrapper(localName = \"GetVideoSourcesResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSourcesResponse\")\n    @WebResult(name = \"VideoSources\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.VideoSource> getVideoSources()\n;"}, {"signature": "public org.onvif.ver10.schema.AudioDecoderConfiguration getAudioDecoderConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"GetAudioDecoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioDecoderConfiguration\")\n    @RequestWrapper(localName = \"GetAudioDecoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioDecoderConfiguration\")\n    @ResponseWrapper(localName = \"GetAudioDecoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioDecoderConfigurationResponse\")\n    @WebResult(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.AudioDecoderConfiguration getAudioDecoderConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public org.onvif.ver10.schema.AudioSourceConfiguration getAudioSourceConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"GetAudioSourceConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioSourceConfiguration\")\n    @RequestWrapper(localName = \"GetAudioSourceConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioSourceConfiguration\")\n    @ResponseWrapper(localName = \"GetAudioSourceConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioSourceConfigurationResponse\")\n    @WebResult(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.AudioSourceConfiguration getAudioSourceConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.VideoSourceConfiguration> getCompatibleVideoSourceConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetCompatibleVideoSourceConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetCompatibleVideoSourceConfigurations\")\n    @RequestWrapper(localName = \"GetCompatibleVideoSourceConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleVideoSourceConfigurations\")\n    @ResponseWrapper(localName = \"GetCompatibleVideoSourceConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleVideoSourceConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.VideoSourceConfiguration> getCompatibleVideoSourceConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioDecoderConfiguration> getCompatibleAudioDecoderConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetCompatibleAudioDecoderConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetCompatibleAudioDecoderConfigurations\")\n    @RequestWrapper(localName = \"GetCompatibleAudioDecoderConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleAudioDecoderConfigurations\")\n    @ResponseWrapper(localName = \"GetCompatibleAudioDecoderConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleAudioDecoderConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioDecoderConfiguration> getCompatibleAudioDecoderConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void addVideoEncoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"AddVideoEncoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/AddVideoEncoderConfiguration\")\n    @RequestWrapper(localName = \"AddVideoEncoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddVideoEncoderConfiguration\")\n    @ResponseWrapper(localName = \"AddVideoEncoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddVideoEncoderConfigurationResponse\")\n    public void addVideoEncoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.MetadataConfiguration> getMetadataConfigurations()\n;", "full": "@WebMethod(operationName = \"GetMetadataConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetMetadataConfigurations\")\n    @RequestWrapper(localName = \"GetMetadataConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetMetadataConfigurations\")\n    @ResponseWrapper(localName = \"GetMetadataConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetMetadataConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.MetadataConfiguration> getMetadataConfigurations()\n;"}, {"signature": "public void setAudioSourceConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.AudioSourceConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );", "full": "@WebMethod(operationName = \"SetAudioSourceConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/SetAudioSourceConfiguration\")\n    @RequestWrapper(localName = \"SetAudioSourceConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetAudioSourceConfiguration\")\n    @ResponseWrapper(localName = \"SetAudioSourceConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetAudioSourceConfigurationResponse\")\n    public void setAudioSourceConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.AudioSourceConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );"}, {"signature": "public DeleteOSDResponse deleteOSD(\n\n        @WebParam(partName = \"parameters\", name = \"DeleteOSD\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        DeleteOSD parameters\n    );", "full": "@WebMethod(operationName = \"DeleteOSD\", action = \"http://www.onvif.org/ver10/media/wsdl/DeleteOSD\")\n    @SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)\n    @WebResult(name = \"DeleteOSDResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", partName = \"parameters\")\n    public DeleteOSDResponse deleteOSD(\n\n        @WebParam(partName = \"parameters\", name = \"DeleteOSD\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        DeleteOSD parameters\n    );"}, {"signature": "public void removeAudioDecoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"RemoveAudioDecoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/RemoveAudioDecoderConfiguration\")\n    @RequestWrapper(localName = \"RemoveAudioDecoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveAudioDecoderConfiguration\")\n    @ResponseWrapper(localName = \"RemoveAudioDecoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveAudioDecoderConfigurationResponse\")\n    public void removeAudioDecoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void deleteProfile(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"DeleteProfile\", action = \"http://www.onvif.org/ver10/media/wsdl/DeleteProfile\")\n    @RequestWrapper(localName = \"DeleteProfile\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.DeleteProfile\")\n    @ResponseWrapper(localName = \"DeleteProfileResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.DeleteProfileResponse\")\n    public void deleteProfile(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.VideoEncoderConfiguration> getCompatibleVideoEncoderConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetCompatibleVideoEncoderConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetCompatibleVideoEncoderConfigurations\")\n    @RequestWrapper(localName = \"GetCompatibleVideoEncoderConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleVideoEncoderConfigurations\")\n    @ResponseWrapper(localName = \"GetCompatibleVideoEncoderConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleVideoEncoderConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.VideoEncoderConfiguration> getCompatibleVideoEncoderConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public org.onvif.ver10.schema.MetadataConfiguration getMetadataConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"GetMetadataConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/GetMetadataConfiguration\")\n    @RequestWrapper(localName = \"GetMetadataConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetMetadataConfiguration\")\n    @ResponseWrapper(localName = \"GetMetadataConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetMetadataConfigurationResponse\")\n    @WebResult(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.MetadataConfiguration getMetadataConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public void setVideoEncoderConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.VideoEncoderConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );", "full": "@WebMethod(operationName = \"SetVideoEncoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/SetVideoEncoderConfiguration\")\n    @RequestWrapper(localName = \"SetVideoEncoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetVideoEncoderConfiguration\")\n    @ResponseWrapper(localName = \"SetVideoEncoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetVideoEncoderConfigurationResponse\")\n    public void setVideoEncoderConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.VideoEncoderConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );"}, {"signature": "public org.onvif.ver10.schema.AudioDecoderConfigurationOptions getAudioDecoderConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"GetAudioDecoderConfigurationOptions\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioDecoderConfigurationOptions\")\n    @RequestWrapper(localName = \"GetAudioDecoderConfigurationOptions\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioDecoderConfigurationOptions\")\n    @ResponseWrapper(localName = \"GetAudioDecoderConfigurationOptionsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioDecoderConfigurationOptionsResponse\")\n    @WebResult(name = \"Options\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.AudioDecoderConfigurationOptions getAudioDecoderConfigurationOptions(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken,\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public GetOSDOptionsResponse getOSDOptions(\n\n        @WebParam(partName = \"parameters\", name = \"GetOSDOptions\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        GetOSDOptions parameters\n    );", "full": "@WebMethod(operationName = \"GetOSDOptions\", action = \"http://www.onvif.org/ver10/media/wsdl/GetOSDOptions\")\n    @SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)\n    @WebResult(name = \"GetOSDOptionsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", partName = \"parameters\")\n    public GetOSDOptionsResponse getOSDOptions(\n\n        @WebParam(partName = \"parameters\", name = \"GetOSDOptions\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        GetOSDOptions parameters\n    );"}, {"signature": "public void addAudioEncoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"AddAudioEncoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/AddAudioEncoderConfiguration\")\n    @RequestWrapper(localName = \"AddAudioEncoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddAudioEncoderConfiguration\")\n    @ResponseWrapper(localName = \"AddAudioEncoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddAudioEncoderConfigurationResponse\")\n    public void addAudioEncoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public void addAudioDecoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"AddAudioDecoderConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/AddAudioDecoderConfiguration\")\n    @RequestWrapper(localName = \"AddAudioDecoderConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddAudioDecoderConfiguration\")\n    @ResponseWrapper(localName = \"AddAudioDecoderConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.AddAudioDecoderConfigurationResponse\")\n    public void addAudioDecoderConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken,\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public void removeVideoAnalyticsConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"RemoveVideoAnalyticsConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/RemoveVideoAnalyticsConfiguration\")\n    @RequestWrapper(localName = \"RemoveVideoAnalyticsConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveVideoAnalyticsConfiguration\")\n    @ResponseWrapper(localName = \"RemoveVideoAnalyticsConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveVideoAnalyticsConfigurationResponse\")\n    public void removeVideoAnalyticsConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void removeMetadataConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"RemoveMetadataConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/RemoveMetadataConfiguration\")\n    @RequestWrapper(localName = \"RemoveMetadataConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveMetadataConfiguration\")\n    @ResponseWrapper(localName = \"RemoveMetadataConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveMetadataConfigurationResponse\")\n    public void removeMetadataConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public void removeAudioOutputConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"RemoveAudioOutputConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/RemoveAudioOutputConfiguration\")\n    @RequestWrapper(localName = \"RemoveAudioOutputConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveAudioOutputConfiguration\")\n    @ResponseWrapper(localName = \"RemoveAudioOutputConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveAudioOutputConfigurationResponse\")\n    public void removeAudioOutputConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioEncoderConfiguration> getAudioEncoderConfigurations()\n;", "full": "@WebMethod(operationName = \"GetAudioEncoderConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioEncoderConfigurations\")\n    @RequestWrapper(localName = \"GetAudioEncoderConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioEncoderConfigurations\")\n    @ResponseWrapper(localName = \"GetAudioEncoderConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioEncoderConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioEncoderConfiguration> getAudioEncoderConfigurations()\n;"}, {"signature": "public void setMetadataConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.MetadataConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );", "full": "@WebMethod(operationName = \"SetMetadataConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/SetMetadataConfiguration\")\n    @RequestWrapper(localName = \"SetMetadataConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetMetadataConfiguration\")\n    @ResponseWrapper(localName = \"SetMetadataConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetMetadataConfigurationResponse\")\n    public void setMetadataConfiguration(\n\n        @WebParam(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        org.onvif.ver10.schema.MetadataConfiguration configuration,\n        @WebParam(name = \"ForcePersistence\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        boolean forcePersistence\n    );"}, {"signature": "public org.onvif.ver10.schema.VideoSourceConfiguration getVideoSourceConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );", "full": "@WebMethod(operationName = \"GetVideoSourceConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/GetVideoSourceConfiguration\")\n    @RequestWrapper(localName = \"GetVideoSourceConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSourceConfiguration\")\n    @ResponseWrapper(localName = \"GetVideoSourceConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetVideoSourceConfigurationResponse\")\n    @WebResult(name = \"Configuration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public org.onvif.ver10.schema.VideoSourceConfiguration getVideoSourceConfiguration(\n\n        @WebParam(name = \"ConfigurationToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String configurationToken\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioDecoderConfiguration> getAudioDecoderConfigurations()\n;", "full": "@WebMethod(operationName = \"GetAudioDecoderConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetAudioDecoderConfigurations\")\n    @RequestWrapper(localName = \"GetAudioDecoderConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioDecoderConfigurations\")\n    @ResponseWrapper(localName = \"GetAudioDecoderConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioDecoderConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioDecoderConfiguration> getAudioDecoderConfigurations()\n;"}, {"signature": "public void removeAudioSourceConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "full": "@WebMethod(operationName = \"RemoveAudioSourceConfiguration\", action = \"http://www.onvif.org/ver10/media/wsdl/RemoveAudioSourceConfiguration\")\n    @RequestWrapper(localName = \"RemoveAudioSourceConfiguration\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveAudioSourceConfiguration\")\n    @ResponseWrapper(localName = \"RemoveAudioSourceConfigurationResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.RemoveAudioSourceConfigurationResponse\")\n    public void removeAudioSourceConfiguration(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}, {"signature": "public GetOSDResponse getOSD(\n\n        @WebParam(partName = \"parameters\", name = \"GetOSD\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        GetOSD parameters\n    );", "full": "@WebMethod(operationName = \"GetOSD\", action = \"http://www.onvif.org/ver10/media/wsdl/GetOSD\")\n    @SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)\n    @WebResult(name = \"GetOSDResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", partName = \"parameters\")\n    public GetOSDResponse getOSD(\n\n        @WebParam(partName = \"parameters\", name = \"GetOSD\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        GetOSD parameters\n    );"}, {"signature": "public java.util.List<org.onvif.ver10.schema.AudioSourceConfiguration> getAudioSourceConfigurations()\n;", "full": "@WebMethod(operationName = \"GetAudioSourceConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdlGetAudioSourceConfigurations/\")\n    @RequestWrapper(localName = \"GetAudioSourceConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioSourceConfigurations\")\n    @ResponseWrapper(localName = \"GetAudioSourceConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetAudioSourceConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.AudioSourceConfiguration> getAudioSourceConfigurations()\n;"}, {"signature": "public boolean setVideoSourceMode(\n\n        @WebParam(name = \"VideoSourceToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String videoSourceToken,\n        @WebParam(name = \"VideoSourceModeToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String videoSourceModeToken\n    );\n}", "full": "@WebMethod(operationName = \"SetVideoSourceMode\", action = \"http://www.onvif.org/ver10/media/wsdl/SetVideoSourceMode\")\n    @RequestWrapper(localName = \"SetVideoSourceMode\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetVideoSourceMode\")\n    @ResponseWrapper(localName = \"SetVideoSourceModeResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.SetVideoSourceModeResponse\")\n    @WebResult(name = \"Reboot\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public boolean setVideoSourceMode(\n\n        @WebParam(name = \"VideoSourceToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String videoSourceToken,\n        @WebParam(name = \"VideoSourceModeToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String videoSourceModeToken\n    );\n}"}], "class_attributes": []}
{"id": 4497632, "class_signatures": "public class HttpSessionStore implements SAMLMessageStore", "class_methods": [{"signature": "public HttpSessionStore(final WebContext context, final SessionStore sessionStore)", "full": "public HttpSessionStore(final WebContext context, final SessionStore sessionStore) {\n        CommonHelper.assertNotNull(\"context\", context);\n        CommonHelper.assertNotNull(\"sessionStore\", sessionStore);\n        this.context = context;\n        this.sessionStore = sessionStore;\n    }"}, {"signature": "public void set(final String messageID, final XMLObject message)", "full": "@Override\n    public void set(final String messageID, final XMLObject message) {\n        log.debug(\"Storing message {} to session {}\", messageID, sessionStore.getSessionId(context, true).get());\n        final var messages = getMessages();\n        messages.put(messageID, Configuration.serializeSamlObject(message).toString());\n        updateSession(messages);\n    }"}, {"signature": "public Optional<XMLObject> get(final String messageID)", "full": "@Override\n    public Optional<XMLObject> get(final String messageID) {\n        final var messages = getMessages();\n        final var o = messages.get(messageID);\n        if (o == null) {\n            log.debug(\"Message {} not found in session {}\", messageID, sessionStore.getSessionId(context, true).get());\n            return Optional.empty();\n        }\n\n        log.debug(\"Message {} found in session {}, clearing\", messageID, sessionStore.getSessionId(context, true).get());\n        messages.clear();\n        updateSession(messages);\n\n        return Configuration.deserializeSamlObject(o);\n    }"}, {"signature": "private LinkedHashMap<String, String> getMessages()", "full": "private LinkedHashMap<String, String> getMessages() {\n        if (internalMessages == null) {\n            internalMessages = initializeSession();\n        }\n        return internalMessages;\n    }"}, {"signature": "private LinkedHashMap<String, String> initializeSession()", "full": "@SuppressWarnings(\"unchecked\")\n    private LinkedHashMap<String, String> initializeSession() {\n        var messages = sessionStore.get(context, SAML_STORAGE_KEY);\n        if (!messages.isPresent()) {\n            synchronized (context) {\n                messages = sessionStore.get(context, SAML_STORAGE_KEY);\n                if (!messages.isPresent()) {\n                    messages = Optional.of(new LinkedHashMap<>());\n                    updateSession((LinkedHashMap<String, String>) messages.get());\n                }\n            }\n        }\n        return (LinkedHashMap<String, String>) messages.get();\n    }"}, {"signature": "private void updateSession(final LinkedHashMap<String, String> messages)", "full": "private void updateSession(final LinkedHashMap<String, String> messages) {\n        sessionStore.set(context, SAML_STORAGE_KEY, messages);\n    }"}, {"signature": "public void remove(final String key) \n}", "full": "@Override\n    public void remove(final String key) {\n        set(key, null);\n    }\n}"}], "class_attributes": [{"type": "Logger", "name": "log"}, {"type": "WebContext", "name": "context"}, {"type": "SessionStore", "name": "sessionStore"}, {"type": "LinkedHashMap", "name": "internalMessages"}, {"type": "String", "name": "SAML_STORAGE_KEY"}]}
{"id": 4741787, "class_signatures": "public class ControllerServiceMain extends AbstractExecutionThreadService implements AutoCloseable", "class_methods": [{"signature": "protected void triggerShutdown()", "full": "@Override\n    protected void triggerShutdown() {\n        log.info(\"Shutting down Controller Service.\");\n        this.serviceStopFuture.complete(null);\n    }"}, {"signature": "public ControllerServiceMain(ControllerServiceConfig serviceConfig)", "full": "public ControllerServiceMain(ControllerServiceConfig serviceConfig) {\n        this(serviceConfig, ControllerServiceStarter::new);\n    }"}, {"signature": "ControllerServiceMain(final ControllerServiceConfig serviceConfig,\n                          final BiFunction<ControllerServiceConfig, StoreClient, ControllerServiceStarter> starterFactory)", "full": "@VisibleForTesting\n    ControllerServiceMain(final ControllerServiceConfig serviceConfig,\n                          final BiFunction<ControllerServiceConfig, StoreClient, ControllerServiceStarter> starterFactory) {\n        this.objectId = \"ControllerServiceMain\";\n        this.serviceConfig = serviceConfig;\n        this.starterFactory = starterFactory;\n        this.serviceStopFuture = new CompletableFuture<>();\n        this.serviceState = ServiceState.NEW;\n        this.zookeeperMetrics = new ZookeeperMetrics();\n    }"}, {"signature": "protected void run() throws Exception", "full": "@Override\n    protected void run() throws Exception {\n        long traceId = LoggerHelpers.traceEnter(log, this.objectId, \"run\");\n        try {\n            while (isRunning()) {\n                log.debug(\"Creating store client\");\n                storeClient = StoreClientFactory.createStoreClient(serviceConfig.getStoreClientConfig());\n\n                starter = starterFactory.apply(serviceConfig, storeClient);\n\n                boolean hasZkConnection = serviceConfig.getStoreClientConfig().getStoreType().equals(StoreType.Zookeeper) ||\n                        serviceConfig.isControllerClusterListenerEnabled();\n\n                CompletableFuture<Void> sessionExpiryFuture = new CompletableFuture<>();\n                if (hasZkConnection) {\n                    CuratorFramework client = (CuratorFramework) storeClient.getClient();\n\n                    log.debug(\"Awaiting ZK client connection to ZK server\");\n                    client.blockUntilConnected();\n\n                    log.debug(\"Awaiting ZK session expiry or termination trigger for ControllerServiceMain\");\n                    client.getConnectionStateListenable().addListener((client1, newState) -> {\n                        if (newState.equals(ConnectionState.LOST)) {\n                            sessionExpiryFuture.complete(null);\n                            starter.notifySessionExpiration();\n                        }\n                    });\n                }\n\n                log.info(\"Starting Controller Services.\");\n                notifyServiceStateChange(ServiceState.STARTING);\n                starter.startAsync();\n                starter.awaitRunning();\n                log.info(\"Controller Services started successfully.\");\n                if (hasZkConnection) {\n                    CompletableFuture.anyOf(sessionExpiryFuture, this.serviceStopFuture).join();\n\n                    if (sessionExpiryFuture.isDone()) {\n                        zookeeperMetrics.reportZKSessionExpiration();\n                        log.info(\"ZK session expired. Stopping Controller Services.\");\n                    }\n                } else {\n                    this.serviceStopFuture.join();\n                    log.info(\"Stopping Controller Services.\");\n                }\n\n                notifyServiceStateChange(ServiceState.PAUSING);\n                starter.stopAsync();\n\n                log.debug(\"Awaiting termination of ControllerServices\");\n                starter.awaitTerminated();\n\n                if (hasZkConnection) {\n                    log.debug(\"Calling close on store client.\");\n                    storeClient.close();\n                }\n                log.info(\"Controller Services terminated successfully.\");\n            }\n        } catch (Exception e) {\n            log.error(\"Controller Service Main thread exited exceptionally\", e);\n            throw e;\n        } finally {\n            if (storeClient != null) {\n                storeClient.close();\n            }\n            LoggerHelpers.traceLeave(log, this.objectId, \"run\", traceId);\n        }\n    }"}, {"signature": "private void notifyServiceStateChange(ServiceState newState)", "full": "private void notifyServiceStateChange(ServiceState newState) {\n        monitor.enter();\n        try {\n            serviceState = newState;\n        } finally {\n            monitor.leave();\n        }\n    }"}, {"signature": "public ControllerServiceStarter awaitServiceStarting()", "full": "@VisibleForTesting\n    public ControllerServiceStarter awaitServiceStarting() {\n        monitor.enterWhenUninterruptibly(hasReachedStarting);\n        try {\n            if (serviceState != ServiceState.STARTING) {\n                throw new IllegalStateException(\"Expected state=\" + ServiceState.STARTING +\n                        \", but actual state=\" + serviceState);\n            } else {\n                return this.starter;\n            }\n        } finally {\n            monitor.leave();\n        }\n    }"}, {"signature": "public ControllerServiceStarter awaitServicePausing()", "full": "@VisibleForTesting\n    public ControllerServiceStarter awaitServicePausing() {\n        monitor.enterWhenUninterruptibly(hasReachedPausing);\n        try {\n            if (serviceState != ServiceState.PAUSING) {\n                throw new IllegalStateException(\"Expected state=\" + ServiceState.PAUSING +\n                        \", but actual state=\" + serviceState);\n            } else {\n                return this.starter;\n            }\n        } finally {\n            monitor.leave();\n        }\n    }"}, {"signature": "public void forceClientSessionExpiry() throws Exception", "full": "@VisibleForTesting\n    public void forceClientSessionExpiry() throws Exception {\n        Preconditions.checkState(serviceConfig.isControllerClusterListenerEnabled(),\n                \"Controller Cluster not enabled\");\n        awaitServiceStarting();\n        ((CuratorFramework) this.storeClient.getClient()).getZookeeperClient().getZooKeeper()\n                                                         .getTestable().injectSessionExpiration();\n    }"}, {"signature": "protected void shutDown() throws Exception", "full": "@Override\n    protected void shutDown() throws Exception {\n        if (starter != null) {\n            if (starter.isRunning()) {\n                triggerShutdown();\n                starter.awaitTerminated();\n            }\n        }\n        if (storeClient != null) {\n            storeClient.close();\n        }\n    }"}, {"signature": "public void close() \n}", "full": "@Override\n    public void close() {\n        if (starter != null) {\n            triggerShutdown();\n            Callbacks.invokeSafely(starter::close, ex -> log.debug(\"Error closing starter. \" + ex.getMessage()));\n        }\n\n        if (storeClient != null) {\n            Callbacks.invokeSafely(storeClient::close, ex -> log.debug(\"Error closing storeClient. \" + ex.getMessage()));\n        }\n    }\n}"}], "class_attributes": [{"type": "String", "name": "objectId"}, {"type": "ControllerServiceConfig", "name": "serviceConfig"}, {"type": "BiFunction", "name": "starterFactory"}, {"type": "ControllerServiceStarter", "name": "starter"}, {"type": "CompletableFuture", "name": "serviceStopFuture"}, {"type": "StoreClient", "name": "storeClient"}, {"type": "ServiceState", "name": "serviceState"}, {"type": "Monitor", "name": "monitor"}, {"type": "Monitor", "name": "hasReachedStarting"}, {"type": "Monitor", "name": "hasReachedPausing"}, {"type": "ZookeeperMetrics", "name": "zookeeperMetrics"}]}
{"id": 4826210, "class_signatures": "public class BLEManager", "class_methods": [{"signature": "public BLEManager(Context context, BluetoothDevice bluetoothDevice, CharacteristicChangeListener\n            characteristicChangeListener, UnexpectedConnectionEventListener unexpectedDisconnectionListener)", "full": "public BLEManager(Context context, BluetoothDevice bluetoothDevice, CharacteristicChangeListener\n            characteristicChangeListener, UnexpectedConnectionEventListener unexpectedDisconnectionListener) {\n        if(DEBUG) {\n            logi(\"start1\");\n        }\n\n        this.context = context;\n        this.bluetoothDevice = bluetoothDevice;\n        this.characteristicChangeListener = characteristicChangeListener;\n        this.unexpectedDisconnectionListener = unexpectedDisconnectionListener;\n    }"}, {"signature": "private static void logi(String message)", "full": "private static void logi(String message) {\n        Log.i(TAG, \"### \" + Thread.currentThread().getId() + \" # \" + message);\n    }"}, {"signature": "public void setBluetoothDevice(BluetoothDevice bluetoothDevice)", "full": "public void setBluetoothDevice(BluetoothDevice bluetoothDevice) {\n        this.bluetoothDevice = bluetoothDevice;\n    }"}, {"signature": "public void setCharacteristicChangeListener(CharacteristicChangeListener characteristicChangeListener)", "full": "public void setCharacteristicChangeListener(CharacteristicChangeListener characteristicChangeListener) {\n        this.characteristicChangeListener = characteristicChangeListener;\n    }"}, {"signature": "public BluetoothGattService getService(UUID uuid)", "full": "@Nullable\n    public BluetoothGattService getService(UUID uuid) {\n        if(gatt == null) {\n            return null;\n        }\n\n        if((bleState & BLE_SERVICES_DISCOVERED) != 0) {\n            return gatt.getService(uuid);\n        }\n\n        return null;\n    }"}, {"signature": "public List<BluetoothGattService> getServices()", "full": "@Nullable\n    public List<BluetoothGattService> getServices() {\n        if(gatt == null) {\n            return null;\n        }\n\n        if((bleState & BLE_SERVICES_DISCOVERED) != 0) {\n            return gatt.getServices();\n        }\n\n        return null;\n    }"}, {"signature": "public boolean reset()", "full": "public boolean reset() {\n        if(DEBUG) {\n            logi(\"reset()\");\n        }\n\n        synchronized(locker) {\n            if(bleState != BLE_DISCONNECTED) {\n                disconnect();\n            }\n\n            if(bleState != BLE_DISCONNECTED) {\n                return false;\n            }\n\n            lastCharacteristic = null;\n            lastDescriptor = null;\n            rssi = 0;\n            error = 0;\n            inBleOp = OP_NOOP;\n            callbackCompleted = false;\n            if(gatt != null) {\n                if(DEBUG) {\n                    logi(\"reset() :: gatt != null : closing gatt\");\n                }\n\n                gatt.close();\n            }\n\n            gatt = null;\n            return true;\n        }\n    }"}, {"signature": "public int getExtendedError()", "full": "public int getExtendedError() {\n        return extendedError;\n    }"}, {"signature": "public int connect(boolean autoReconnect)", "full": "public int connect(boolean autoReconnect) {\n        int rc = BLE_ERROR_NOOP;\n\n        if(gatt == null) {\n            if(DEBUG) {\n                logi(\"connectMaybeInit() :: gatt == null\");\n            }\n\n            synchronized(locker) {\n                if(inBleOp == OP_NOOP) {\n                    inBleOp = OP_CONNECT;\n                    try {\n                        if(DEBUG) {\n                            logi(\"connectMaybeInit() :: bluetoothDevice.connectGatt(context, autoReconnect, bluetoothGattCallback)\");\n                        }\n\n                        gatt = bluetoothDevice.connectGatt(context, autoReconnect, bluetoothGattCallback);\n\n                        if(gatt == null) {\n                            if(DEBUG) {\n                                logi(\"connectGatt failed with AutoReconnect = \" + autoReconnect + \". Trying again.. !autoReconnect=\" + !autoReconnect);\n                            }\n                            gatt = bluetoothDevice.connectGatt(context, !autoReconnect, bluetoothGattCallback);\n                        }\n\n                        if(gatt != null) {\n                            error = 0;\n                            locker.wait(BLE_WAIT_TIMEOUT);\n\n                            if(DEBUG) {\n                                logi(\"connectMaybeInit() :: remote device = \" + gatt.getDevice().getAddress());\n                            }\n\n                            if(!callbackCompleted) {\n                                error = (BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT);\n                            }\n\n                            rc = error | bleState;\n                        }\n                    } catch(InterruptedException e) {\n                        Log.e(TAG, e.toString());\n                    }\n\n                    inBleOp = OP_NOOP;\n                }\n            }\n        } else {\n            rc = gattConnect();\n        }\n\n        if(DEBUG) {\n            logi(\"connectMaybeInit() :: rc = \" + rc);\n        }\n        return rc;\n    }"}, {"signature": "private int gattConnect()", "full": "private int gattConnect() {\n        if(DEBUG) {\n            logi(\"gattConnect() :: start\");\n        }\n\n        int rc = BLE_ERROR_NOOP;\n\n        synchronized(locker) {\n            if(gatt != null && inBleOp == OP_NOOP) {\n                if(DEBUG) {\n                    logi(\"gattConnect() :: gatt != null\");\n                }\n\n                inBleOp = OP_CONNECT;\n                error = 0;\n                try {\n                    if(bleState == BLE_DISCONNECTED) {\n                        if(DEBUG) {\n                            logi(\"gattConnect() :: gatt.connectMaybeInit()\");\n                        }\n\n                        callbackCompleted = false;\n\n                        boolean result = gatt.connect();\n                        logi(\"gatt.connectMaybeInit() returns = \" + result);\n                        locker.wait(BLE_WAIT_TIMEOUT);\n\n                        if(DEBUG) {\n                            logi(\"gattConnect() :: remote device = \" + gatt.getDevice().getAddress());\n                        }\n\n                        if(!callbackCompleted) {\n                            logi(\"BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT\");\n                            error = (BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT);\n                        }\n                        rc = error | bleState;\n                    }\n                } catch(InterruptedException e) {\n                    Log.e(TAG, e.toString());\n                }\n\n                inBleOp = OP_NOOP;\n            }\n        }\n\n        if(DEBUG) {\n            logi(\"gattConnect() :: rc = \" + rc);\n        }\n\n        return rc;\n    }"}, {"signature": "public int disconnect()", "full": "public int disconnect() {\n        if(DEBUG) {\n            logi(\"disconnect() :: start\");\n        }\n\n        int rc = BLE_ERROR_NOOP;\n\n        synchronized(locker) {\n            if(gatt != null && inBleOp == OP_NOOP) {\n\n                inBleOp = OP_CONNECT;\n                try {\n                    error = 0;\n                    if(bleState != BLE_DISCONNECTED) {\n                        callbackCompleted = false;\n                        gatt.disconnect();\n                        locker.wait(BLE_WAIT_TIMEOUT);\n                        if(!callbackCompleted) {\n                            error = (BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT);\n                        }\n                    }\n\n                    rc = error | bleState;\n                } catch(InterruptedException e) {\n                    Log.e(TAG, e.toString());\n                }\n\n                inBleOp = OP_NOOP;\n            }\n        }\n\n        if(DEBUG) {\n            logi(\"disconnect() :: rc = \" + rc);\n        }\n\n        return rc;\n    }"}, {"signature": "public int discoverServices()", "full": "public int discoverServices() {\n        if(DEBUG) {\n            logi(\"discoverServices() :: start\");\n        }\n\n        int rc = BLE_ERROR_NOOP;\n        synchronized(locker) {\n            if(gatt != null && inBleOp == OP_NOOP) {\n\n                inBleOp = OP_DISCOVER_SERVICES;\n                error = 0;\n                try {\n                    callbackCompleted = false;\n                    if(gatt.discoverServices()) {\n                        locker.wait(BLE_WAIT_TIMEOUT);\n                        if(!callbackCompleted) {\n                            error = (BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT);\n                        }\n\n                        rc = error | bleState;\n                    }\n                } catch(InterruptedException e) {\n                    Log.e(TAG, e.toString());\n                }\n\n                inBleOp = OP_NOOP;\n            }\n        }\n\n        if(DEBUG) {\n            logi(\"discoverServices() :: end : rc = \" + rc);\n        }\n\n        return rc;\n    }"}, {"signature": "public boolean isConnected()", "full": "public boolean isConnected() {\n        return bleState == BLE_CONNECTED || bleState == BLE_SERVICES_DISCOVERED || bleState == (BLE_CONNECTED |\n                BLE_SERVICES_DISCOVERED);\n    }"}, {"signature": "public int writeDescriptor(BluetoothGattDescriptor descriptor)", "full": "public int writeDescriptor(BluetoothGattDescriptor descriptor) {\n        if(DEBUG) {\n            logi(\"writeDescriptor() :: start\");\n        }\n\n        int rc = BLE_ERROR_NOOP;\n\n        synchronized(locker) {\n            if(gatt != null && inBleOp == OP_NOOP) {\n\n                inBleOp = OP_WRITE_DESCRIPTOR;\n                lastDescriptor = null;\n                error = 0;\n                try {\n                    if(gatt.writeDescriptor(descriptor)) {\n                        callbackCompleted = false;\n                        locker.wait(BLE_WAIT_TIMEOUT);\n                        if(!callbackCompleted) {\n                            error = (BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT);\n                        }\n\n                        rc = error | bleState;\n                    }\n\n                } catch(InterruptedException e) {\n                    Log.e(TAG, e.toString());\n                }\n\n                inBleOp = OP_NOOP;\n            }\n        }\n\n        if(DEBUG) {\n            logi(\"writeDescriptor() :: end : rc = \" + rc);\n        }\n\n        return rc;\n    }"}, {"signature": "public int readDescriptor(BluetoothGattDescriptor descriptor)", "full": "public int readDescriptor(BluetoothGattDescriptor descriptor) {\n        if(DEBUG) {\n            logi(\"readDescriptor() :: start\");\n        }\n\n        int rc = BLE_ERROR_NOOP;\n\n        synchronized(locker) {\n            if(gatt != null && inBleOp > OP_NOOP) {\n\n                inBleOp = OP_READ_DESCRIPTOR;\n                lastDescriptor = null;\n                error = 0;\n                try {\n                    callbackCompleted = false;\n                    if(gatt.readDescriptor(descriptor)) {\n                        locker.wait(BLE_WAIT_TIMEOUT);\n                        if(!callbackCompleted) {\n                            error = (BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT);\n                        }\n\n                        rc = error | bleState;\n                    }\n                } catch(InterruptedException e) {\n                    Log.e(TAG, e.toString());\n                }\n\n                inBleOp = OP_NOOP;\n            }\n        }\n\n        if(DEBUG) {\n            logi(\"readDescriptor() :: end : rc = \" + rc);\n        }\n\n        return rc;\n    }"}, {"signature": "public int writeCharacteristic(BluetoothGattCharacteristic characteristic)", "full": "public int writeCharacteristic(BluetoothGattCharacteristic characteristic) {\n        if(DEBUG) {\n            logi(\"writeCharacteristic() :: start\");\n        }\n\n        int rc = BLE_ERROR_NOOP;\n\n        synchronized(locker) {\n            if(gatt != null && inBleOp == OP_NOOP) {\n                inBleOp = OP_WRITE_CHARACTERISTIC;\n                lastCharacteristic = null;\n                error = 0;\n                try {\n                    callbackCompleted = false;\n                    if(gatt.writeCharacteristic(characteristic)) {\n                        locker.wait(BLE_WAIT_TIMEOUT);\n                        if(!callbackCompleted) {\n                            error = (BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT);\n                        }\n\n                        rc = error | bleState;\n                    } else {\n                        if(DEBUG) {\n                            logi(\"writeCharacteristic() :: failed\");\n                        }\n                    }\n\n\n                } catch(InterruptedException e) {\n                    Log.e(TAG, e.toString());\n                }\n\n                inBleOp = OP_NOOP;\n            } else {\n                logi(\"Couldn't write to characteristic\");\n            }\n\n        }\n\n        if(DEBUG) {\n            logi(\"writeCharacteristic() :: end : rc = \" + rc);\n        }\n\n        return rc;\n    }"}, {"signature": "public int readCharacteristic(BluetoothGattCharacteristic characteristic)", "full": "public int readCharacteristic(BluetoothGattCharacteristic characteristic) {\n        if(DEBUG) {\n            logi(\"readCharacteristic() :: start\");\n        }\n\n        int rc = BLE_ERROR_NOOP;\n\n        synchronized(locker) {\n            if(gatt != null && inBleOp == OP_NOOP) {\n\n                inBleOp = OP_READ_CHARACTERISTIC;\n                lastCharacteristic = null;\n                error = 0;\n                int bleState = this.bleState;\n                try {\n                    callbackCompleted = false;\n                    if(gatt.readCharacteristic(characteristic)) {\n                        locker.wait(BLE_WAIT_TIMEOUT);\n                        if(!callbackCompleted) {\n                            error = (BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT);\n                        } else {\n                            bleState = this.bleState;\n                        }\n\n                        rc = error | bleState;\n                    }\n                } catch(InterruptedException e) {\n                    Log.e(TAG, e.toString());\n                }\n\n                inBleOp = OP_NOOP;\n            }\n        }\n\n        if(DEBUG) {\n            logi(\"readCharacteristic() :: end : rc = \" + rc);\n        }\n\n        return rc;\n    }"}, {"signature": "public BluetoothGattCharacteristic getLastCharacteristic()", "full": "public BluetoothGattCharacteristic getLastCharacteristic() {\n        return lastCharacteristic;\n    }"}, {"signature": "public int enableCharacteristicNotification(BluetoothGattCharacteristic characteristic, BluetoothGattDescriptor\n            descriptor, boolean enable)", "full": "public int enableCharacteristicNotification(BluetoothGattCharacteristic characteristic, BluetoothGattDescriptor\n            descriptor, boolean enable) {\n        if(gatt == null) {\n            return BLE_ERROR_NOOP;\n        }\n        int rc = BLE_ERROR_NOOP;\n\n        synchronized(locker) {\n            error = 0;\n\n            if(gatt.setCharacteristicNotification(characteristic, enable)) {\n                logi(\"characteristic notif success\");\n                rc = error | bleState;\n\n                descriptor.setValue(enable ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE :\n                        BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);\n            }\n        }\n\n        return writeDescriptor(descriptor) | rc;\n    }"}], "class_attributes": [{"type": "String", "name": "TAG"}, {"type": "int", "name": "BLE_DISCONNECTED"}, {"type": "int", "name": "BLE_CONNECTED"}, {"type": "int", "name": "BLE_SERVICES_DISCOVERED"}, {"type": "int", "name": "BLE_ERROR_OK"}, {"type": "int", "name": "BLE_ERROR_FAIL"}, {"type": "int", "name": "BLE_ERROR_TIMEOUT"}, {"type": "int", "name": "BLE_ERROR_NOOP"}, {"type": "int", "name": "BLE_ERROR_NOGATT"}, {"type": "long", "name": "BLE_WAIT_TIMEOUT"}, {"type": "int", "name": "OP_NOOP"}, {"type": "int", "name": "OP_CONNECT"}, {"type": "int", "name": "OP_DISCOVER_SERVICES"}, {"type": "int", "name": "OP_READ_CHARACTERISTIC"}, {"type": "int", "name": "OP_WRITE_CHARACTERISTIC"}, {"type": "int", "name": "OP_READ_DESCRIPTOR"}, {"type": "int", "name": "OP_WRITE_DESCRIPTOR"}, {"type": "int", "name": "OP_CHARACTERISTIC_CHANGED"}, {"type": "int", "name": "OP_RELIABLE_WRITE_COMPLETED"}, {"type": "int", "name": "OP_READ_REMOTE_RSSI"}, {"type": "int", "name": "OP_MTU_CHANGED"}, {"type": "int", "name": "bleState"}, {"type": "int", "name": "error"}, {"type": "int", "name": "inBleOp"}, {"type": "boolean", "name": "callbackCompleted"}, {"type": "int", "name": "rssi"}, {"type": "BluetoothGattCharacteristic", "name": "lastCharacteristic"}, {"type": "BluetoothGattDescriptor", "name": "lastDescriptor"}, {"type": "Context", "name": "context"}, {"type": "BluetoothGatt", "name": "gatt"}, {"type": "BluetoothDevice", "name": "bluetoothDevice"}, {"type": "Object", "name": "locker"}, {"type": "CharacteristicChangeListener", "name": "characteristicChangeListener"}, {"type": "UnexpectedConnectionEventListener", "name": "unexpectedDisconnectionListener"}, {"type": "int", "name": "extendedError"}, {"type": "BluetoothGattCallback", "name": "bluetoothGattCallback"}]}
{"id": 4880569, "class_signatures": "public class AuthorityInfoAccessFactory", "class_methods": [{"signature": "private AuthorityInfoAccessFactory()", "full": "private AuthorityInfoAccessFactory() {\n        elements = new Vector<AccessDescription>();\n    }"}, {"signature": "public static final AuthorityInfoAccessFactory create()", "full": "public static final AuthorityInfoAccessFactory create() {\n        AuthorityInfoAccessFactory aiaf = new AuthorityInfoAccessFactory();\n        return aiaf;\n    }"}, {"signature": "public final AuthorityInfoAccessFactory addElement(final AccessDescription element)", "full": "public final AuthorityInfoAccessFactory addElement(final AccessDescription element) {\n        elements.add(element);\n        return this;\n    }"}, {"signature": "public final AuthorityInfoAccessFactory addElement(final MethodJson type, final GeneralName location)", "full": "public final AuthorityInfoAccessFactory addElement(final MethodJson type, final GeneralName location) {\n        elements.add(new AccessDescription(type.getOid(), location));\n        return this;\n    }"}, {"signature": "public final AuthorityInformationAccess build() \n}", "full": "public final AuthorityInformationAccess build() {\n        if (elements.isEmpty()) {\n            return null;\n        }\n        AccessDescription[] ads = elements.toArray(new AccessDescription[elements.size()]);\n        AuthorityInformationAccess aia = new AuthorityInformationAccess(ads);\n        return aia;\n    }\n}"}], "class_attributes": [{"type": "Vector", "name": "elements"}]}
{"id": 5263027, "class_signatures": "public class CacheFilter extends AbstractFilter", "class_methods": [{"signature": "public String prepare(RenderContext renderContext, Resource resource, RenderChain chain) throws Exception", "full": "@Override\n    public String prepare(RenderContext renderContext, Resource resource, RenderChain chain) throws Exception {\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> moduleMap = (Map<String, Object>) renderContext.getRequest().getAttribute(\"moduleMap\");\n        if (!isCacheFilterEnabled(moduleMap)) {\n            generatorQueue.getFragmentsGenerationPermit(resource.toString(), renderContext.getRequest());\n            return null;\n        }\n\n        moduleMap.put(RENDERING_TIMER, System.currentTimeMillis());\n        final String path = resource.getNodePath();\n        final String key = (String) moduleMap.get(AggregateFilter.RENDERING_KEY);\n        final String finalKey = (String) moduleMap.get(AggregateFilter.RENDERING_FINAL_KEY);\n\n        Element element = null;\n        final Cache cache = cacheProvider.getCache();\n\n        try {\n            logger.debug(\"Try to get fragment from cache with final key: {}\", finalKey);\n            element = cache.get(finalKey);\n        } catch (LockTimeoutException e) {\n            logger.warn(\"Error while rendering \" + renderContext.getMainResource() + e.getMessage(), e);\n        }\n\n        if (element != null && element.getObjectValue() != null) {\n            logger.debug(\"Fragment found in cache: {} \", path);\n            return returnFromCache(renderContext, key, finalKey, element, moduleMap);\n        }\n\n        logger.debug(\"Fragment not found in cache: {} \", path);\n\n        resource.safeLoadNode();\n\n        if (isCacheable(renderContext, key, resource, cacheProvider.getKeyGenerator().getAttributesForKey(renderContext, resource))) {\n            if (!bypassCache(renderContext, resource)) {\n                logger.debug(\"Use latch to decide between generate or waiting fragment: {}\", path);\n\n                if (generatorQueue.getLatch(renderContext, finalKey)) {\n                    element = cache.get(finalKey);\n                    if (element != null && element.getObjectValue() != null) {\n                        logger.debug(\"Latch released for fragment: {} and fragment found in cache\", path);\n                        return returnFromCache(renderContext, key, finalKey, element, moduleMap);\n                    }\n                    logger.debug(\"Latch released for fragment: {} but fragment not found in cache, generate it\", path);\n                }\n                return null;\n            }\n        } else {\n            cacheProvider.addNonCacheableFragment(key);\n        }\n\n        generatorQueue.getFragmentsGenerationPermit(finalKey, renderContext.getRequest());\n        return null;\n    }"}, {"signature": "public String execute(String previousOut, RenderContext renderContext, Resource resource, RenderChain chain) throws Exception", "full": "@Override\n    public String execute(String previousOut, RenderContext renderContext, Resource resource, RenderChain chain) throws Exception {\n        return execute(previousOut, renderContext, resource, false);\n    }"}, {"signature": "private void logCacheFilterRenderingTime(Resource resource, Map<String, Object> moduleMap)", "full": "private void logCacheFilterRenderingTime(Resource resource, Map<String, Object> moduleMap) {\n        if (!logger.isDebugEnabled()) {\n            return;\n        }\n        Object servedFromCacheAttribute = moduleMap.get(FRAGMENT_SERVED_FROM_CACHE);\n        Boolean isServerFromCache = servedFromCacheAttribute != null && (Boolean) servedFromCacheAttribute;\n        String cacheLogMsg = isServerFromCache ? \"Served fragment {} from cache in {} ms\" : \"Generated fragment {} in {} ms\";\n        long start = (Long) moduleMap.get(RENDERING_TIMER);\n        logger.debug(cacheLogMsg, resource.getPath(), System.currentTimeMillis() - start);\n    }"}, {"signature": "public void finalize(RenderContext renderContext, Resource resource, RenderChain chain)", "full": "@Override\n    public void finalize(RenderContext renderContext, Resource resource, RenderChain chain) {\n\n        if (renderContext.getRequest().getAttribute(RESOURCES_STACK) == null) {\n            generatorQueue.releaseFragmentsGenerationPermit(renderContext.getRequest());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> moduleMap = (Map<String, Object>) renderContext.getRequest().getAttribute(\"moduleMap\");\n        if (isCacheFilterEnabled(moduleMap)) {\n            generatorQueue.releaseLatch((String) moduleMap.get(AggregateFilter.RENDERING_FINAL_KEY));\n        }\n    }"}, {"signature": "public String getContentForError(RenderContext renderContext, Resource resource, RenderChain chain, Exception e)", "full": "@Override\n    public String getContentForError(RenderContext renderContext, Resource resource, RenderChain chain, Exception e) {\n\n        super.getContentForError(renderContext, resource, chain, e);\n        HttpServletRequest request = renderContext.getRequest();\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Object> moduleMap = (Map<String, Object>) request.getAttribute(\"moduleMap\");\n        if (!isCacheFilterEnabled(moduleMap) || cascadeFragmentErrors || Resource.CONFIGURATION_PAGE.equals(resource.getContextConfiguration())) {\n            return null;\n        }\n\n        try {\n            return execute(\"<!-- Module error : \" + HtmlUtils.htmlEscape(e.getMessage()) + \"-->\", renderContext, resource, true);\n        } catch (Exception e1) {\n            return null;\n        }\n    }"}, {"signature": "private boolean isCacheFilterEnabled(Map<String, Object> moduleMap)", "full": "private boolean isCacheFilterEnabled(Map<String, Object> moduleMap) {\n        return moduleMap.get(AggregateFilter.RENDERING_KEY) != null && moduleMap.get(AggregateFilter.RENDERING_FINAL_KEY) != null;\n    }"}, {"signature": "protected void doCache(String previousOut, RenderContext renderContext, Resource resource, Long expiration, Cache cache, String finalKey, boolean bypassDependencies)", "full": "protected void doCache(String previousOut, RenderContext renderContext, Resource resource, Long expiration, Cache cache, String finalKey, boolean bypassDependencies) {\n\n        Set<String> depNodeWrappers = Collections.emptySet();\n\n        CacheEntry<String> cacheEntry = new CacheEntry<String>(previousOut);\n\n        addPropertiesToCacheEntry(cacheEntry, renderContext);\n\n        Element cachedElement = new Element(finalKey, cacheEntry);\n\n        if (expiration > 0) {\n            cachedElement.setTimeToLive(expiration.intValue());\n        }\n        if (!bypassDependencies) {\n            storeDependencies(renderContext, resource, finalKey, depNodeWrappers);\n        }\n        cache.put(cachedElement);\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Store in cache content of fragment with key: {}\", finalKey);\n            StringBuilder stringBuilder = new StringBuilder();\n            for (String path : depNodeWrappers) {\n                stringBuilder.append(path).append(\"\\n\");\n            }\n            logger.debug(\"Dependencies of {}: {}\", finalKey, stringBuilder);\n        }\n    }"}, {"signature": "private void storeDependencies(RenderContext renderContext, Resource resource, String finalKey, Set<String> depNodeWrappers)", "full": "@SuppressWarnings(\"unchecked\")\n    private void storeDependencies(RenderContext renderContext, Resource resource, String finalKey, Set<String> depNodeWrappers) {\n        if (useDependencies()) {\n            final Cache dependenciesCache = cacheProvider.getDependenciesCache();\n            depNodeWrappers = resource.getDependencies();\n            for (String path : depNodeWrappers) {\n                if(!path.startsWith(\"/modules\")) {\n                    Element element1 = dependenciesCache.get(path);\n                    Set<String> dependencies = element1 != null ? (Set<String>) element1.getObjectValue() : Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());\n                    if (!dependencies.contains(FLAG_ALL)) {\n                        if ((dependencies.size() + 1) > dependenciesLimit) {\n                            Element element = new Element(path, FLAGS_ALL_SET);\n                            element.setEternal(true);\n                            dependenciesCache.put(element);\n                        } else {\n                            addDependencies(renderContext, finalKey, dependenciesCache, path, dependencies);\n                        }\n                    }\n                }\n            }\n            final Cache regexpDependenciesCache = cacheProvider.getRegexpDependenciesCache();\n            Set<String> regexpDepNodeWrappers = resource.getRegexpDependencies();\n            for (String regexp : regexpDepNodeWrappers) {\n                Element element1 = regexpDependenciesCache.get(regexp);\n                Set<String> dependencies = element1 != null ? (Set<String>) element1.getObjectValue() : Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());\n                addDependencies(renderContext, finalKey, regexpDependenciesCache, regexp, dependencies);\n            }\n        }\n        resource.getDependencies().clear();\n        resource.getRegexpDependencies().clear();\n    }"}, {"signature": "protected boolean useDependencies()", "full": "protected boolean useDependencies() {\n        return true;\n    }"}, {"signature": "protected void addDependencies(RenderContext renderContext, String finalKey, Cache cache, String value, Set<String> newDependencies)", "full": "protected void addDependencies(RenderContext renderContext, String finalKey, Cache cache, String value, Set<String> newDependencies) {\n        if (newDependencies.add(finalKey)) {\n            cache.put(new Element(value, newDependencies));\n        }\n    }"}, {"signature": "private void addPropertiesToCacheEntry(CacheEntry<String> cacheEntry, RenderContext renderContext)", "full": "@SuppressWarnings(\"unchecked\")\n    private void addPropertiesToCacheEntry(CacheEntry<String> cacheEntry, RenderContext renderContext) {\n        Map<String,Object> moduleMap = (Map<String, Object>) renderContext.getRequest().getAttribute(\"moduleMap\");\n        if (moduleMap != null && moduleMap.containsKey(\"requestAttributesToCache\")){\n            HashMap<String,Serializable> attributes = new HashMap<>();\n            Collection<String> requestAttributesToCache = (Collection<String>) moduleMap.get(\"requestAttributesToCache\");\n            for (String attributesToCache : requestAttributesToCache) {\n                if (renderContext.getRequest().getAttribute(attributesToCache) instanceof Serializable) {\n                    attributes.put(attributesToCache, (Serializable) renderContext.getRequest().getAttribute(attributesToCache));\n                }\n            }\n            cacheEntry.setProperty(\"requestAttributes\", attributes);\n        }\n    }"}, {"signature": "private void restorePropertiesFromCacheEntry(CacheEntry<?> cacheEntry, RenderContext renderContext)", "full": "@SuppressWarnings(\"unchecked\")\n    private void restorePropertiesFromCacheEntry(CacheEntry<?> cacheEntry, RenderContext renderContext) {\n        if (cacheEntry.getProperty(\"requestAttributes\") != null) {\n            Map<String,Serializable> requestAttributesToCache = (Map<String, Serializable>) cacheEntry.getProperty(\"requestAttributes\");\n            for (Map.Entry<String, Serializable> entry : requestAttributesToCache.entrySet()) {\n                renderContext.getRequest().setAttribute(entry.getKey(), entry.getValue());\n            }\n        }\n    }"}, {"signature": "protected boolean isCacheable(RenderContext renderContext, String key, Resource resource, Properties fragmentProperties) throws RepositoryException", "full": "protected boolean isCacheable(RenderContext renderContext, String key, Resource resource, Properties fragmentProperties) throws RepositoryException {\n\n        if (cacheProvider.isNonCacheableFragment(key)) {\n            return false;\n        }\n\n        final String cacheExpiration = fragmentProperties.getProperty(CacheUtils.FRAGMNENT_PROPERTY_CACHE_EXPIRATION);\n        Long expiration = cacheExpiration != null ? Long.parseLong(cacheExpiration) : -1;\n        return expiration != 0L;\n    }"}, {"signature": "private boolean bypassCache(RenderContext renderContext, Resource resource) throws RepositoryException", "full": "private boolean bypassCache(RenderContext renderContext, Resource resource) throws RepositoryException {\n\n        if (renderContext.getRequest().getParameter(FLAG_VERSION) != null && renderContext.isLoggedIn()) {\n            return true;\n        }\n\n        final String ecParameter = renderContext.getRequest().getParameter(FLAG_RANDOM);\n        if (ecParameter != null) {\n            if (ecParameter.equals(resource.getNode().getIdentifier())) {\n                return true;\n            }\n            for (Resource parent : renderContext.getResourcesStack()) {\n                if (ecParameter.equals(parent.getNode().getIdentifier())) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }"}, {"signature": "protected String returnFromCache(RenderContext renderContext, String key, String finalKey, Element element, Map<String, Object> moduleMap)", "full": "protected String returnFromCache(RenderContext renderContext, String key, String finalKey, Element element, Map<String, Object> moduleMap) {\n\n        logger.debug(\"Content retrieved from cache for node with key: {}\", finalKey);\n        CacheEntry<?> cacheEntry = (CacheEntry<?>) element.getObjectValue();\n        String cachedContent = (String) cacheEntry.getObject();\n\n        restorePropertiesFromCacheEntry(cacheEntry, renderContext);\n\n        moduleMap.put(FRAGMENT_SERVED_FROM_CACHE, Boolean.TRUE);\n\n        return cachedContent;\n    }"}, {"signature": "protected String appendDebugInformation(Map<String, Object> moduleMap, String renderContent)", "full": "protected String appendDebugInformation(Map<String, Object> moduleMap, String renderContent) {\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"<div class=\\\"cacheDebugInfo\\\">\");\n        stringBuilder.append(\"<span class=\\\"cacheDebugInfoLabel\\\">Expiration: </span><span>\");\n        if (Boolean.TRUE.equals(moduleMap.get(FRAGMENT_SERVED_FROM_CACHE))) {\n            stringBuilder.append(SimpleDateFormat.getDateTimeInstance().format(new Date(cacheProvider.getCache().get(\n                    moduleMap.get(AggregateFilter.RENDERING_FINAL_KEY)).getExpirationTime())));\n        } else {\n            stringBuilder.append(\"Not cached fragment \").append(SimpleDateFormat.getDateTimeInstance().format(Calendar.getInstance().getTime()));\n        }\n        stringBuilder.append(\"</span><br/>\");\n        stringBuilder.append(\"</div>\");\n        stringBuilder.append(renderContent);\n        return stringBuilder.toString();\n    }"}, {"signature": "public void setCacheProvider(ModuleCacheProvider cacheProvider)", "full": "public void setCacheProvider(ModuleCacheProvider cacheProvider) {\n        this.cacheProvider = cacheProvider;\n    }"}, {"signature": "public void setCascadeFragmentErrors(boolean cascadeFragmentErrors)", "full": "public void setCascadeFragmentErrors(boolean cascadeFragmentErrors) {\n        this.cascadeFragmentErrors = cascadeFragmentErrors;\n    }"}, {"signature": "public void setErrorCacheExpiration(int errorCacheExpiration)", "full": "public void setErrorCacheExpiration(int errorCacheExpiration) {\n        this.errorCacheExpiration = errorCacheExpiration;\n    }"}, {"signature": "public void setDependenciesLimit(int dependenciesLimit)", "full": "public void setDependenciesLimit(int dependenciesLimit) {\n        this.dependenciesLimit = dependenciesLimit;\n    }"}, {"signature": "public void setGeneratorQueue(ModuleGeneratorQueue generatorQueue) \n}", "full": "public void setGeneratorQueue(ModuleGeneratorQueue generatorQueue) {\n        this.generatorQueue = generatorQueue;\n    }\n}"}], "class_attributes": [{"type": "String", "name": "FLAG_VERSION"}, {"type": "String", "name": "FLAG_RANDOM"}, {"type": "String", "name": "FLAG_ALL"}, {"type": "Set", "name": "FLAGS_ALL_SET"}, {"type": "String", "name": "RENDERING_TIMER"}, {"type": "String", "name": "FRAGMENT_SERVED_FROM_CACHE"}, {"type": "Logger", "name": "logger"}, {"type": "ModuleCacheProvider", "name": "cacheProvider"}, {"type": "boolean", "name": "cascadeFragmentErrors"}, {"type": "int", "name": "errorCacheExpiration"}, {"type": "int", "name": "dependenciesLimit"}, {"type": "ModuleGeneratorQueue", "name": "generatorQueue"}]}
{"id": 5589100, "class_signatures": "public class PrintfFormat", "class_methods": [{"signature": "public PrintfFormat(String fmtArg)\n      throws IllegalArgumentException", "full": "public PrintfFormat(String fmtArg)\n      throws IllegalArgumentException {\n    this(Locale.getDefault(),fmtArg);\n  }"}, {"signature": "public PrintfFormat(Locale locale,String fmtArg)\n      throws IllegalArgumentException", "full": "public PrintfFormat(Locale locale,String fmtArg)\n      throws IllegalArgumentException {\n    dfs = new DecimalFormatSymbols(locale);\n    int ePos=0;\n    ConversionSpecification sFmt=null;\n    String unCS = this.nonControl(fmtArg,0);\n    if (unCS!=null) {\n      sFmt = new ConversionSpecification();\n      sFmt.setLiteral(unCS);\n      vFmt.addElement(sFmt);\n    }\n    while(cPos!=-1 && cPos<fmtArg.length()) {\n      for (ePos=cPos+1; ePos<fmtArg.length();\n                    ePos++) {\n        char c=0;\n        c = fmtArg.charAt(ePos);\n        if (c == 'i') break;\n        if (c == 'd') break;\n        if (c == 'f') break;\n        if (c == 'g') break;\n        if (c == 'G') break;\n        if (c == 'o') break;\n        if (c == 'x') break;\n        if (c == 'X') break;\n        if (c == 'e') break;\n        if (c == 'E') break;\n        if (c == 'c') break;\n        if (c == 's') break;\n        if (c == '%') break;\n      }\n      ePos=Math.min(ePos+1,fmtArg.length());\n      sFmt = new ConversionSpecification(\n        fmtArg.substring(cPos,ePos));\n      vFmt.addElement(sFmt);\n      unCS = this.nonControl(fmtArg,ePos);\n      if (unCS!=null) {\n        sFmt = new ConversionSpecification();\n        sFmt.setLiteral(unCS);\n        vFmt.addElement(sFmt);\n      }\n    }\n  }"}, {"signature": "private String nonControl(String s,int start)", "full": "private String nonControl(String s,int start) {\n    String ret=\"\";\n    cPos=s.indexOf(\"%\",start);\n    if (cPos==-1) cPos=s.length();\n    return s.substring(start,cPos);\n  }"}, {"signature": "public String sprintf(Object[] o)", "full": "public String sprintf(Object[] o) {\n    Enumeration e = vFmt.elements();\n    ConversionSpecification cs = null;\n    char c = 0;\n    int i=0;\n    StringBuffer sb=new StringBuffer();\n    while (e.hasMoreElements()) {\n      cs = (ConversionSpecification)\n        e.nextElement();\n      c = cs.getConversionCharacter();\n      if (c=='\\0') sb.append(cs.getLiteral());\n      else if (c=='%') sb.append(\"%\");\n      else {\n        if (cs.isPositionalSpecification()) {\n          i=cs.getArgumentPosition()-1;\n          if (cs.isPositionalFieldWidth()) {\n            int ifw=cs.getArgumentPositionForFieldWidth()-1;\n            cs.setFieldWidthWithArg(((Integer)o[ifw]).intValue());\n          }\n          if (cs.isPositionalPrecision()) {\n            int ipr=cs.getArgumentPositionForPrecision()-1;\n            cs.setPrecisionWithArg(((Integer)o[ipr]).intValue());\n          }\n        }\n        else {\n          if (cs.isVariableFieldWidth()) {\n            cs.setFieldWidthWithArg(((Integer)o[i]).intValue());\n            i++;\n          }\n          if (cs.isVariablePrecision()) {\n            cs.setPrecisionWithArg(((Integer)o[i]).intValue());\n            i++;\n          }\n        }\n        if (o[i] instanceof Byte)\n          sb.append(cs.internalsprintf(\n          ((Byte)o[i]).byteValue()));\n        else if (o[i] instanceof Short)\n          sb.append(cs.internalsprintf(\n          ((Short)o[i]).shortValue()));\n        else if (o[i] instanceof Integer)\n          sb.append(cs.internalsprintf(\n          ((Integer)o[i]).intValue()));\n        else if (o[i] instanceof Long)\n          sb.append(cs.internalsprintf(\n          ((Long)o[i]).longValue()));\n        else if (o[i] instanceof Float)\n          sb.append(cs.internalsprintf(\n          ((Float)o[i]).floatValue()));\n        else if (o[i] instanceof Double)\n          sb.append(cs.internalsprintf(\n          ((Double)o[i]).doubleValue()));\n        else if (o[i] instanceof Character)\n          sb.append(cs.internalsprintf(\n          ((Character)o[i]).charValue()));\n        else if (o[i] instanceof String)\n          sb.append(cs.internalsprintf(\n          (String)o[i]));\n        else\n          sb.append(cs.internalsprintf(\n          o[i]));\n        if (!cs.isPositionalSpecification())\n          i++;\n      }\n    }\n    return sb.toString();\n  }"}, {"signature": "public String sprintf()", "full": "public String sprintf() {\n    Enumeration e = vFmt.elements();\n    ConversionSpecification cs = null;\n    char c = 0;\n    StringBuffer sb=new StringBuffer();\n    while (e.hasMoreElements()) {\n      cs = (ConversionSpecification)\n        e.nextElement();\n      c = cs.getConversionCharacter();\n      if (c=='\\0') sb.append(cs.getLiteral());\n      else if (c=='%') sb.append(\"%\");\n    }\n    return sb.toString();\n  }"}], "class_attributes": [{"type": "Vector", "name": "vFmt"}, {"type": "int", "name": "cPos"}, {"type": "DecimalFormatSymbols", "name": "dfs"}]}
{"id": 5760917, "class_signatures": "public class LogTypes", "class_methods": [{"signature": "public LogTypes(final JMenu menu, final int selectedIndex)", "full": "public LogTypes(final JMenu menu, final int selectedIndex) {\n        final ButtonGroup logFileGroup = new ButtonGroup();\n        logFileGroup.add(logRadio);\n        logFileGroup.add(txtRadio);\n        logFileGroup.add(csvRadio);\n        logFileGroup.add(yamlRadio);\n\n        menu.add(logRadio);\n        menu.add(txtRadio);\n        menu.add(csvRadio);\n        menu.add(yamlRadio);\n\n        logRadio.setBackground(WHITE);\n        txtRadio.setBackground(WHITE);\n        csvRadio.setBackground(WHITE);\n        yamlRadio.setBackground(WHITE);\n\n        if (selectedIndex < 0 || selectedIndex > 3) {\n            throw new RuntimeException(format(\"Log type index %s out of bounds\", selectedIndex));\n        }\n        selectLogType(selectedIndex);\n    }"}, {"signature": "public int getSelectedIndex()", "full": "public int getSelectedIndex() {\n        if (logRadio.isSelected()) {\n            return 0;\n        }\n        if (txtRadio.isSelected()) {\n            return 1;\n        }\n        if (csvRadio.isSelected()) {\n            return 2;\n        }\n        if (yamlRadio.isSelected()) {\n            return 3;\n        } else {\n            throw new RuntimeException(\"No log type selected\");\n        }\n    }"}, {"signature": "void selectLogType(int index)", "full": "void selectLogType(int index) {\n        switch (index) {\n            case 0:\n                logRadio.setSelected(true);\n                break;\n            case 1:\n                txtRadio.setSelected(true);\n                break;\n            case 2:\n                csvRadio.setSelected(true);\n                break;\n            case 3:\n                yamlRadio.setSelected(true);\n                break;\n            default:\n                throw new RuntimeException(format(\"Log type index %s out of bounds\", index));\n        }\n    }"}, {"signature": "public boolean isEventSource(final FocusEvent event)", "full": "public boolean isEventSource(final FocusEvent event) {\n        final Object source = event.getSource();\n        return source == logRadio || source == txtRadio || source == csvRadio || source == yamlRadio;\n    }"}, {"signature": "public void addItemListener(final ItemListener listener)", "full": "public void addItemListener(final ItemListener listener) {\n        logRadio.addItemListener(listener);\n        txtRadio.addItemListener(listener);\n        csvRadio.addItemListener(listener);\n        yamlRadio.addItemListener(listener);\n    }"}, {"signature": "JRadioButtonMenuItem getLogRadio()", "full": "JRadioButtonMenuItem getLogRadio() {\n        return logRadio;\n    }"}, {"signature": "JRadioButtonMenuItem getTxtRadio()", "full": "JRadioButtonMenuItem getTxtRadio() {\n        return txtRadio;\n    }"}, {"signature": "JRadioButtonMenuItem getCsvRadio()", "full": "JRadioButtonMenuItem getCsvRadio() {\n        return csvRadio;\n    }"}, {"signature": "JRadioButtonMenuItem getYamlRadio() \n}", "full": "JRadioButtonMenuItem getYamlRadio() {\n        return yamlRadio;\n    }\n}"}], "class_attributes": [{"type": "JRadioButtonMenuItem", "name": "logRadio"}, {"type": "JRadioButtonMenuItem", "name": "txtRadio"}, {"type": "JRadioButtonMenuItem", "name": "csvRadio"}, {"type": "JRadioButtonMenuItem", "name": "yamlRadio"}]}
{"id": 5874750, "class_signatures": "KafkaMetrics implements MeterBinder, AutoCloseable", "class_methods": [{"signature": "KafkaMetrics(Supplier<Map<MetricName, ? extends Metric>> metricsSupplier)", "full": "KafkaMetrics(Supplier<Map<MetricName, ? extends Metric>> metricsSupplier) {\n        this(metricsSupplier, emptyList());\n    }"}, {"signature": "KafkaMetrics(Supplier<Map<MetricName, ? extends Metric>> metricsSupplier, Iterable<Tag> extraTags)", "full": "KafkaMetrics(Supplier<Map<MetricName, ? extends Metric>> metricsSupplier, Iterable<Tag> extraTags) {\n        this(metricsSupplier, extraTags, DEFAULT_REFRESH_INTERVAL);\n    }"}, {"signature": "KafkaMetrics(Supplier<Map<MetricName, ? extends Metric>> metricsSupplier, Iterable<Tag> extraTags, Duration refreshInterval)", "full": "KafkaMetrics(Supplier<Map<MetricName, ? extends Metric>> metricsSupplier, Iterable<Tag> extraTags, Duration refreshInterval) {\n        this.metricsSupplier = metricsSupplier;\n        this.extraTags = extraTags;\n        this.refreshInterval = refreshInterval;\n    }"}, {"signature": "public void bindTo(MeterRegistry registry)", "full": "@Override\n    public void bindTo(MeterRegistry registry) {\n        this.registry = registry;\n\n        commonTags = getCommonTags(registry);\n        prepareToBindMetrics(registry);\n        checkAndBindMetrics(registry);\n        scheduler.scheduleAtFixedRate(() -> checkAndBindMetrics(registry), getRefreshIntervalInMillis(), getRefreshIntervalInMillis(), TimeUnit.MILLISECONDS);\n    }"}, {"signature": "private Iterable<Tag> getCommonTags(MeterRegistry registry)", "full": "private Iterable<Tag> getCommonTags(MeterRegistry registry) {\n        Meter.Id dummyId = Meter.builder(\"delete.this\", Meter.Type.OTHER, Collections.emptyList()).register(registry).getId();\n        registry.remove(dummyId);\n        return dummyId.getTags();\n    }"}, {"signature": "void prepareToBindMetrics(MeterRegistry registry)", "full": "void prepareToBindMetrics(MeterRegistry registry) {\n        this.metrics.set(this.metricsSupplier.get());\n        Map<MetricName, ? extends Metric> metrics = this.metrics.get();\n        Metric startTime = null;\n\n        for (Map.Entry<MetricName, ? extends Metric> entry : metrics.entrySet()) {\n            MetricName name = entry.getKey();\n            if (METRIC_GROUP_APP_INFO.equals(name.group()))\n                if (VERSION_METRIC_NAME.equals(name.name())) {\n                    kafkaVersion = (String) entry.getValue().metricValue();\n                } else if (START_TIME_METRIC_NAME.equals(name.name())) {\n                    startTime = entry.getValue();\n                }\n        }\n\n        if (startTime != null) {\n            bindMeter(registry, startTime.metricName(), meterName(startTime), meterTags(startTime));\n        }\n    }"}, {"signature": "private long getRefreshIntervalInMillis()", "full": "private long getRefreshIntervalInMillis() {\n        return refreshInterval.toMillis();\n    }"}, {"signature": "void checkAndBindMetrics(MeterRegistry registry)", "full": "void checkAndBindMetrics(MeterRegistry registry) {\n        this.metrics.set(this.metricsSupplier.get());\n        Map<MetricName, ? extends Metric> metrics = this.metrics.get();\n\n        if (!currentMeters.equals(metrics.keySet())) {\n            currentMeters = new HashSet<>(metrics.keySet());\n\n            Map<String, List<Meter>> registryMetersByNames = registry.getMeters().stream()\n                    .collect(Collectors.groupingBy(meter -> meter.getId().getName()));\n\n            metrics.forEach((name, metric) -> {\n                if (!(metric.metricValue() instanceof Number) ||\n                        METRIC_GROUP_APP_INFO.equals(name.group()) ||\n                        METRIC_GROUP_METRICS_COUNT.equals(name.group())) {\n                    return;\n                }\n\n                String meterName = meterName(metric);\n\n                boolean hasLessTags = false;\n                for (Meter other : registryMetersByNames.getOrDefault(meterName, emptyList())) {\n                    List<Tag> tags = other.getId().getTags();\n                    List<Tag> meterTagsWithCommonTags = meterTags(metric, true);\n                    if (tags.size() < meterTagsWithCommonTags.size()) {\n                        registry.remove(other);\n                        registeredMeters.remove(other);\n                    }\n                    else if (tags.size() == meterTagsWithCommonTags.size())\n                        if (tags.containsAll(meterTagsWithCommonTags)) return;\n                        else break;\n                    else hasLessTags = true;\n                }\n                if (hasLessTags) return;\n\n                List<Tag> tags = meterTags(metric);\n                try {\n                    Meter meter = bindMeter(registry, metric.metricName(), meterName, tags);\n                    List<Meter> meters = registryMetersByNames.computeIfAbsent(meterName, k -> new ArrayList<>());\n                    meters.add(meter);\n                }\n                catch (Exception ex) {\n                    String message = ex.getMessage();\n                    if (message != null && message.contains(\"Prometheus requires\")) {\n                        warnThenDebugLogger.log(\"Failed to bind meter: \" + meterName + \" \" + tags\n                                + \". However, this could happen and might be restored in the next refresh.\");\n                    }\n                    else {\n                        log.warn(\"Failed to bind meter: \" + meterName + \" \" + tags + \".\", ex);\n                    }\n                }\n            });\n        }\n    }"}, {"signature": "private Meter bindMeter(MeterRegistry registry, MetricName metricName, String meterName, Iterable<Tag> tags)", "full": "private Meter bindMeter(MeterRegistry registry, MetricName metricName, String meterName, Iterable<Tag> tags) {\n        Meter meter = registerMeter(registry, metricName, meterName, tags);\n        registeredMeters.add(meter);\n        return meter;\n    }"}, {"signature": "private Meter registerMeter(MeterRegistry registry, MetricName metricName, String meterName, Iterable<Tag> tags)", "full": "private Meter registerMeter(MeterRegistry registry, MetricName metricName, String meterName, Iterable<Tag> tags) {\n        if (meterName.endsWith(\"total\") || meterName.endsWith(\"count\")) {\n            return registerCounter(registry, metricName, meterName, tags);\n        } else {\n            return registerGauge(registry, metricName, meterName, tags);\n        }\n    }"}, {"signature": "private Gauge registerGauge(MeterRegistry registry, MetricName metricName, String meterName, Iterable<Tag> tags)", "full": "private Gauge registerGauge(MeterRegistry registry, MetricName metricName, String meterName, Iterable<Tag> tags) {\n        return Gauge.builder(meterName, this.metrics, toMetricValue(metricName))\n                .tags(tags)\n                .description(metricName.description())\n                .register(registry);\n    }"}, {"signature": "private FunctionCounter registerCounter(MeterRegistry registry, MetricName metricName, String meterName, Iterable<Tag> tags)", "full": "private FunctionCounter registerCounter(MeterRegistry registry, MetricName metricName, String meterName, Iterable<Tag> tags) {\n        return FunctionCounter.builder(meterName, this.metrics, toMetricValue(metricName))\n                .tags(tags)\n                .description(metricName.description())\n                .register(registry);\n    }"}, {"signature": "private ToDoubleFunction<AtomicReference<Map<MetricName, ? extends Metric>>> toMetricValue(MetricName metricName)", "full": "private ToDoubleFunction<AtomicReference<Map<MetricName, ? extends Metric>>> toMetricValue(MetricName metricName) {\n        return metricsReference -> toDouble(metricsReference.get().get(metricName));\n    }"}, {"signature": "private double toDouble(@Nullable Metric metric)", "full": "private double toDouble(@Nullable Metric metric) {\n        return (metric != null) ? ((Number) metric.metricValue()).doubleValue() : Double.NaN;\n    }"}, {"signature": "private List<Tag> meterTags(Metric metric, boolean includeCommonTags)", "full": "private List<Tag> meterTags(Metric metric, boolean includeCommonTags) {\n        List<Tag> tags = new ArrayList<>();\n        metric.metricName().tags().forEach((key, value) -> tags.add(Tag.of(key.replaceAll(\"-\", \".\"), value)));\n        tags.add(Tag.of(KAFKA_VERSION_TAG_NAME, kafkaVersion));\n        extraTags.forEach(tags::add);\n        if (includeCommonTags) {\n            commonTags.forEach(tags::add);\n        }\n        return tags;\n    }"}, {"signature": "private List<Tag> meterTags(Metric metric)", "full": "private List<Tag> meterTags(Metric metric) {\n        return meterTags(metric, false);\n    }"}, {"signature": "private String meterName(Metric metric)", "full": "private String meterName(Metric metric) {\n        String name = METRIC_NAME_PREFIX + metric.metricName().group() + \".\" + metric.metricName().name();\n        return name.replaceAll(\"-metrics\", \"\").replaceAll(\"-\", \".\");\n    }"}, {"signature": "public void close() \n}", "full": "@Override\n    public void close() {\n        this.scheduler.shutdownNow();\n\n        for (Meter meter : registeredMeters) {\n            registry.remove(meter);\n        }\n    }\n}"}], "class_attributes": [{"type": "InternalLogger", "name": "log"}, {"type": "WarnThenDebugLogger", "name": "warnThenDebugLogger"}, {"type": "String", "name": "METRIC_NAME_PREFIX"}, {"type": "String", "name": "METRIC_GROUP_APP_INFO"}, {"type": "String", "name": "METRIC_GROUP_METRICS_COUNT"}, {"type": "String", "name": "VERSION_METRIC_NAME"}, {"type": "String", "name": "START_TIME_METRIC_NAME"}, {"type": "Duration", "name": "DEFAULT_REFRESH_INTERVAL"}, {"type": "String", "name": "KAFKA_VERSION_TAG_NAME"}, {"type": "String", "name": "DEFAULT_VALUE"}, {"type": "Supplier", "name": "metricsSupplier"}, {"type": "AtomicReference", "name": "metrics"}, {"type": "Iterable", "name": "extraTags"}, {"type": "Duration", "name": "refreshInterval"}, {"type": "ScheduledExecutorService", "name": "scheduler"}, {"type": "Iterable", "name": "commonTags"}, {"type": "Set", "name": "currentMeters"}, {"type": "String", "name": "kafkaVersion"}, {"type": "MeterRegistry", "name": "registry"}, {"type": "Set", "name": "registeredMeters"}]}
{"id": 5926526, "class_signatures": "public class BankClient", "class_methods": [{"signature": "private BankClient(Bank bank)", "full": "private BankClient(Bank bank)\n    {\n        _bank = bank;\n    }"}, {"signature": "private static int menu()", "full": "private static int menu()\n    {\n        System.out.println(\"\");\n        System.out.println(\"-------------------------------------------------\");\n        System.out.println(\"Bank client \");\n        System.out.println(\"-------------------------------------------------\");\n        System.out.println(\"\");\n        System.out.println(\"Select an option : \");\n        System.out.println(\"\\t0. Quit\");\n        System.out.println(\"\\t1. Create a new account.\");\n        System.out.println(\"\\t2. Get an account information.\");\n        System.out.println(\"\\t3. Make a transfer.\");\n        System.out.println(\"\\t4. Credit an account.\");\n        System.out.println(\"\\t5. Withdraw from an account.\");\n        System.out.println(\"\\t6. Display this menu.\");\n        System.out.println(\"\");\n        System.out.print(\"Your choice : \");\n        String choice = input();\n        if (choice == null)\n            return 0;\n\n        try\n        {\n            return Integer.parseInt(choice);\n        }\n        catch (NumberFormatException e)\n        {\n            return 6;\n        }\n    }"}, {"signature": "private static String input()", "full": "private static String input()\n    {\n        try\n        {\n            java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));\n            return reader.readLine();\n        }\n        catch (IOException ioe)\n        {\n            System.err.println(\"Problem reading from the keyboard, returning null\");\n            }\n        return null;\n    }"}, {"signature": "private void start()", "full": "private void start()\n    {\n        while (true)\n        {\n            switch (menu())\n            {\n                case 0:\n                    System.exit(0);\n                case 1:\n                    newAccount();\n                    break;\n                case 2:\n                    getInfo();\n                    break;\n                case 3:\n                    makeTransfer();\n                    break;\n                case 4:\n                    makeCredit();\n                    break;\n                case 5:\n                    makeWithdraw();\n                    break;\n                case 6:\n                    break;\n            }\n        }\n    }"}, {"signature": "private void newAccount()", "full": "private void newAccount()\n    {\n        System.out.println(\"\");\n        System.out.println(\"- Create a new account -\");\n        System.out.println(\"------------------------\");\n        System.out.println(\"\");\n\n        System.out.print(\"Name : \");\n        String name = input();\n        if (name == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        System.out.print(\"Initial balance : \");\n        String balance = input();\n        if (balance == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        float fbalance = 0;\n        try\n        {\n            fbalance = new Float(balance).floatValue();\n        }\n        catch (java.lang.Exception ex)\n        {\n            System.out.println(\"Invalid float number, abort operation...\");\n            return;\n        }\n\n        try\n        {\n            Current current = OTSManager.get_current();\n            System.out.println(\"Beginning a User transaction to create account\");\n            current.begin();\n            Account acc = _bank.create_account(name);\n            System.out.println(\"Credit the Account\");\n            acc.credit(current.get_control(), fbalance);\n            System.out.println(\"Attempt to commit the account creation transaction\");\n            current.commit(false);\n        }\n        catch (Exception e)\n        {\n            System.err.println(\"ERROR - \" + e);\n        }\n    }"}, {"signature": "private void getInfo()", "full": "private void getInfo()\n    {\n        System.out.println(\"\");\n        System.out.println(\"- Get information about an account -\");\n        System.out.println(\"------------------------------------\");\n        System.out.println(\"\");\n\n        System.out.print(\"Name : \");\n\n        String name = input();\n        if (name == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        try\n        {\n            Current current = OTSManager.get_current();\n            System.out.println(\"Beginning a User transaction to get balance\");\n            current.begin();\n            try\n            {\n                Account acc = _bank.get_account(name);\n                System.out.println(\"Balance : \" + acc.balance(current.get_control()));\n            }\n            catch (NotExistingAccount nea)\n            {\n                System.out.println(\"Account not Found\");\n                current.rollback_only();\n            }\n\n            current.commit(false);\n        }\n        catch (Exception e)\n        {\n            System.err.println(\"ERROR - \" + e);\n        }\n    }"}, {"signature": "private void makeTransfer()", "full": "private void makeTransfer()\n    {\n        System.out.println(\"\");\n        System.out.println(\"- Make a transfer -\");\n        System.out.println(\"-------------------\");\n        System.out.println(\"\");\n\n        System.out.print(\"Take money from : \");\n\n        String name_supplier = input();\n        if (name_supplier == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        System.out.print(\"Put money to : \");\n        String name_consumer = input();\n        if (name_consumer == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        System.out.print(\"Transfer amount : \");\n        String amount = input();\n        if (amount == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        float famount = 0;\n        try\n        {\n            famount = new Float(amount).floatValue();\n        }\n        catch (java.lang.Exception ex)\n        {\n            System.out.println(\"Invalid float number, abort operation...\");\n            return;\n        }\n\n        Current current = null;\n        try\n        {\n            current = OTSManager.get_current();\n            System.out.println(\"Beginning a User transaction to Transfer money\");\n            current.begin();\n            try\n            {\n                Account supplier = _bank.get_account(name_supplier);\n                Account consumer = _bank.get_account(name_consumer);\n\n                supplier.debit(current.get_control(), famount);\n                consumer.credit(current.get_control(), famount);\n            }\n            catch (NotExistingAccount nea)\n            {\n                System.out.println(\"Account not Found\");\n                current.rollback_only();\n            }\n\n            current.commit(false);\n        }\n        catch (Exception e)\n        {\n            System.err.println(\"ERROR - \" + e);\n        }\n    }"}, {"signature": "private void makeCredit()", "full": "private void makeCredit()\n    {\n        System.out.println(\"\");\n        System.out.println(\"- Credit an Account -\");\n        System.out.println(\"-------------------\");\n        System.out.println(\"\");\n\n        System.out.print(\"Give the Account name : \");\n        String name_consumer = input();\n        if (name_consumer == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        System.out.print(\"Amount to credit : \");\n        String amount = input();\n        if (amount == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        float famount = 0;\n        try\n        {\n            famount = new Float(amount).floatValue();\n        }\n        catch (java.lang.Exception ex)\n        {\n            System.out.println(\"Invalid float number, abort operation...\");\n            return;\n        }\n\n        try\n        {\n            Current current = OTSManager.get_current();\n            System.out.println(\"Beginning a User transaction to  credit an account\");\n            current.begin();\n            try\n            {\n                Account consumer = _bank.get_account(name_consumer);\n                consumer.credit(current.get_control(), famount);\n            }\n            catch (NotExistingAccount nea)\n            {\n                System.out.println(\"The requested account does not exist!\");\n                current.rollback_only();\n            }\n\n            current.commit(false);\n        }\n        catch (Exception e)\n        {\n            System.err.println(\"ERROR - \" + e);\n        }\n    }"}, {"signature": "private void makeWithdraw()", "full": "private void makeWithdraw()\n    {\n        System.out.println(\"\");\n        System.out.println(\"- Withrdaw from an Account -\");\n        System.out.println(\"-------------------\");\n        System.out.println(\"\");\n\n        System.out.print(\"Give the Account name : \");\n        String name_debit = input();\n        if (name_debit == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        System.out.print(\"Amount to withdraw : \");\n        String amount = input();\n        if (amount == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        float famount = 0;\n        try\n        {\n            famount = new Float(amount).floatValue();\n        }\n        catch (java.lang.Exception ex)\n        {\n            System.out.println(\"Invalid float number, abort operation...\");\n            return;\n        }\n\n        try\n        {\n            Current current = OTSManager.get_current();\n            System.out.println(\"Beginning a User transaction to withdraw from an account\");\n            current.begin();\n            try\n            {\n                Account debiter = _bank.get_account(name_debit);\n                debiter.debit(current.get_control(), famount);\n            }\n            catch (NotExistingAccount nea)\n            {\n                System.out.println(\"The requested account does not exist!\");\n                current.rollback_only();\n            }\n            current.commit(false);\n        }\n        catch (Exception e)\n        {\n            System.err.println(\"ERROR - \" + e);\n        }\n    }"}, {"signature": "public static void main(String[] args)\n    \n}", "full": "public static void main(String[] args)\n    {\n        ORB myORB = null;\n        RootOA myOA = null;\n        try\n        {\n            myORB = ORB.getInstance(\"ClientSide\");\n            myOA = OA.getRootOA(myORB);\n            myORB.initORB(args, null);\n            myOA.initOA();\n        }\n        catch (Exception e)\n        {\n            System.err.println(\"Trailmap Error: ORB Initialisation failed: \" + e);\n            e.printStackTrace();\n            System.exit(0);\n        }\n\n        Bank bank = null;\n        try\n        {\n            java.io.FileInputStream file = new java.io.FileInputStream(\"ObjectId\");\n            java.io.InputStreamReader input = new java.io.InputStreamReader(file);\n            java.io.BufferedReader reader = new java.io.BufferedReader(input);\n            String stringTarget = reader.readLine();\n\n            org.omg.CORBA.Object obj = myORB.orb().string_to_object(stringTarget);\n            System.out.println(\"Try to convert the obj ref to a Bank object !\");\n            bank = BankHelper.narrow(obj);\n        }\n        catch (java.io.IOException ioe)\n        {\n            System.out.println(\"Trailmap Error: Could not read the IOR of the BankImpl (from file ./ObjectId): \" + ioe);\n            ioe.printStackTrace();\n            System.exit(0);\n        }\n\n        BankClient client = new BankClient(bank);\n\n        client.start();\n    }\n}"}], "class_attributes": [{"type": "Bank", "name": "_bank"}]}
{"id": 5946322, "class_signatures": "public abstract class ServiceStateManager<T extends ServiceState>", "class_methods": [{"signature": "protected ServiceStateManager()", "full": "protected ServiceStateManager()\n    {\n        transactions = new Hashtable<Object, T>();\n        restoreState();\n    }"}, {"signature": "protected void putDerivedState(Object txId, T state)", "full": "protected void putDerivedState(Object txId, T state)\n    {\n        transactions.put(txId, state);\n    }"}, {"signature": "protected T getDerivedState(Object txId)", "full": "protected T getDerivedState(Object txId)\n    {\n        return transactions.get(txId);\n    }"}, {"signature": "protected void removeState(Object txId)", "full": "protected void removeState(Object txId)\n    {\n        transactions.remove(txId);\n    }"}, {"signature": "protected boolean isLocked()", "full": "protected boolean isLocked()\n    {\n        return (preparedTxID != null);\n    }"}, {"signature": "protected Object getLockID()", "full": "protected Object getLockID()\n    {\n        return preparedTxID;\n    }"}, {"signature": "protected boolean isLockID(Object txId)", "full": "protected boolean isLockID(Object txId)\n    {\n        if (preparedTxID != null) {\n            return preparedTxID.equals(txId);\n        } else {\n            return txId == null;\n        }\n    }"}, {"signature": "protected void lock(Object preparedTxID)", "full": "protected void lock(Object preparedTxID)\n    {\n        this.preparedTxID = preparedTxID;\n    }"}, {"signature": "protected void unlock()", "full": "protected void unlock()\n    {\n        this.preparedTxID = null;\n        this.notifyAll();\n    }"}, {"signature": "protected T getPreparedState()", "full": "protected T getPreparedState()\n    {\n        if (preparedTxID != null) {\n            return transactions.get(preparedTxID);\n        }\n        \n        return null;\n    }"}, {"signature": "protected void writeShadowState(Object txId, T childState) throws IOException", "full": "protected void writeShadowState(Object txId, T childState) throws IOException\n    {\n        FileOutputStream fos = null;\n        ObjectOutputStream oos = null;\n        try {\n            fos = new FileOutputStream(getShadowStateFilename());\n            oos = new ObjectOutputStream(fos);\n            oos.writeObject(txId);\n            oos.writeObject(childState);\n        } finally {\n            if (oos != null) {\n                oos.close();\n            } else if (fos != null) {\n                fos.close();\n            }\n        }\n    }"}, {"signature": "protected void clearShadowState(Object txId)", "full": "protected void clearShadowState(Object txId)\n    {\n        File shadowFile = new File(getShadowStateFilename());\n\n        if (shadowFile.exists()) {\n            shadowFile.delete();\n        }\n    }"}, {"signature": "protected void commitShadowState(Object txId)", "full": "protected void commitShadowState(Object txId)\n    {\n        File stateFile = new File(getStateFilename());\n        File shadowFile = new File(getShadowStateFilename());\n        shadowFile.renameTo(stateFile);\n    }"}, {"signature": "private void restoreState()", "full": "private void restoreState()\n    {\n        File file = new File(getStateFilename());\n        File shadowFile = new File(getShadowStateFilename());\n        T current = null;\n        T shadow = null;\n        Object shadowTxId = null;\n\n        FileInputStream fis = null;\n        ObjectInputStream ois = null;\n        if (file.exists()) {\n            try {\n                fis = new FileInputStream(file);\n                ois = new ObjectInputStream(fis);\n                ois.readObject();\n                current = (T) ois.readObject();\n                ois.close();\n            } catch (IOException e) {\n                System.out.println(\"error : unable to read current service state \" + e);\n            } catch (ClassNotFoundException e) {\n                System.out.println(\"error : unknown class reading current service state \" + e);\n            }\n        }\n\n        try {\n            if (ois != null) {\n                ois.close();\n            } else if (fis != null) {\n                fis.close();\n            }\n        } catch (Exception e) {\n            }\n\n        fis = null;\n        ois = null;\n\n        if (shadowFile.exists()) {\n            try {\n                fis = new FileInputStream(shadowFile);\n                ois = new ObjectInputStream(fis);\n                shadowTxId = ois.readObject();\n                shadow = (T) ois.readObject();\n                rollbackPreparedTx = true;\n            } catch (IOException e) {\n                System.out.println(\"error : unable to read shadow restaurant manager state \" + e);\n                shadowTxId = null;\n            } catch (ClassNotFoundException e) {\n                System.out.println(\"error : unknown class reading shadow restaurant manager state \" + e);\n                shadowTxId = null;\n            }\n        }\n\n        try {\n            if (ois != null) {\n                ois.close();\n            } else if (fis != null) {\n                fis.close();\n            }\n        } catch (Exception e) {\n            }\n\n        if (current != null) {\n            if (shadow != null) {\n                assert current.isParentOf(shadow);\n                putDerivedState(shadowTxId, shadow);\n                preparedTxID = shadowTxId;\n            } else {\n                preparedTxID = null;\n            }\n        }\n\n        currentState = current;\n    }"}, {"signature": "protected void clearTransactions()", "full": "protected void clearTransactions() {\n        Enumeration<Object> keys = transactions.keys();\n        while (keys.hasMoreElements()) {\n            Object key = keys.nextElement();\n            transactions.remove(key);\n            System.out.println(\"deleted prepared data for transaction \" + key);\n        }\n    }"}, {"signature": "public boolean recovered(Object txID, int txType)", "full": "public boolean recovered(Object txID, int txType)\n    {\n        if (isLockID(txID)) {\n            rollbackPreparedTx = false;\n            return true;\n        }\n\n        return false;\n    }"}, {"signature": "public void recoveryScanCompleted(int txType)", "full": "public void recoveryScanCompleted(int txType)\n    {\n        completedScans |= txType;\n        \n        if (completedScans == TX_TYPE_BOTH && rollbackPreparedTx) {\n            rollback(getLockID());\n        }\n    }"}, {"signature": "public boolean prepare(Object txID)", "full": "public boolean prepare(Object txID)\n    {\n        T childState = getDerivedState(txID);\n        if (childState == null) {\n            return false;\n        }\n        synchronized (this) {\n            while (isLocked()) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    }\n            }\n\n            if (!currentState.isParentOf(childState)) {\n                removeState(txID);\n                return false;\n            }\n\n            if (!confirmPrepare()) {\n                removeState(txID);\n                return false;\n            }\n\n            lock(txID);\n        }\n        try {\n            writeShadowState(txID, childState);\n            return true;\n        } catch (Exception e) {\n            clearShadowState(txID);\n            synchronized (this) {\n                removeState(txID);\n                unlock();\n            }\n            System.err.println(\"RestaurantManager.prepareSeats(): Error attempting to prepare transaction: \" + e);\n            return false;\n        }\n    }"}, {"signature": "public void commit(Object txID)", "full": "public void commit(Object txID)\n    {\n        synchronized (this) {\n            if (isLockID(txID)) {\n                commitShadowState(txID);\n                currentState = getPreparedState();\n                unlock();\n            }\n            removeState(txID);\n        }\n    }"}, {"signature": "public void rollback(Object txID)", "full": "public void rollback(Object txID)\n    {\n        synchronized (this) {\n            removeState(txID);\n            if (isLockID(txID)) {\n                clearShadowState(txID);\n                unlock();\n            }\n            this.notifyAll();\n        }\n    }"}, {"signature": "public abstract String getStateFilename();", "full": "public abstract String getStateFilename();"}, {"signature": "public abstract String getShadowStateFilename();", "full": "public abstract String getShadowStateFilename();"}, {"signature": "public abstract boolean confirmPrepare();", "full": "public abstract boolean confirmPrepare();"}], "class_attributes": [{"type": "T", "name": "currentState"}, {"type": "Object", "name": "preparedTxID"}, {"type": "Hashtable", "name": "transactions"}, {"type": "int", "name": "completedScans"}, {"type": "boolean", "name": "rollbackPreparedTx"}]}
{"id": 6127949, "class_signatures": "public class PixelCalibration", "class_methods": [{"signature": "private PixelCalibration()", "full": "private PixelCalibration() {}"}, {"signature": "private PixelCalibration duplicate()", "full": "private PixelCalibration duplicate() {\n\t\tvar cal = new PixelCalibration();\n\t\tcal.pixelWidth = new SimpleQuantity(pixelWidth.value, pixelWidth.unit);\n\t\tcal.pixelHeight = new SimpleQuantity(pixelHeight.value, pixelHeight.unit);\n\t\tcal.zSpacing = new SimpleQuantity(zSpacing.value, zSpacing.unit);\n\t\tcal.timeUnit = timeUnit;\n\t\tcal.timepoints = timepoints == null ? null : timepoints.clone();\n\t\treturn cal;\n\t}"}, {"signature": "public PixelCalibration createScaledInstance(double scaleX, double scaleY)", "full": "public PixelCalibration createScaledInstance(double scaleX, double scaleY) {\n\t\treturn createScaledInstance(scaleX, scaleY, 1);\n\t}"}, {"signature": "public PixelCalibration createScaledInstance(double scaleX, double scaleY, double scaleZ)", "full": "public PixelCalibration createScaledInstance(double scaleX, double scaleY, double scaleZ) {\n\t\tPixelCalibration cal2 = duplicate();\n\t\tcal2.pixelWidth = pixelWidth.scale(scaleX);\n\t\tcal2.pixelHeight = pixelHeight.scale(scaleY);\n\t\tcal2.zSpacing = zSpacing.scale(scaleZ);\n\t\treturn cal2;\n\t}"}, {"signature": "private static Number multiply(Number n1, double scale)", "full": "private static Number multiply(Number n1, double scale) {\n\t\tif (n1 instanceof BigInteger)\n\t\t\tn1 = new BigDecimal((BigInteger)n1);\n\t\tif (n1 instanceof BigDecimal)\n\t\t\treturn ((BigDecimal)n1).multiply(BigDecimal.valueOf(scale));\n\t\treturn n1.doubleValue() * scale;\n\t}"}, {"signature": "private static Number average(Number n1, Number n2)", "full": "private static Number average(Number n1, Number n2) {\n\t\tNumber half1 = multiply(n1, 0.5);\n\t\tNumber half2 = multiply(n2, 0.5);\n\t\treturn add(half1, half2);\n\t}"}, {"signature": "private static Number add(Number n1, Number n2)", "full": "private static Number add(Number n1, Number n2) {\n\t\tif (n1 instanceof BigInteger)\n\t\t\tn1 = new BigDecimal((BigInteger)n2);\n\t\tif (n2 instanceof BigInteger)\n\t\t\tn2 = new BigDecimal((BigInteger)n2);\n\t\t\n\t\tif (n1 instanceof BigDecimal && n2 instanceof BigDecimal)\n\t\t\treturn ((BigDecimal)n1).add((BigDecimal)n2);\n\t\treturn n1.doubleValue() + n2.doubleValue();\n\t}"}, {"signature": "public TimeUnit getTimeUnit()", "full": "public TimeUnit getTimeUnit() {\n\t\treturn timeUnit;\n\t}"}, {"signature": "public int nTimepoints()", "full": "public int nTimepoints() {\n\t\treturn timepoints.length;\n\t}"}, {"signature": "public double getTimepoint(int ind)", "full": "public double getTimepoint(int ind) {\n\t\treturn ind >= timepoints.length ? Double.NaN : timepoints[ind];\n\t}"}, {"signature": "public boolean hasPixelSizeMicrons()", "full": "public boolean hasPixelSizeMicrons() {\n\t\treturn MICROMETER.equals(pixelWidth.unit) && MICROMETER.equals(pixelHeight.unit);\n\t}"}, {"signature": "public boolean hasZSpacingMicrons()", "full": "public boolean hasZSpacingMicrons() {\n\t\treturn MICROMETER.equals(zSpacing.unit);\n\t}"}, {"signature": "public double getAveragedPixelSizeMicrons()", "full": "public double getAveragedPixelSizeMicrons() {\n\t\treturn (getPixelWidthMicrons() + getPixelHeightMicrons()) / 2.0;\n\t}"}, {"signature": "public double getZSpacingMicrons()", "full": "public double getZSpacingMicrons() {\n\t\tif (hasZSpacingMicrons())\n\t\t\treturn zSpacing.value.doubleValue();\n\t\treturn Double.NaN;\n\t}"}, {"signature": "public double getPixelWidthMicrons()", "full": "public double getPixelWidthMicrons() {\n\t\tif (hasPixelSizeMicrons())\n\t\t\treturn pixelWidth.value.doubleValue();\n\t\treturn Double.NaN;\n\t}"}, {"signature": "public double getPixelHeightMicrons()", "full": "public double getPixelHeightMicrons() {\n\t\tif (hasPixelSizeMicrons())\n\t\t\treturn pixelHeight.value.doubleValue();\n\t\treturn Double.NaN;\n\t}"}, {"signature": "public String getPixelWidthUnit()", "full": "public String getPixelWidthUnit() {\n\t\treturn pixelWidth.unit;\n\t}"}, {"signature": "public boolean unitsMatch2D()", "full": "public boolean unitsMatch2D() {\n\t\treturn Objects.equals(getPixelHeightUnit(), getPixelHeightUnit());\n\t}"}, {"signature": "public boolean unitsMatch3D()", "full": "public boolean unitsMatch3D() {\n\t\treturn unitsMatch2D() && Objects.equals(getPixelHeightUnit(), getZSpacingUnit());\n\t}"}, {"signature": "public String getPixelHeightUnit()", "full": "public String getPixelHeightUnit() {\n\t\treturn pixelHeight.unit;\n\t}"}, {"signature": "public String getZSpacingUnit()", "full": "public String getZSpacingUnit() {\n\t\treturn zSpacing.unit;\n\t}"}, {"signature": "public Number getAveragedPixelSize()", "full": "public Number getAveragedPixelSize() {\n\t\treturn average(getPixelWidth(), getPixelHeight());\n\t}"}, {"signature": "public Number getPixelWidth()", "full": "public Number getPixelWidth() {\n\t\treturn pixelWidth.value;\n\t}"}, {"signature": "public Number getPixelHeight()", "full": "public Number getPixelHeight() {\n\t\treturn pixelHeight.value;\n\t}"}, {"signature": "public Number getZSpacing()", "full": "public Number getZSpacing() {\n\t\treturn zSpacing.value;\n\t}"}, {"signature": "public String toString()", "full": "@Override\n\tpublic String toString() {\n\t\treturn String.format(\"Pixel calibration: x=%s, y=%s, z=%s, t=%s\",\n\t\t\t\tpixelWidth.toString(), pixelHeight.toString(), zSpacing.toString(), timeUnit.toString());\n\t}"}, {"signature": "public static PixelCalibration getDefaultInstance()", "full": "public static PixelCalibration getDefaultInstance() {\n\t\treturn DEFAULT_INSTANCE;\n\t}"}, {"signature": "public int hashCode()", "full": "@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((pixelHeight == null) ? 0 : pixelHeight.hashCode());\n\t\tresult = prime * result + ((pixelWidth == null) ? 0 : pixelWidth.hashCode());\n\t\tresult = prime * result + ((timeUnit == null) ? 0 : timeUnit.hashCode());\n\t\tresult = prime * result + Arrays.hashCode(timepoints);\n\t\tresult = prime * result + ((zSpacing == null) ? 0 : zSpacing.hashCode());\n\t\treturn result;\n\t}"}, {"signature": "public boolean equals(Object obj) \n\t\n\n}", "full": "@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPixelCalibration other = (PixelCalibration) obj;\n\t\tif (pixelHeight == null) {\n\t\t\tif (other.pixelHeight != null)\n\t\t\t\treturn false;\n\t\t} else if (!pixelHeight.equals(other.pixelHeight))\n\t\t\treturn false;\n\t\tif (pixelWidth == null) {\n\t\t\tif (other.pixelWidth != null)\n\t\t\t\treturn false;\n\t\t} else if (!pixelWidth.equals(other.pixelWidth))\n\t\t\treturn false;\n\t\tif (timeUnit != other.timeUnit)\n\t\t\treturn false;\n\t\tif (!Arrays.equals(timepoints, other.timepoints))\n\t\t\treturn false;\n\t\tif (zSpacing == null) {\n\t\t\tif (other.zSpacing != null)\n\t\t\t\treturn false;\n\t\t} else if (!zSpacing.equals(other.zSpacing))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\n}"}], "class_attributes": [{"type": "String", "name": "PIXEL"}, {"type": "String", "name": "MICROMETER"}, {"type": "String", "name": "Z_SLICE"}, {"type": "SimpleQuantity", "name": "pixelWidth"}, {"type": "SimpleQuantity", "name": "pixelHeight"}, {"type": "SimpleQuantity", "name": "zSpacing"}, {"type": "TimeUnit", "name": "timeUnit"}, {"type": "double", "name": "timepoints"}, {"type": "PixelCalibration", "name": "DEFAULT_INSTANCE"}]}
{"id": 6367455, "class_signatures": "public class CurrencyRateController extends BaseController", "class_methods": [{"signature": "public Map<String, Object> getCurrencyRate(\n        @ApiParam(required = true, value = \"\u00e7\u0089\u0088\u00e6\u009c\u00ac\", defaultValue = \"v1\") @PathVariable(\"version\") String version\n    ) \n\n}", "full": "@GetMapping(value = \"/rate/all\", produces = \"application/json; charset=UTF-8\")\n    @ApiOperation(value = \"\u00e8\u008e\u00b7\u00e5\u008f\u0096USD\u00e5\u00af\u00b9\u00e5\u00ba\u0094\u00e6\u00b1\u0087\u00e7\u008e\u0087\")\n    public Map<String, Object> getCurrencyRate(\n        @ApiParam(required = true, value = \"\u00e7\u0089\u0088\u00e6\u009c\u00ac\", defaultValue = \"v1\") @PathVariable(\"version\") String version\n    ) {\n        Map<String, String> rate = currencyRateService.getRate();\n        Map<String, Object> message = new HashMap<>();\n        message.put(Message.RETURN_FIELD_CODE, ReturnCode.SUCCESS);\n        message.put(Message.RETURN_FIELD_DATA, rate);\n        return message;\n    }\n\n}"}], "class_attributes": [{"type": "ICurrencyRateService", "name": "currencyRateService"}]}
{"id": 7037335, "class_signatures": "public class ResourceArrayPropertyEditor extends PropertyEditorSupport", "class_methods": [{"signature": "public ResourceArrayPropertyEditor()", "full": "public ResourceArrayPropertyEditor() {\n\t\tthis(new PathMatchingResourcePatternResolver(), null, true);\n\t}"}, {"signature": "public ResourceArrayPropertyEditor(\n\t\t\tResourcePatternResolver resourcePatternResolver, @Nullable PropertyResolver propertyResolver)", "full": "public ResourceArrayPropertyEditor(\n\t\t\tResourcePatternResolver resourcePatternResolver, @Nullable PropertyResolver propertyResolver) {\n\n\t\tthis(resourcePatternResolver, propertyResolver, true);\n\t}"}, {"signature": "public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,\n\t\t\t@Nullable PropertyResolver propertyResolver, boolean ignoreUnresolvablePlaceholders)", "full": "public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,\n\t\t\t@Nullable PropertyResolver propertyResolver, boolean ignoreUnresolvablePlaceholders) {\n\n\t\tAssert.notNull(resourcePatternResolver, \"ResourcePatternResolver must not be null\");\n\t\tthis.resourcePatternResolver = resourcePatternResolver;\n\t\tthis.propertyResolver = propertyResolver;\n\t\tthis.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;\n\t}"}, {"signature": "public void setAsText(String text)", "full": "@Override\n\tpublic void setAsText(String text) {\n\t\tString pattern = resolvePath(text).trim();\n\t\ttry {\n\t\t\tsetValue(this.resourcePatternResolver.getResources(pattern));\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Could not resolve resource location pattern [\" + pattern + \"]: \" + ex.getMessage());\n\t\t}\n\t}"}, {"signature": "public void setValue(Object value) throws IllegalArgumentException", "full": "@Override\n\tpublic void setValue(Object value) throws IllegalArgumentException {\n\t\tif (value instanceof Collection || (value instanceof Object[] && !(value instanceof Resource[]))) {\n\t\t\tCollection<?> input = (value instanceof Collection ? (Collection<?>) value : Arrays.asList((Object[]) value));\n\t\t\tList<Resource> merged = new ArrayList<>();\n\t\t\tfor (Object element : input) {\n\t\t\t\tif (element instanceof String) {\n\t\t\t\t\tString pattern = resolvePath((String) element).trim();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tResource[] resources = this.resourcePatternResolver.getResources(pattern);\n\t\t\t\t\t\tfor (Resource resource : resources) {\n\t\t\t\t\t\t\tif (!merged.contains(resource)) {\n\t\t\t\t\t\t\t\tmerged.add(resource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Could not retrieve resources for pattern '\" + pattern + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (element instanceof Resource) {\n\t\t\t\t\tResource resource = (Resource) element;\n\t\t\t\t\tif (!merged.contains(resource)) {\n\t\t\t\t\t\tmerged.add(resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot convert element [\" + element + \"] to [\" +\n\t\t\t\t\t\t\tResource.class.getName() + \"]: only location String and Resource object supported\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuper.setValue(merged.toArray(new Resource[0]));\n\t\t}\n\n\t\telse {\n\t\t\tsuper.setValue(value);\n\t\t}\n\t}"}, {"signature": "protected String resolvePath(String path) \n\n}", "full": "protected String resolvePath(String path) {\n\t\tif (this.propertyResolver == null) {\n\t\t\tthis.propertyResolver = new StandardEnvironment();\n\t\t}\n\t\treturn (this.ignoreUnresolvablePlaceholders ? this.propertyResolver.resolvePlaceholders(path) :\n\t\t\t\tthis.propertyResolver.resolveRequiredPlaceholders(path));\n\t}\n\n}"}], "class_attributes": [{"type": "Log", "name": "logger"}, {"type": "ResourcePatternResolver", "name": "resourcePatternResolver"}, {"type": "PropertyResolver", "name": "propertyResolver"}, {"type": "boolean", "name": "ignoreUnresolvablePlaceholders"}]}
{"id": 7051733, "class_signatures": "public abstract class StreamUtils", "class_methods": [{"signature": "public static byte[] copyToByteArray(@Nullable InputStream in) throws IOException", "full": "public static byte[] copyToByteArray(@Nullable InputStream in) throws IOException {\n\t\tif (in == null) {\n\t\t\treturn new byte[0];\n\t\t}\n\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream(BUFFER_SIZE);\n\t\tcopy(in, out);\n\t\treturn out.toByteArray();\n\t}"}, {"signature": "public static String copyToString(@Nullable InputStream in, Charset charset) throws IOException", "full": "public static String copyToString(@Nullable InputStream in, Charset charset) throws IOException {\n\t\tif (in == null) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder out = new StringBuilder();\n\t\tInputStreamReader reader = new InputStreamReader(in, charset);\n\t\tchar[] buffer = new char[BUFFER_SIZE];\n\t\tint bytesRead = -1;\n\t\twhile ((bytesRead = reader.read(buffer)) != -1) {\n\t\t\tout.append(buffer, 0, bytesRead);\n\t\t}\n\t\treturn out.toString();\n\t}"}, {"signature": "public static void copy(byte[] in, OutputStream out) throws IOException", "full": "public static void copy(byte[] in, OutputStream out) throws IOException {\n\t\tAssert.notNull(in, \"No input byte array specified\");\n\t\tAssert.notNull(out, \"No OutputStream specified\");\n\n\t\tout.write(in);\n\t}"}, {"signature": "public static void copy(String in, Charset charset, OutputStream out) throws IOException", "full": "public static void copy(String in, Charset charset, OutputStream out) throws IOException {\n\t\tAssert.notNull(in, \"No input String specified\");\n\t\tAssert.notNull(charset, \"No charset specified\");\n\t\tAssert.notNull(out, \"No OutputStream specified\");\n\n\t\tWriter writer = new OutputStreamWriter(out, charset);\n\t\twriter.write(in);\n\t\twriter.flush();\n\t}"}, {"signature": "public static int copy(InputStream in, OutputStream out) throws IOException", "full": "public static int copy(InputStream in, OutputStream out) throws IOException {\n\t\tAssert.notNull(in, \"No InputStream specified\");\n\t\tAssert.notNull(out, \"No OutputStream specified\");\n\n\t\tint byteCount = 0;\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\tint bytesRead = -1;\n\t\twhile ((bytesRead = in.read(buffer)) != -1) {\n\t\t\tout.write(buffer, 0, bytesRead);\n\t\t\tbyteCount += bytesRead;\n\t\t}\n\t\tout.flush();\n\t\treturn byteCount;\n\t}"}, {"signature": "public static long copyRange(InputStream in, OutputStream out, long start, long end) throws IOException", "full": "public static long copyRange(InputStream in, OutputStream out, long start, long end) throws IOException {\n\t\tAssert.notNull(in, \"No InputStream specified\");\n\t\tAssert.notNull(out, \"No OutputStream specified\");\n\n\t\tlong skipped = in.skip(start);\n\t\tif (skipped < start) {\n\t\t\tthrow new IOException(\"Skipped only \" + skipped + \" bytes out of \" + start + \" required\");\n\t\t}\n\n\t\tlong bytesToCopy = end - start + 1;\n\t\tbyte[] buffer = new byte[StreamUtils.BUFFER_SIZE];\n\t\twhile (bytesToCopy > 0) {\n\t\t\tint bytesRead = in.read(buffer);\n\t\t\tif (bytesRead == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (bytesRead <= bytesToCopy) {\n\t\t\t\tout.write(buffer, 0, bytesRead);\n\t\t\t\tbytesToCopy -= bytesRead;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.write(buffer, 0, (int) bytesToCopy);\n\t\t\t\tbytesToCopy = 0;\n\t\t\t}\n\t\t}\n\t\treturn (end - start + 1 - bytesToCopy);\n\t}"}, {"signature": "public static int drain(InputStream in) throws IOException", "full": "public static int drain(InputStream in) throws IOException {\n\t\tAssert.notNull(in, \"No InputStream specified\");\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\tint bytesRead = -1;\n\t\tint byteCount = 0;\n\t\twhile ((bytesRead = in.read(buffer)) != -1) {\n\t\t\tbyteCount += bytesRead;\n\t\t}\n\t\treturn byteCount;\n\t}"}, {"signature": "public static InputStream emptyInput()", "full": "public static InputStream emptyInput() {\n\t\treturn new ByteArrayInputStream(EMPTY_CONTENT);\n\t}"}, {"signature": "public static InputStream nonClosing(InputStream in)", "full": "public static InputStream nonClosing(InputStream in) {\n\t\tAssert.notNull(in, \"No InputStream specified\");\n\t\treturn new NonClosingInputStream(in);\n\t}"}, {"signature": "public static OutputStream nonClosing(OutputStream out)", "full": "public static OutputStream nonClosing(OutputStream out) {\n\t\tAssert.notNull(out, \"No OutputStream specified\");\n\t\treturn new NonClosingOutputStream(out);\n\t}"}], "class_attributes": [{"type": "int", "name": "BUFFER_SIZE"}, {"type": "byte", "name": "EMPTY_CONTENT"}]}
{"id": 7437666, "class_signatures": "public class DefaultServiceConfig", "class_methods": [{"signature": "public DefaultServiceConfig()", "full": "public DefaultServiceConfig() {\n        System.setProperty(\"http.maxConnections\", \"300\");\n    }"}, {"signature": "public RestTemplate northboundRestTemplate(\n            @Value(\"${northbound.endpoint}\") String endpoint,\n            @Value(\"${northbound.username}\") String username,\n            @Value(\"${northbound.password}\") String password)", "full": "@Bean(name = \"northboundRestTemplate\")\n    public RestTemplate northboundRestTemplate(\n            @Value(\"${northbound.endpoint}\") String endpoint,\n            @Value(\"${northbound.username}\") String username,\n            @Value(\"${northbound.password}\") String password) {\n        RestTemplate restTemplate = buildRestTemplateWithAuth(endpoint, username, password);\n        restTemplate.getInterceptors().add(plusEncoderInterceptor());\n        return restTemplate;\n    }"}, {"signature": "public RestTemplate floodlightRestTemplate(\n            @Value(\"#{'${floodlight.endpoints}'.split(',')[0]}\") String endpoint,\n            @Value(\"${floodlight.username}\") String username,\n            @Value(\"${floodlight.password}\") String password)", "full": "@Bean(name = \"floodlightRestTemplate\")\n    public RestTemplate floodlightRestTemplate(\n            @Value(\"#{'${floodlight.endpoints}'.split(',')[0]}\") String endpoint,\n            @Value(\"${floodlight.username}\") String username,\n            @Value(\"${floodlight.password}\") String password) {\n        return buildRestTemplateWithAuth(endpoint, username, password);\n    }"}, {"signature": "public RestTemplate elasticSearchRestTemplate(\n            @Value(\"${elasticsearch.endpoint}\") String endpoint,\n            @Value(\"${elasticsearch.username}\") String username,\n            @Value(\"${elasticsearch.password}\") String password)", "full": "@Bean(name = \"elasticSearchRestTemplate\")\n    public RestTemplate elasticSearchRestTemplate(\n            @Value(\"${elasticsearch.endpoint}\") String endpoint,\n            @Value(\"${elasticsearch.username}\") String username,\n            @Value(\"${elasticsearch.password}\") String password) {\n        return buildRestTemplateWithAuth(endpoint, username, password);\n    }"}, {"signature": "public RestTemplate traffExamRestTemplate()", "full": "@Bean(name = \"traffExamRestTemplate\")\n    public RestTemplate traffExamRestTemplate() {\n        return buildLoggingRestTemplate();\n    }"}, {"signature": "public Map<String, RestTemplate> lockKeeperRestTemplates(\n            @Value(\"${lockkeeper.port}\") Integer lockKeeperPort,\n            @Value(\"#{'${floodlight.regions}'.split(',')}\") List<String> regions,\n            @Value(\"#{'${floodlight.endpoints}'.split(',')}\") List<String> flEndpoints)", "full": "@Bean(name = \"lockKeeperRestTemplates\")\n    public Map<String, RestTemplate> lockKeeperRestTemplates(\n            @Value(\"${lockkeeper.port}\") Integer lockKeeperPort,\n            @Value(\"#{'${floodlight.regions}'.split(',')}\") List<String> regions,\n            @Value(\"#{'${floodlight.endpoints}'.split(',')}\") List<String> flEndpoints) {\n        Map<String, RestTemplate> result = new HashMap<>();\n        for (int i = 0; i < flEndpoints.size(); i++) {\n            String lockKeeperEndpoint = flEndpoints.get(i)\n                    .replaceFirst(\"(.*):\\\\d+\", \"$1:\" + lockKeeperPort);\n            result.put(regions.get(i), buildLoggingRestTemplate(lockKeeperEndpoint));\n        }\n        return result;\n    }"}, {"signature": "public List<Floodlight> floodlights(@Value(\"#{'${floodlight.openflows}'.split(',')}\") List<String> openflows,\n                                        @Value(\"#{'${floodlight.endpoints}'.split(',')}\") List<String> endpoints,\n                                        @Value(\"#{'${floodlight.containers}'.split(',')}\") List<String> containers,\n                                        @Value(\"#{'${floodlight.regions}'.split(',')}\") List<String> regions,\n                                        @Value(\"#{'${floodlight.modes}'.split(',')}\") List<String> modes,\n                                        @Autowired TopologyDefinition topo)", "full": "@Bean\n    @Scope(SCOPE_PROTOTYPE)\n    public List<Floodlight> floodlights(@Value(\"#{'${floodlight.openflows}'.split(',')}\") List<String> openflows,\n                                        @Value(\"#{'${floodlight.endpoints}'.split(',')}\") List<String> endpoints,\n                                        @Value(\"#{'${floodlight.containers}'.split(',')}\") List<String> containers,\n                                        @Value(\"#{'${floodlight.regions}'.split(',')}\") List<String> regions,\n                                        @Value(\"#{'${floodlight.modes}'.split(',')}\") List<String> modes,\n                                        @Autowired TopologyDefinition topo) {\n        if (openflows.size() != endpoints.size() || openflows.size() != containers.size()\n                || openflows.size() != regions.size() || openflows.size() != modes.size()) {\n            throw new IllegalArgumentException(\"Floodlight test properties are illegal. Sizes of floodlight.openflows,\"\n                    + \" floodlight.endpoints, floodlight.containers, floodlight.regions, floodlight.modes should be \"\n                    + \"equal\");\n        }\n        List<Floodlight> floodlights = new ArrayList<>();\n        for (int i = 0; i < regions.size(); i++) {\n            floodlights.add(new Floodlight(openflows.get(i), containers.get(i), regions.get(i),\n                    new IslandFloodlightService(endpoints.get(i), topo),\n                    EnumUtils.getEnumIgnoreCase(FloodlightConnectMode.class, modes.get(i))));\n        }\n        return floodlights;\n    }"}, {"signature": "public RestTemplate otsdbRestTemplate(@Value(\"${opentsdb.endpoint}\") String endpoint)", "full": "@Bean(name = \"otsdbRestTemplate\")\n    public RestTemplate otsdbRestTemplate(@Value(\"${opentsdb.endpoint}\") String endpoint) {\n        return buildLoggingRestTemplate(endpoint);\n    }"}, {"signature": "public RestTemplate labApiRestTemplate(@Value(\"${lab-api.endpoint}\") String endpoint)", "full": "@Bean(name = \"labApiRestTemplate\")\n    public RestTemplate labApiRestTemplate(@Value(\"${lab-api.endpoint}\") String endpoint) {\n        return buildLoggingRestTemplate(endpoint);\n    }"}, {"signature": "public RestTemplate grpcRestTemplate(\n            @Value(\"${grpc.endpoint}\") String endpoint,\n            @Value(\"${grpc.username}\") String username,\n            @Value(\"${grpc.password}\") String password)", "full": "@Bean(name = \"grpcRestTemplate\")\n    public RestTemplate grpcRestTemplate(\n            @Value(\"${grpc.endpoint}\") String endpoint,\n            @Value(\"${grpc.username}\") String username,\n            @Value(\"${grpc.password}\") String password) {\n        return buildRestTemplateWithAuth(endpoint, username, password);\n    }"}, {"signature": "public static RestTemplate buildLoggingRestTemplate(String endpoint)", "full": "public static RestTemplate buildLoggingRestTemplate(String endpoint) {\n        final RestTemplate restTemplate = buildLoggingRestTemplate();\n        restTemplate.setUriTemplateHandler(new DefaultUriBuilderFactory(endpoint));\n        return restTemplate;\n    }"}, {"signature": "public static RestTemplate buildLoggingRestTemplate()", "full": "public static RestTemplate buildLoggingRestTemplate() {\n        final RestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(\n                new HttpComponentsClientHttpRequestFactory()));\n        List<ClientHttpRequestInterceptor> interceptors = restTemplate.getInterceptors();\n        interceptors.add(new LoggingRequestInterceptor());\n        restTemplate.setErrorHandler(new ExtendedErrorHandler());\n        return restTemplate;\n    }"}, {"signature": "public static RestTemplate buildRestTemplateWithAuth(String endpoint, String username, String password)", "full": "public static RestTemplate buildRestTemplateWithAuth(String endpoint, String username, String password) {\n        RestTemplate restTemplate = buildLoggingRestTemplate(endpoint);\n        restTemplate.getInterceptors().add(new BasicAuthorizationInterceptor(username, password));\n        return restTemplate;\n    }"}, {"signature": "private ClientHttpRequestInterceptor plusEncoderInterceptor() \n}", "full": "private ClientHttpRequestInterceptor plusEncoderInterceptor() {\n        return new ClientHttpRequestInterceptor() {\n            @Override\n            public ClientHttpResponse intercept(HttpRequest request, byte[] body,\n                                                ClientHttpRequestExecution execution) throws IOException {\n                return execution.execute(new HttpRequestWrapper(request) {\n                    @Override\n                    public URI getURI() {\n                        URI uri = super.getURI();\n                        String escapedQuery = StringUtils.replace(uri.getRawQuery(), \"+\", \"%2B\");\n                        return UriComponentsBuilder.fromUri(uri)\n                                .replaceQuery(escapedQuery)\n                                .build(true).toUri();\n                    }\n                }, body);\n            }\n        };\n    }\n}"}], "class_attributes": []}
{"id": 7584847, "class_signatures": "final class HuffmanDecoder", "class_methods": [{"signature": "HuffmanDecoder(int[] codes, byte[] lengths)", "full": "HuffmanDecoder(int[] codes, byte[] lengths) {\n    if (codes.length != 257 || codes.length != lengths.length) {\n      throw new IllegalArgumentException(\"invalid Huffman coding\");\n    }\n    root = buildTree(codes, lengths);\n  }"}, {"signature": "public byte[] decode(byte[] buf) throws IOException", "full": "public byte[] decode(byte[] buf) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n    Node node = root;\n    int current = 0;\n    int bits = 0;\n    for (int i = 0; i < buf.length; i++) {\n      int b = buf[i] & 0xFF;\n      current = (current << 8) | b;\n      bits += 8;\n      while (bits >= 8) {\n        int c = (current >>> (bits - 8)) & 0xFF;\n        node = node.children[c];\n        bits -= node.bits;\n        if (node.isTerminal()) {\n          if (node.symbol == HpackUtil.HUFFMAN_EOS) {\n            throw EOS_DECODED;\n          }\n          baos.write(node.symbol);\n          node = root;\n        }\n      }\n    }\n\n    while (bits > 0) {\n      int c = (current << (8 - bits)) & 0xFF;\n      node = node.children[c];\n      if (node.isTerminal() && node.bits <= bits) {\n        bits -= node.bits;\n        baos.write(node.symbol);\n        node = root;\n      } else {\n        break;\n      }\n    }\n\n    int mask = (1 << bits) - 1;\n    if ((current & mask) != mask) {\n      throw INVALID_PADDING;\n    }\n\n    return baos.toByteArray();\n  }"}, {"signature": "private static Node buildTree(int[] codes, byte[] lengths)", "full": "private static Node buildTree(int[] codes, byte[] lengths) {\n    Node root = new Node();\n    for (int i = 0; i < codes.length; i++) {\n      insert(root, i, codes[i], lengths[i]);\n    }\n    return root;\n  }"}, {"signature": "private static void insert(Node root, int symbol, int code, byte length) \n}", "full": "private static void insert(Node root, int symbol, int code, byte length) {\n    Node current = root;\n    while (length > 8) {\n      if (current.isTerminal()) {\n        throw new IllegalStateException(\"invalid Huffman code: prefix not unique\");\n      }\n      length -= 8;\n      int i = (code >>> length) & 0xFF;\n      if (current.children[i] == null) {\n        current.children[i] = new Node();\n      }\n      current = current.children[i];\n    }\n\n    Node terminal = new Node(symbol, length);\n    int shift = 8 - length;\n    int start = (code << shift) & 0xFF;\n    int end = 1 << shift;\n    for (int i = start; i < start + end; i++) {\n      current.children[i] = terminal;\n    }\n  }\n}"}], "class_attributes": [{"type": "IOException", "name": "EOS_DECODED"}, {"type": "IOException", "name": "INVALID_PADDING"}, {"type": "Node", "name": "root"}]}
{"id": 8901418, "class_signatures": "public class XMeans \n  extends RandomizableClusterer\n  implements TechnicalInformationHandler", "class_methods": [{"signature": "public XMeans()", "full": "public XMeans() {\n    super();\n    \n    m_SeedDefault = 10;\n    setSeed(m_SeedDefault);\n  }"}, {"signature": "protected boolean stopIteration(int iterationCount, int max)", "full": "protected boolean stopIteration(int iterationCount, int max) {\n    boolean stopIterate = false;\n    if (max >= 0) \n      stopIterate = (iterationCount >= max);\n    return stopIterate;\n  }"}, {"signature": "public void setCutOffFactor(double i)", "full": "public void setCutOffFactor(double i) {\n    m_CutOffFactor = i;\n  }"}, {"signature": "protected double[] distortion(int[][] instOfCent, Instances centers)", "full": "protected double[] distortion(int[][] instOfCent, Instances centers) {\n    double[] distortion = new double[centers.numInstances()];\n    for (int i = 0; i < centers.numInstances(); i++) {\n      distortion[i] = 0.0;\n      for (int j = 0; j < instOfCent[i].length; j++) {\n        distortion[i] += m_DistanceF.distance(m_Instances\n            .instance(instOfCent[i][j]), centers.instance(i));\n      }\n    }\n    return distortion;\n  }"}, {"signature": "protected int clusterProcessedInstance(Instance instance, Instances centers)", "full": "protected int clusterProcessedInstance(Instance instance, Instances centers) {\n    \n    double minDist = Integer.MAX_VALUE;\n    int bestCluster = 0;\n    for (int i = 0; i < centers.numInstances(); i++) {\n      double dist = m_DistanceF.distance(instance, centers.instance(i));\n\n      if (dist < minDist) {\n        minDist = dist;\n        bestCluster = i;\n      }\n    }\n    ;\n    return bestCluster;\n  }"}, {"signature": "public String globalInfo()", "full": "public String globalInfo() {\n    return \n        \"Cluster data using the X-means algorithm.\\n\\n\" \n      + \"X-Means is K-Means extended by an Improve-Structure part In this \"\n      + \"part of the algorithm the centers are attempted to be split in \"\n      + \"its region. The decision between the children of each center and \"\n      + \"itself is done comparing the BIC-values of the two structures.\\n\\n\"\n      + \"For more information see:\\n\\n\"\n      + getTechnicalInformation().toString();\n  }"}, {"signature": "public TechnicalInformation getTechnicalInformation()", "full": "public TechnicalInformation getTechnicalInformation() {\n    TechnicalInformation \tresult;\n    \n    result = new TechnicalInformation(Type.INPROCEEDINGS);\n    result.setValue(Field.AUTHOR, \"Dan Pelleg and Andrew W. Moore\");\n    result.setValue(Field.TITLE, \"X-means: Extending K-means with Efficient Estimation of the Number of Clusters\");\n    result.setValue(Field.BOOKTITLE, \"Seventeenth International Conference on Machine Learning\");\n    result.setValue(Field.YEAR, \"2000\");\n    result.setValue(Field.PAGES, \"727-734\");\n    result.setValue(Field.PUBLISHER, \"Morgan Kaufmann\");\n    \n    return result;\n  }"}, {"signature": "public Capabilities getCapabilities()", "full": "public Capabilities getCapabilities() {\n    Capabilities result = super.getCapabilities();\n    result.disableAll();\n    result.enable(Capability.NO_CLASS);\n\n    result.enable(Capability.NUMERIC_ATTRIBUTES);\n    result.enable(Capability.DATE_ATTRIBUTES);\n    result.enable(Capability.MISSING_VALUES);\n\n    return result;\n  }"}, {"signature": "public void buildClusterer(Instances data) throws Exception", "full": "public void buildClusterer(Instances data) throws Exception {\n\n    getCapabilities().testWithFail(data);\n    \n    if (m_MinNumClusters > m_MaxNumClusters) {\n      throw new Exception(\"XMeans: min number of clusters \"\n          + \"can't be greater than max number of clusters!\");\n    }\n\n    m_NumSplits = 0;\n    m_NumSplitsDone = 0;\n    m_NumSplitsStillDone = 0;\n\n    m_ReplaceMissingFilter = new ReplaceMissingValues();\n    m_ReplaceMissingFilter.setInputFormat(data);\n    m_Instances = Filter.useFilter(data, m_ReplaceMissingFilter);\n    \n    Random random0 = new Random(m_Seed);\n\n    m_NumClusters =  m_MinNumClusters;\n\n    if (m_DistanceF == null) {\n      m_DistanceF = new EuclideanDistance();\n    }\n\n    m_DistanceF.setInstances(m_Instances);\n    checkInstances();\n\n    if (m_DebugVectorsFile.exists() && m_DebugVectorsFile.isFile())\n      initDebugVectorsInput();\n\n    int[] allInstList = new int[m_Instances.numInstances()]; \n    for (int i = 0; i < m_Instances.numInstances(); i++) {\n      allInstList[i] = i;\n    }\n    \n    m_Model = new Instances(m_Instances, 0);\n\n    if (m_CenterInput != null) {\n      m_ClusterCenters = new Instances(m_CenterInput);\n      m_NumClusters = m_ClusterCenters.numInstances();\n    }\n    else\n      m_ClusterCenters = makeCentersRandomly(random0,\n\t\t\t\t\t     m_Instances, m_NumClusters);\n    PFD(D_FOLLOWSPLIT, \"\\n*** Starting centers \");\n    for (int k = 0; k < m_ClusterCenters.numInstances(); k++) {\n      PFD(D_FOLLOWSPLIT, \"Center \" + k + \": \" + m_ClusterCenters.instance(k));\n    }\n\n    PrCentersFD(D_PRINTCENTERS);\n\n    boolean finished = false;\n    Instances children; \n\n    if (m_UseKDTree)\n      m_KDTree.setInstances(m_Instances);\n  \n    m_IterationCount = 0;\n\n    while (!finished &&\n           !stopIteration(m_IterationCount, m_MaxIterations)) {\n      \n      PFD(D_FOLLOWSPLIT, \"\\nBeginning of main loop - centers:\");\n      PrCentersFD(D_FOLLOWSPLIT);\n\n      PFD(D_ITERCOUNT, \"\\n*** 1. Improve-Params \" + m_IterationCount + \n\t  \". time\");\n      m_IterationCount++;\n\n      boolean converged = false;\n\n      m_ClusterAssignments = initAssignments(m_Instances.numInstances());\n      int[][] instOfCent = new int[m_ClusterCenters.numInstances()][];\n\n      int kMeansIteration = 0;\n\n      PFD(D_FOLLOWSPLIT, \"\\nConverge in K-Means:\");\n      while (!converged && \n\t     !stopKMeansIteration(kMeansIteration, m_MaxKMeans)) {\n\t\n\tkMeansIteration++;\n\tconverged = true;\n\t\n        converged = assignToCenters(m_UseKDTree ? m_KDTree : null,\n\t\t\t\t    m_ClusterCenters, \n\t\t\t\t    instOfCent,\n\t\t\t\t    allInstList, \n\t\t\t\t    m_ClusterAssignments,\n\t\t\t\t    kMeansIteration);\n\t\n\tPFD(D_FOLLOWSPLIT, \"\\nMain loop - Assign - centers:\");\n\tPrCentersFD(D_FOLLOWSPLIT);\n\tconverged = recomputeCenters(m_ClusterCenters, instOfCent,       m_Model);         PFD(D_FOLLOWSPLIT, \"\\nMain loop - Recompute - centers:\");\n      PrCentersFD(D_FOLLOWSPLIT);\n      }\n      PFD(D_FOLLOWSPLIT, \"\");\n      PFD(D_FOLLOWSPLIT, \"End of Part: 1. Improve-Params - conventional K-means\");\n\n      m_Mle = distortion(instOfCent, m_ClusterCenters);\n      m_Bic = calculateBIC(instOfCent, m_ClusterCenters, m_Mle);\n      PFD(D_FOLLOWSPLIT, \"m_Bic \" + m_Bic);\n\n      int currNumCent = m_ClusterCenters.numInstances();\n      Instances splitCenters = new Instances(m_ClusterCenters, \n\t\t\t\t\t     currNumCent * 2);\n      \n      double[] pbic = new double [currNumCent];\n      double[] cbic = new double [currNumCent];\n            \n      for (int i = 0; i < currNumCent \n\t    \n\t   i++) {\n\t\n\tPFD(D_FOLLOWSPLIT, \"\\nsplit center \" + i +\n\t\t      \" \" + m_ClusterCenters.instance(i));\n\tInstance currCenter = m_ClusterCenters.instance(i);\n\tint[] currInstList = instOfCent[i];\n\tint currNumInst = instOfCent[i].length;\n\t\n\tif (currNumInst <= 2) {\n\t  pbic[i] = Double.MAX_VALUE;\n\t  cbic[i] = 0.0;\n\t  splitCenters.add(currCenter);\n\t  splitCenters.add(currCenter);\n\t  continue;\n\t}\n\t\n\tdouble variance = m_Mle[i] / (double)currNumInst;\n\tchildren = splitCenter(random0, currCenter, variance, m_Model);\n\t\n\tint[] oneCentAssignments = initAssignments(currNumInst);\n\tint[][] instOfChCent = new int [2][]; converged = false;\n\tint kMeansForChildrenIteration = 0;\n\tPFD(D_FOLLOWSPLIT, \"\\nConverge, K-Means for children: \" + i);\n\twhile (!converged && \n          !stopKMeansIteration(kMeansForChildrenIteration, \n\t\t\t       m_MaxKMeansForChildren)) {\n\t  kMeansForChildrenIteration++;\n\t  \n\t  converged =\n\t    assignToCenters(children, instOfChCent,\n\t\t\t    currInstList, oneCentAssignments);\n\n\t  if (!converged) {       \n\t    recomputeCentersFast(children, instOfChCent, m_Model);\n\t  }\n\t} \n\n\tsplitCenters.add(children.instance(0));\n\tsplitCenters.add(children.instance(1));\n\n\tPFD(D_FOLLOWSPLIT, \"\\nconverged cildren \");\n\tPFD(D_FOLLOWSPLIT, \" \" + children.instance(0));\n\tPFD(D_FOLLOWSPLIT, \" \" + children.instance(1));\n\n\tpbic[i] = calculateBIC(currInstList, currCenter,  m_Mle[i], m_Model);\n\tdouble[] chMLE = distortion(instOfChCent, children);\n\tcbic[i] = calculateBIC(instOfChCent, children, chMLE);\n\n      } Instances newClusterCenters = null;\n      newClusterCenters = newCentersAfterSplit(pbic, cbic, m_CutOffFactor,\n                                                 splitCenters);\n      int newNumClusters = newClusterCenters.numInstances();\n      if (newNumClusters != m_NumClusters) {\n\t\n\tPFD(D_FOLLOWSPLIT, \"Compare with non-split\");\n\n\tint[] newClusterAssignments = \n\t  initAssignments(m_Instances.numInstances());\n\t\n\tint[][] newInstOfCent = new int[newClusterCenters.numInstances()][];\n\t\n\tconverged = assignToCenters(m_UseKDTree ? m_KDTree : null,\n\t\t\t\t    newClusterCenters, \n\t\t\t\t    newInstOfCent,\n\t\t\t\t    allInstList, \n\t\t\t\t    newClusterAssignments,\n\t\t\t\t    m_IterationCount);\n\t\n\tdouble[] newMle = distortion(newInstOfCent, newClusterCenters);\n\tdouble newBic = calculateBIC(newInstOfCent, newClusterCenters, newMle);\n\tPFD(D_FOLLOWSPLIT, \"newBic \" + newBic);\n\tif (newBic > m_Bic) {\n          PFD(D_FOLLOWSPLIT, \"*** decide for new clusters\");\n\t  m_Bic = newBic;\n\t  m_ClusterCenters = newClusterCenters;\n\t  m_ClusterAssignments = newClusterAssignments;\n\t} else {\n          PFD(D_FOLLOWSPLIT, \"*** keep old clusters\");\n        }\n      }\n\n      newNumClusters = m_ClusterCenters.numInstances();\n      if ((newNumClusters >= m_MaxNumClusters) \n\t  || (newNumClusters == m_NumClusters)) {\n\tfinished = true;\n      }\n      m_NumClusters = newNumClusters;\n    }\n  }"}, {"signature": "public boolean checkForNominalAttributes(Instances data)", "full": "public boolean checkForNominalAttributes(Instances data) {\n\n    int i = 0;\n    while (i < data.numAttributes()) {\n      if ((i != data.classIndex()) && data.attribute(i++).isNominal()) {\n\treturn true;\n      }\n    }\n    return false;\n  }"}, {"signature": "protected int[] initAssignments(int[] ass)", "full": "protected int[] initAssignments(int[] ass) {\n    for (int i = 0; i < ass.length; i++)\n      ass[i] = -1;\n    return ass;\n  }"}, {"signature": "boolean[] initBoolArray(int len)", "full": "boolean[] initBoolArray(int len) {\n    boolean[] boolArray = new boolean [len];\n    for (int i = 0; i < len; i++) {\n      boolArray[i] = false;\n    }\n    return boolArray;\n  }"}, {"signature": "protected Instances newCentersAfterSplit(double[] pbic, \n\t\t\t\t\t double[] cbic,\n\t\t\t\t\t double cutoffFactor,\n\t\t\t\t\t Instances splitCenters)", "full": "protected Instances newCentersAfterSplit(double[] pbic, \n\t\t\t\t\t double[] cbic,\n\t\t\t\t\t double cutoffFactor,\n\t\t\t\t\t Instances splitCenters) {\n\n    boolean splitPerCutoff = false;\n    boolean takeSomeAway = false;\n    boolean[] splitWon = initBoolArray(m_ClusterCenters.numInstances());\n    int numToSplit = 0;\n    Instances newCenters = null;\n    \n    for (int i = 0; i < cbic.length; i++) {\n      if (cbic[i] > pbic[i]) {\n\tsplitWon[i] = true; numToSplit++;\n\tPFD(D_FOLLOWSPLIT, \"Center \" + i + \" decide for children\");\n      }\n      else {\n\tPFD(D_FOLLOWSPLIT, \"Center \" + i + \" decide for parent\");\n      }\n    }\n\n    if ((numToSplit == 0) && (cutoffFactor > 0)) {\n      splitPerCutoff = true;\n      \n      numToSplit = (int) \n        ((double) m_ClusterCenters.numInstances() * m_CutOffFactor); \n    }\n\n    double[] diff = new double [m_NumClusters];\n    for (int j = 0; j < diff.length; j++) {\n      diff[j] = pbic[j] - cbic[j];\n    }    \n    int[] sortOrder = Utils.sort(diff);\n    \n    int possibleToSplit = m_MaxNumClusters - m_NumClusters; \n\n    if (possibleToSplit > numToSplit) {\n      possibleToSplit = numToSplit;\n    }\n    else\n      takeSomeAway = true;\n\n    if (splitPerCutoff) {\n      for (int j = 0; (j < possibleToSplit) && (cbic[sortOrder[j]] > 0.0);\n\t   j++) {\n\tsplitWon[sortOrder[j]] = true;\n      }\n      m_NumSplitsStillDone += possibleToSplit;\n    } \n    else {\n      if (takeSomeAway) {\n\tint count = 0;\n\tint j = 0;\n\tfor (;j < splitWon.length && count < possibleToSplit; j++){\n\t  if (splitWon[sortOrder[j]] == true) count++;\n\t}\n\t\n\twhile (j < splitWon.length) {\n\t  splitWon[sortOrder[j]] = false;\n\t  j++;\n\t}\n      }\n    }\n   \n    if (possibleToSplit > 0) \n      newCenters = newCentersAfterSplit(splitWon, splitCenters);\n    else\n      newCenters = m_ClusterCenters;\n    return newCenters;\n  }"}, {"signature": "protected Instances newCentersAfterSplit(boolean[] splitWon,\n      Instances splitCenters)", "full": "protected Instances newCentersAfterSplit(boolean[] splitWon,\n      Instances splitCenters) {\n    Instances newCenters = new Instances(splitCenters, 0);\n\n    int sIndex = 0;\n    for (int i = 0; i < splitWon.length; i++) {\n      if (splitWon[i]) {\n        m_NumSplitsDone++;\n        newCenters.add(splitCenters.instance(sIndex++));\n        newCenters.add(splitCenters.instance(sIndex++));\n      } else {\n        sIndex++;\n        sIndex++;\n        newCenters.add(m_ClusterCenters.instance(i));\n      }\n    }\n    return newCenters;\n  }"}, {"signature": "protected boolean stopKMeansIteration(int iterationCount, int max)", "full": "protected boolean stopKMeansIteration(int iterationCount, int max) {\n    boolean stopIterate = false;\n    if (max >= 0) \n      stopIterate = (iterationCount >= max);\n    if (stopIterate) \n      m_KMeansStopped++;\n    return stopIterate;\n  }"}, {"signature": "protected boolean recomputeCenters(Instances centers,          \n\t\t\t\t   int[][] instOfCent, \n\t\t\t\t   Instances model)", "full": "protected boolean recomputeCenters(Instances centers,          \n\t\t\t\t   int[][] instOfCent, \n\t\t\t\t   Instances model) {\n    boolean converged = true;\n    \n    for (int i = 0; i < centers.numInstances(); i++) {\n      double val;\n      for (int j = 0; j < model.numAttributes(); j++) {\n\tval = meanOrMode(m_Instances, instOfCent[i], j);\n\n\tfor (int k = 0; k < instOfCent[i].length; k++)\n\n\tif (converged && m_ClusterCenters.instance(i).value(j) != val) \n\t  converged = false;\n\tif (!converged)\n\t  m_ClusterCenters.instance(i).setValue(j, val);\n      }\n    }\n    return converged;\n  }"}, {"signature": "protected void recomputeCentersFast(Instances centers,          \n\t\t\t\t    int[][] instOfCentIndexes, \n\t\t\t\t    Instances model   \n\t\t\t\t    )", "full": "protected void recomputeCentersFast(Instances centers,          \n\t\t\t\t    int[][] instOfCentIndexes, \n\t\t\t\t    Instances model   \n\t\t\t\t    ) {\n    for (int i = 0; i < centers.numInstances(); i++) {\n      double val;\n      for (int j = 0; j < model.numAttributes(); j++) {\n\tval = meanOrMode(m_Instances, instOfCentIndexes[i], j);\n\tcenters.instance(i).setValue(j, val);\n      }\n    }\n  }"}, {"signature": "protected double meanOrMode(Instances instances, \n\t\t\t    int[] instList, \n\t\t\t    int attIndex)", "full": "protected double meanOrMode(Instances instances, \n\t\t\t    int[] instList, \n\t\t\t    int attIndex) {\n    double result, found;\n    int[] counts;\n    int numInst = instList.length;\n\n    if (instances.attribute(attIndex).isNumeric()) {\n      result = found = 0;\n      for (int j = 0; j < numInst; j++) {\n\tInstance currInst = instances.instance(instList[j]);\n\tif (!currInst.isMissing(attIndex)) {\n\t  found += currInst.weight();\n\t  result += currInst.weight() * \n\t    currInst.value(attIndex);\n\t}\n      }\n      if (Utils.eq(found, 0)) {\n\treturn 0;\n      } else {\n\treturn result / found;\n      }\n    } else if (instances.attribute(attIndex).isNominal()) {\n      counts = new int[instances.attribute(attIndex).numValues()];\n      for (int j = 0; j < numInst; j++) {\n\tInstance currInst = instances.instance(instList[j]);\n\tif (!currInst.isMissing(attIndex)) {\n\t  counts[(int) currInst.value(attIndex)] += currInst.weight();\n\t}\n      }\n      return (double)Utils.maxIndex(counts);\n    } else {\n      return 0;\n    }\n  }"}, {"signature": "protected boolean assignToCenters(KDTree tree,\n                                  Instances centers, \n\t\t\t\t  int[][] instOfCent, \n                                  int[] allInstList,\n\t\t\t\t  int[] assignments,\n                                  int iterationCount) throws Exception", "full": "protected boolean assignToCenters(KDTree tree,\n                                  Instances centers, \n\t\t\t\t  int[][] instOfCent, \n                                  int[] allInstList,\n\t\t\t\t  int[] assignments,\n                                  int iterationCount) throws Exception {\n    \n    boolean converged = true;\n    if (tree != null) {\n      converged = assignToCenters(tree,\n\t\t\t\t  centers, \n\t\t\t\t  instOfCent,\n\t\t\t\t  assignments,\n\t\t\t\t  iterationCount);\n    } else {\n      converged = assignToCenters(centers, \n\t\t\t\t  instOfCent,\n\t\t\t\t  allInstList, \n\t\t\t\t  assignments);\n    }\n    return converged;\n  }"}, {"signature": "protected boolean assignToCenters(KDTree kdtree,\n\t\t\t\t  Instances centers, \n\t\t\t\t  int[][] instOfCent, \n\t\t\t\t  int[] assignments,\n                                  int iterationCount) throws Exception", "full": "protected boolean assignToCenters(KDTree kdtree,\n\t\t\t\t  Instances centers, \n\t\t\t\t  int[][] instOfCent, \n\t\t\t\t  int[] assignments,\n                                  int iterationCount) throws Exception {\n\n    int numCent = centers.numInstances();\n    int numInst = m_Instances.numInstances(); \n    int[] oldAssignments = new int[numInst];\n    \n    if (assignments == null) {\n      assignments = new int[numInst];\n      for (int i = 0; i < numInst; i++) {\n\tassignments[0] = -1;\n      }\n    }\n    \n    if (instOfCent == null) {\n      instOfCent = new int [numCent][];\n    }\n    \n    for (int i = 0; i < assignments.length; i++) {\n      oldAssignments[i] = assignments[i];\n    }\n    \n    kdtree.centerInstances(centers, assignments,\n\t\t\t   Math.pow(.8, iterationCount));\t\n    boolean converged = true;\n  \n    for (int i = 0; converged && (i < assignments.length); i++) {\n      converged = (oldAssignments[i] == assignments[i]);\n      if (assignments[i] == -1) \n\tthrow new Exception(\"Instance \" + i + \n\t\t\t    \" has not been assigned to cluster.\");\n    }\n\n    if (!converged) {\n      int[] numInstOfCent = new int[numCent];\n      for (int i = 0; i < numCent; i++)\n\tnumInstOfCent[i] = 0;\n\n      for (int i = 0; i < numInst; i++)\n\tnumInstOfCent[assignments[i]]++;\n      \n      for (int i = 0; i < numCent; i++){\n\tinstOfCent[i] = new int[numInstOfCent[i]];\n      }\n      for (int i = 0; i < numCent; i++) {\n\tint index = -1;   \n\tfor (int j = 0; j < numInstOfCent[i]; j++) {\n\t  index = nextAssignedOne(i, index, assignments);\n\t  instOfCent[i][j] = index;\n\t}\n      }\n    }\n  \n    return converged;\n  }"}, {"signature": "protected boolean assignToCenters(Instances centers, \n\t\t\t\t  int[][] instOfCent,\n\t\t\t\t  int[] allInstList,\n\t\t\t\t  int[] assignments) \n    throws Exception", "full": "protected boolean assignToCenters(Instances centers, \n\t\t\t\t  int[][] instOfCent,\n\t\t\t\t  int[] allInstList,\n\t\t\t\t  int[] assignments) \n    throws Exception {\n    \n    boolean converged = true; int numInst = allInstList.length; \n    int numCent = centers.numInstances();\n    int[] numInstOfCent = new int [numCent];\n    for (int i = 0; i < numCent; i++) numInstOfCent[i] = 0;\n\n    if (assignments == null) {\n      assignments = new int[numInst];\n      for (int i = 0; i < numInst; i++) {\n\tassignments[i] = -1;\n      }\n    }\n\n    if (instOfCent == null) {\n      instOfCent = new int [numCent][];\n    }\n\n    for (int i = 0; i < numInst; i++) {\n      Instance inst = m_Instances.instance(allInstList[i]);\n      int newC = clusterProcessedInstance(inst, centers);\n      \n      if (converged && newC != assignments[i]) {\n\tconverged = false;\n      }\n\n      numInstOfCent[newC]++; \n      if (!converged)\n\tassignments[i] = newC;\n    }\n\n    if (!converged) {\n      PFD(D_FOLLOWSPLIT, \"assignToCenters -> it has NOT converged\");\n      for (int i = 0; i < numCent; i++) {\n\tinstOfCent[i] = new int [numInstOfCent[i]];\n      }\n\n      for (int i = 0; i < numCent; i++) {\n\tint index = -1;   \n\tfor (int j = 0; j < numInstOfCent[i]; j++) {\n\t  index = nextAssignedOne(i, index, assignments);\n\t  instOfCent[i][j] = allInstList[index];\n\t}\n      }\n    }\n    else\n      PFD(D_FOLLOWSPLIT, \"assignToCenters -> it has converged\");\n\n    return converged;\n  }"}, {"signature": "protected int nextAssignedOne(int cent, int lastIndex, \n\t\t\t      int[] assignments)", "full": "protected int nextAssignedOne(int cent, int lastIndex, \n\t\t\t      int[] assignments) {\n    int len = assignments.length;\n    int index = lastIndex + 1;\n    while (index < len) {\n      if (assignments[index] == cent) {\n\treturn (index);\n      }\n      index++;\n    }\n    return (-1);\n  }"}, {"signature": "protected Instances splitCenter(Random random,\n\t\t\t        Instance center,\n\t\t\t        double variance,\n\t\t\t        Instances model) throws Exception", "full": "protected Instances splitCenter(Random random,\n\t\t\t        Instance center,\n\t\t\t        double variance,\n\t\t\t        Instances model) throws Exception {\n    m_NumSplits++;\n    AlgVector r = null;\n    Instances children = new Instances(model, 2);\n\n    if (m_DebugVectorsFile.exists() && m_DebugVectorsFile.isFile()) {\n      Instance nextVector = getNextDebugVectorsInstance(model);\n      PFD(D_RANDOMVECTOR, \"Random Vector from File \" + nextVector);\n      r = new AlgVector(nextVector);\n    }\n    else {\n      r = new AlgVector(model, random);\n    }\n    r.changeLength(Math.pow(variance, 0.5));\n    PFD(D_RANDOMVECTOR, \"random vector *variance \"+ r);\n    \n    AlgVector c = new AlgVector(center);\n    AlgVector c2 = (AlgVector) c.clone();\n    c = c.add(r);\n    Instance newCenter = c.getAsInstance(model, random);\n    children.add(newCenter);\n    PFD(D_FOLLOWSPLIT, \"first child \"+ newCenter);\n    \n    c2 = c2.substract(r);\n    newCenter = c2.getAsInstance(model, random);\n    children.add(newCenter);\n    PFD(D_FOLLOWSPLIT, \"second child \"+ newCenter);\n\n    return children;\n  }"}, {"signature": "protected Instances splitCenters(Random random,\n\t\t\t\t Instances instances,\n\t\t\t\t Instances model)", "full": "protected Instances splitCenters(Random random,\n\t\t\t\t Instances instances,\n\t\t\t\t Instances model) {\n    Instances children = new Instances(model, 2);\n    int instIndex = Math.abs(random.nextInt()) % instances.numInstances();\n    children.add(instances.instance(instIndex));\n    int instIndex2 = instIndex;\n    int count = 0;\n    while ((instIndex2 == instIndex) && count < 10) {\n      count++;\n      instIndex2 = Math.abs(random.nextInt()) % instances.numInstances();\n    }\n    children.add(instances.instance(instIndex2));\n    \n    return children;\n  }"}, {"signature": "protected Instances makeCentersRandomly(Random random0,\n\t\t\t\t\tInstances model,\n\t\t\t\t\tint numClusters)", "full": "protected Instances makeCentersRandomly(Random random0,\n\t\t\t\t\tInstances model,\n\t\t\t\t\tint numClusters) {\n    Instances clusterCenters = new Instances(model, numClusters);\n    m_NumClusters = numClusters;\n\n    for (int i = 0; i < numClusters; i++) {\n      int instIndex = Math.abs(random0.nextInt()) % m_Instances.numInstances();\n      clusterCenters.add(m_Instances.instance(instIndex));\n    }\n    return clusterCenters;\n  }"}, {"signature": "protected double calculateBIC(int[] instList, Instance center,\n\t\t\t      double mle, Instances model)", "full": "protected double calculateBIC(int[] instList, Instance center,\n\t\t\t      double mle, Instances model) {\n    int[][] w1 = new int[1][instList.length];\n    for (int i = 0; i < instList.length; i++) {\n      w1[0][i] = instList[i];\n    }\n    double[] m = {mle};\n    Instances w2 = new Instances(model, 1);\n    w2.add(center);\n    return calculateBIC(w1, w2, m);\n    }"}, {"signature": "protected double calculateBIC(int[][] instOfCent, Instances centers,\n\t\t\t      double[] mle)", "full": "protected double calculateBIC(int[][] instOfCent, Instances centers,\n\t\t\t      double[] mle) {\n    double loglike = 0.0;\n    int numInstTotal = 0;\n    int numCenters = centers.numInstances();\n    int numDimensions = centers.numAttributes();\n    int numParameters = (numCenters - 1) + numCenters * numDimensions + numCenters; for (int i = 0; i < centers.numInstances(); i++) {\n      loglike += logLikelihoodEstimate(instOfCent[i].length, centers.instance(i),\n\t\t\t\t       mle[i], centers.numInstances() * 2);\n      numInstTotal += instOfCent[i].length;\n    }\n    loglike -= numInstTotal * Math.log(numInstTotal);\n    loglike -= (numParameters / 2.0) * Math.log(numInstTotal);\n    return loglike;\n  }"}, {"signature": "protected double logLikelihoodEstimate(int numInst, \n\t\t\t\t       Instance center, \n\t\t\t\t       double distortion, \n\t\t\t\t       int numCent)", "full": "protected double logLikelihoodEstimate(int numInst, \n\t\t\t\t       Instance center, \n\t\t\t\t       double distortion, \n\t\t\t\t       int numCent) {\n    double loglike = 0;\n    if (numInst > 1) {\n      double variance =  distortion / (numInst - 1.0); \n  \n      double p1 = - (numInst / 2.0) * Math.log(Math.PI * 2.0);\n      double p2 = - (numInst * center.numAttributes()) / 2 * Math.log(variance);\n      \n      double p3 = - (numInst - 1.0) / 2.0;\n      \n      double p4 = numInst * Math.log(numInst);\n      \n      loglike = p1 + p2 + p3 + p4; }\n    return loglike;\n  }"}, {"signature": "protected int clusterProcessedInstance(Instance instance)", "full": "protected int clusterProcessedInstance(Instance instance) {\n    double minDist = Integer.MAX_VALUE;\n    int bestCluster = 0;\n    for (int i = 0; i < m_NumClusters; i++) {\n      double dist = m_DistanceF\n          .distance(instance, m_ClusterCenters.instance(i));\n      if (dist < minDist) {\n        minDist = dist;\n        bestCluster = i;\n      }\n    }\n    return bestCluster;\n  }"}, {"signature": "public int clusterInstance(Instance instance) throws Exception", "full": "public int clusterInstance(Instance instance) throws Exception {\n    m_ReplaceMissingFilter.input(instance);\n    Instance inst = m_ReplaceMissingFilter.output();\n\n    return clusterProcessedInstance(inst);\n  }"}, {"signature": "public int numberOfClusters()", "full": "public int numberOfClusters() {\n    return m_NumClusters;\n  }"}, {"signature": "public Enumeration listOptions()", "full": "public Enumeration listOptions() {\n    Vector result = new Vector();\n    \n    result.addElement(new Option(\n\t\"\\tmaximum number of overall iterations\\n\"\n\t+ \"\\t(default 1).\", \n\t\"I\", 1, \"-I <num>\"));\n    \n    result.addElement(new Option(\n\t\"\\tmaximum number of iterations in the kMeans loop in\\n\"\n\t+ \"\\tthe Improve-Parameter part \\n\"\n\t+ \"\\t(default 1000).\", \n\t\"M\", 1, \"-M <num>\"));\n    \n    result.addElement(new Option(\n\t\"\\tmaximum number of iterations in the kMeans loop\\n\"\n\t+ \"\\tfor the splitted centroids in the Improve-Structure part \\n\"\n\t+ \"\\t(default 1000).\",\n\t\"J\", 1, \"-J <num>\"));\n    \n    result.addElement(new Option(\n\t\"\\tminimum number of clusters\\n\"\n\t+ \"\\t(default 2).\", \n\t\"L\", 1, \"-L <num>\"));\n    \n    result.addElement(new Option(\n\t\"\\tmaximum number of clusters\\n\"\n\t+ \"\\t(default 4).\",\n\t\"H\", 1, \"-H <num>\"));\n    \n    result.addElement(new Option(\n\t\"\\tdistance value for binary attributes\\n\"\n\t+ \"\\t(default 1.0).\",\n\t\"B\", 1, \"-B <value>\"));\n    \n    result.addElement(new Option(\n\t\"\\tUses the KDTree internally\\n\"\n\t+ \"\\t(default no).\",\n\t\"use-kdtree\", 0, \"-use-kdtree\"));\n    \n    result.addElement(new Option(\n\t\"\\tFull class name of KDTree class to use, followed\\n\"\n\t+ \"\\tby scheme options.\\n\"\n\t+ \"\\teg: \\\"weka.core.neighboursearch.kdtrees.KDTree -P\\\"\\n\"\n\t+ \"\\t(default no KDTree class used).\",\n\t\"K\", 1, \"-K <KDTree class specification>\"));\n    \n    result.addElement(new Option(\n\t\"\\tcutoff factor, takes the given percentage of the splitted \\n\"\n\t+ \"\\tcentroids if none of the children win\\n\"\n\t+ \"\\t(default 0.0).\",\n\t\"C\", 1, \"-C <value>\"));\n    \n    result.addElement(new Option(\n\t\"\\tFull class name of Distance function class to use, followed\\n\"\n\t+ \"\\tby scheme options.\\n\" +\n\t\"\\t(default weka.core.EuclideanDistance).\",\n\t\"D\", 1, \"-D <distance function class specification>\"));\n    \n    result.addElement(new Option(\n\t\"\\tfile to read starting centers from (ARFF format).\",\n\t\"N\", 1, \"-N <file name>\"));\n    \n    result.addElement(new Option(\n\t\"\\tfile to write centers to (ARFF format).\",\n\t\"O\", 1, \"-O <file name>\"));\n    \n    result.addElement(new Option(\n\t\"\\tThe debug level.\\n\"\n\t+ \"\\t(default 0)\",\n\t\"U\", 1, \"-U <int>\"));\n    \n    result.addElement(new Option(\n\t\"\\tThe debug vectors file.\",\n\t\"Y\", 1, \"-Y <file name>\"));\n    \n    Enumeration en = super.listOptions();\n    while (en.hasMoreElements())\n      result.addElement(en.nextElement());\n    \n    return result.elements();\n  }"}, {"signature": "public String minNumClustersTipText()", "full": "public String minNumClustersTipText() {\n    return \"set minimum number of clusters\";\n  }"}, {"signature": "public void setMinNumClusters(int n)", "full": "public void setMinNumClusters(int n) {\n    m_MinNumClusters = n;\n  }"}, {"signature": "public int getMinNumClusters()", "full": "public int getMinNumClusters() {\n    return m_MinNumClusters;\n  }"}, {"signature": "public String maxNumClustersTipText()", "full": "public String maxNumClustersTipText() {\n    return \"set maximum number of clusters\";\n  }"}, {"signature": "public void setMaxNumClusters(int n)", "full": "public void setMaxNumClusters(int n) {\n    if (n >= m_MinNumClusters) {\n      m_MaxNumClusters = n;\n    }\n  }"}, {"signature": "public int getMaxNumClusters()", "full": "public int getMaxNumClusters() {\n    return m_MaxNumClusters;\n  }"}, {"signature": "public String maxIterationsTipText()", "full": "public String maxIterationsTipText() {\n    return \"the maximum number of iterations to perform\";\n  }"}, {"signature": "public void setMaxIterations(int i) throws Exception", "full": "public void setMaxIterations(int i) throws Exception {\n    if (i < 0) \n      throw new Exception(\"Only positive values for iteration number\" +\n                           \" allowed (Option I).\"); \n    m_MaxIterations = i;\n  }"}, {"signature": "public int getMaxIterations()", "full": "public int getMaxIterations() {\n    return  m_MaxIterations;\n  }"}, {"signature": "public String maxKMeansTipText()", "full": "public String maxKMeansTipText() {\n    return \"the maximum number of iterations to perform in KMeans\";\n  }"}, {"signature": "public void setMaxKMeans(int i)", "full": "public void setMaxKMeans(int i) {\n    m_MaxKMeans = i;\n    m_MaxKMeansForChildren = i;\n  }"}, {"signature": "public int getMaxKMeans()", "full": "public int getMaxKMeans() {\n    return  m_MaxKMeans;\n  }"}, {"signature": "public String maxKMeansForChildrenTipText()", "full": "public String maxKMeansForChildrenTipText() {\n    return \"the maximum number of iterations KMeans that is performed on the child centers\";\n  }"}, {"signature": "public void setMaxKMeansForChildren(int i)", "full": "public void setMaxKMeansForChildren(int i) {\n    m_MaxKMeansForChildren = i;\n  }"}, {"signature": "public int getMaxKMeansForChildren()", "full": "public int getMaxKMeansForChildren() {\n    return  m_MaxKMeansForChildren;\n  }"}, {"signature": "public String cutOffFactorTipText()", "full": "public String cutOffFactorTipText() {\n    return \"the cut-off factor to use\";\n  }"}, {"signature": "public KDTree getKDTree()", "full": "public KDTree getKDTree() {\n    return m_KDTree;\n  }"}, {"signature": "public double getCutOffFactor()", "full": "public double getCutOffFactor() {\n    return  m_CutOffFactor;\n  }"}, {"signature": "public String binValueTipText()", "full": "public String binValueTipText() {\n    return \"Set the value that represents true in the new attributes.\";\n  }"}, {"signature": "public double getBinValue()", "full": "public double getBinValue() {\n    return m_BinValue;\n  }"}, {"signature": "public void setBinValue(double value)", "full": "public void setBinValue(double value) {\n    m_BinValue = value;\n  }"}, {"signature": "public String distanceFTipText()", "full": "public String distanceFTipText() {\n    return \"The distance function to use.\";\n  }"}, {"signature": "public void setDistanceF(DistanceFunction distanceF)", "full": "public void setDistanceF(DistanceFunction distanceF) {\n    m_DistanceF = distanceF;\n  }"}, {"signature": "public DistanceFunction getDistanceF()", "full": "public DistanceFunction getDistanceF() {\n    return m_DistanceF;\n  }"}, {"signature": "protected String getDistanceFSpec()", "full": "protected String getDistanceFSpec() {\n    \n    DistanceFunction d = getDistanceF();\n    if (d instanceof OptionHandler) {\n      return d.getClass().getName() + \" \"\n\t+ Utils.joinOptions(((OptionHandler) d).getOptions());\n    }\n    return d.getClass().getName();\n  }"}, {"signature": "public String debugVectorsFileTipText()", "full": "public String debugVectorsFileTipText() {\n    return \"The file containing the debug vectors (only for debugging!).\";\n  }"}, {"signature": "public void setDebugVectorsFile(File value)", "full": "public void setDebugVectorsFile(File value) {\n    m_DebugVectorsFile = value;\n  }"}, {"signature": "public File getDebugVectorsFile()", "full": "public File getDebugVectorsFile() {\n    return m_DebugVectorsFile;\n  }"}, {"signature": "public void initDebugVectorsInput() throws Exception", "full": "public void initDebugVectorsInput() throws Exception {\n    m_DebugVectorsInput = \n      new BufferedReader(new FileReader(m_DebugVectorsFile));\n    m_DebugVectors = new Instances(m_DebugVectorsInput);\n    m_DebugVectorsIndex = 0;\n  }"}, {"signature": "public Instance getNextDebugVectorsInstance(Instances model) \n    throws Exception", "full": "public Instance getNextDebugVectorsInstance(Instances model) \n    throws Exception {\n    if (m_DebugVectorsIndex >= m_DebugVectors.numInstances())\n      throw new Exception(\"no more prefabricated Vectors\");\n    Instance nex = m_DebugVectors.instance(m_DebugVectorsIndex);\n    nex.setDataset(model);\n    m_DebugVectorsIndex++;\n    return nex;\n  }"}, {"signature": "public String inputCenterFileTipText()", "full": "public String inputCenterFileTipText() {\n    return \"The file to read the list of centers from.\";\n  }"}, {"signature": "public void setInputCenterFile(File value)", "full": "public void setInputCenterFile(File value) {\n    m_InputCenterFile = value;\n  }"}, {"signature": "public File getInputCenterFile()", "full": "public File getInputCenterFile() {\n    return m_InputCenterFile;\n  }"}, {"signature": "public String outputCenterFileTipText()", "full": "public String outputCenterFileTipText() {\n    return \"The file to write the list of centers to.\";\n  }"}, {"signature": "public void setOutputCenterFile(File value)", "full": "public void setOutputCenterFile(File value) {\n    m_OutputCenterFile = value;\n  }"}, {"signature": "public File getOutputCenterFile()", "full": "public File getOutputCenterFile() {\n    return m_OutputCenterFile;\n  }"}, {"signature": "public String KDTreeTipText()", "full": "public String KDTreeTipText() {\n    return \"The KDTree to use.\";\n  }"}, {"signature": "public void setKDTree(KDTree k)", "full": "public void setKDTree(KDTree k) {\n    m_KDTree = k;\n  }"}, {"signature": "public String useKDTreeTipText()", "full": "public String useKDTreeTipText() {\n    return \"Whether to use the KDTree.\";\n  }"}, {"signature": "public void setUseKDTree(boolean value)", "full": "public void setUseKDTree(boolean value) {\n    m_UseKDTree = value;\n  }"}, {"signature": "public boolean getUseKDTree()", "full": "public boolean getUseKDTree() {\n    return m_UseKDTree;\n  }"}, {"signature": "protected String getKDTreeSpec()", "full": "protected String getKDTreeSpec() {\n    \n    KDTree c = getKDTree();\n    if (c instanceof OptionHandler) {\n      return c.getClass().getName() + \" \"\n\t+ Utils.joinOptions(((OptionHandler)c).getOptions());\n    }\n    return c.getClass().getName();\n  }"}, {"signature": "public String debugLevelTipText()", "full": "public String debugLevelTipText() {\n    return \"The debug level to use.\";\n  }"}, {"signature": "public void setDebugLevel(int d)", "full": "public void setDebugLevel(int d) {\n    m_DebugLevel = d;\n  }"}, {"signature": "public int getDebugLevel()", "full": "public int getDebugLevel() {\n    return m_DebugLevel;\n  }"}, {"signature": "protected void checkInstances ()", "full": "protected void checkInstances () {\n    \n   }"}, {"signature": "public void setOptions(String[] options)\n    throws Exception", "full": "public void setOptions(String[] options)\n    throws Exception {\n    \n    String \toptionString;\n    String \tfuncString;\n\n    optionString = Utils.getOption('I', options);\n    if (optionString.length() != 0)\n      setMaxIterations(Integer.parseInt(optionString));\n    else\n      setMaxIterations(1);\n    \n    optionString = Utils.getOption('M', options);\n    if (optionString.length() != 0)\n      setMaxKMeans(Integer.parseInt(optionString));\n    else\n      setMaxKMeans(1000);\n    \n    optionString = Utils.getOption('J', options);\n    if (optionString.length() != 0)\n      setMaxKMeansForChildren(Integer.parseInt(optionString));\n    else\n      setMaxKMeansForChildren(1000);\n      \n    optionString = Utils.getOption('L', options);\n    if (optionString.length() != 0)\n      setMinNumClusters(Integer.parseInt(optionString));\n    else\n      setMinNumClusters(2);\n      \n    optionString = Utils.getOption('H', options);\n    if (optionString.length() != 0)\n      setMaxNumClusters(Integer.parseInt(optionString));\n    else\n      setMaxNumClusters(4);\n    \n    optionString = Utils.getOption('B', options);\n    if (optionString.length() != 0)\n      setBinValue(Double.parseDouble(optionString));\n    else\n      setBinValue(1.0);\n\n    setUseKDTree(Utils.getFlag(\"use-kdtree\", options));\n    \n    if (getUseKDTree()) {\n      funcString = Utils.getOption('K', options);\n      if (funcString.length() != 0) {\n\tString[] funcSpec = Utils.splitOptions(funcString);\n\tif (funcSpec.length == 0) {\n\t  throw new Exception(\"Invalid function specification string\");\n\t}\n\tString funcName = funcSpec[0];\n\tfuncSpec[0] = \"\";\n\tsetKDTree((KDTree) Utils.forName(KDTree.class, funcName, funcSpec));\n      }\n      else {\n\tsetKDTree(new KDTree());\n      }\n    }\n    else {\n      setKDTree(new KDTree());\n    }\n\n    optionString = Utils.getOption('C', options);\n    if (optionString.length() != 0)\n      setCutOffFactor(Double.parseDouble(optionString));\n    else\n      setCutOffFactor(0.0);\n    \n    funcString = Utils.getOption('D', options);\n    if (funcString.length() != 0) {\n      String[] funcSpec = Utils.splitOptions(funcString);\n      if (funcSpec.length == 0) {\n\tthrow new Exception(\"Invalid function specification string\");\n      }\n      String funcName = funcSpec[0];\n      funcSpec[0] = \"\";\n      setDistanceF((DistanceFunction) Utils.forName(DistanceFunction.class,\n\t\t\t\t\t\t    funcName, funcSpec));\n    }\n    else {\n      setDistanceF(new EuclideanDistance());\n    }\n\n    optionString  = Utils.getOption('N', options);\n    if (optionString.length() != 0) {\n      setInputCenterFile(new File(optionString));\n      m_CenterInput = \n\tnew BufferedReader(new FileReader(optionString));\n    }\n    else {\n      setInputCenterFile(new File(System.getProperty(\"user.dir\")));\n      m_CenterInput = null;\n    }\n\n    optionString  = Utils.getOption('O', options);\n    if (optionString.length() != 0) {\n      setOutputCenterFile(new File(optionString));\n      m_CenterOutput = new PrintWriter(new FileOutputStream(optionString));\n    }\n    else {\n      setOutputCenterFile(new File(System.getProperty(\"user.dir\")));\n      m_CenterOutput = null;\n    }\n\n    optionString = Utils.getOption('U', options);\n    int debugLevel = 0;\n    if (optionString.length() != 0) {\n      try {\n\tdebugLevel = Integer.parseInt(optionString);\n      } catch (NumberFormatException e) {\n\tthrow new Exception(optionString +\n                            \"is an illegal value for option -U\"); \n      }\n    }\n    setDebugLevel(debugLevel);\n\n    optionString  = Utils.getOption('Y', options);\n    if (optionString.length() != 0) {\n      setDebugVectorsFile(new File(optionString));\n    }\n    else {\n      setDebugVectorsFile(new File(System.getProperty(\"user.dir\")));\n      m_DebugVectorsInput = null;\n      m_DebugVectors      = null;\n    }\n    \n    super.setOptions(options);\n  }"}, {"signature": "public String[] getOptions()", "full": "public String[] getOptions() {\n    int       \ti;\n    Vector    \tresult;\n    String[]  \toptions;\n\n    result = new Vector();\n\n    result.add(\"-I\");\n    result.add(\"\" + getMaxIterations());\n    \n    result.add(\"-M\");\n    result.add(\"\" + getMaxKMeans());\n    \n    result.add(\"-J\");\n    result.add(\"\" + getMaxKMeansForChildren());\n    \n    result.add(\"-L\");\n    result.add(\"\" + getMinNumClusters());\n    \n    result.add(\"-H\");\n    result.add(\"\" + getMaxNumClusters());\n    \n    result.add(\"-B\");\n    result.add(\"\" + getBinValue());\n    \n    if (getUseKDTree()) {\n      result.add(\"-use-kdtree\");\n      result.add(\"-K\");\n      result.add(\"\" + getKDTreeSpec());\n    }\n    \n    result.add(\"-C\");\n    result.add(\"\" + getCutOffFactor());\n    \n    if (getDistanceF() != null) {\n      result.add(\"-D\");\n      result.add(\"\" + getDistanceFSpec());\n    }\n    \n    if (getInputCenterFile().exists() && getInputCenterFile().isFile()) {\n      result.add(\"-N\");\n      result.add(\"\" + getInputCenterFile());\n    }\n    \n    if (getOutputCenterFile().exists() && getOutputCenterFile().isFile()) {\n      result.add(\"-O\");\n      result.add(\"\" + getOutputCenterFile());\n    }\n    \n    int dL = getDebugLevel();\n    if (dL > 0) {\n      result.add(\"-U\");\n      result.add(\"\" + getDebugLevel());\n    }\n\n    if (getDebugVectorsFile().exists() && getDebugVectorsFile().isFile()) {\n      result.add(\"-Y\");\n      result.add(\"\" + getDebugVectorsFile());\n    }\n    \n    options = super.getOptions();\n    for (i = 0; i < options.length; i++)\n      result.add(options[i]);\n\n    return (String[]) result.toArray(new String[result.size()]);\t  \n  }"}, {"signature": "public String toString()", "full": "public String toString() {\n    StringBuffer temp = new StringBuffer();\n\n    temp.append(\"\\nXMeans\\n======\\n\");\n\n    temp.append(\"Requested iterations            : \" + m_MaxIterations + \"\\n\");\n    temp.append(\"Iterations performed            : \" + m_IterationCount+ \"\\n\");\n    if (m_KMeansStopped > 0) {\n      temp.append(\"kMeans did not converge\\n\");\n      temp.append(\"  but was stopped by max-loops \" \n\t  + m_KMeansStopped + \" times (max kMeans-iter)\\n\");\n    }\n    temp.append(\"Splits prepared                 : \" + m_NumSplits + \"\\n\");\n    temp.append(\"Splits performed                : \" + m_NumSplitsDone + \"\\n\");\n    temp.append(\"Cutoff factor                   : \" + m_CutOffFactor + \"\\n\");\n    double perc;\n    if (m_NumSplitsDone > 0)\n      perc = (((double)m_NumSplitsStillDone)/((double) m_NumSplitsDone))\n             * 100.0;\n    else\n      perc = 0.0;\n    temp.append(\"Percentage of splits accepted \\n\" +\n                \"by cutoff factor                : \" \n\t\t+ Utils.doubleToString(perc,2) + \" %\\n\");\n    temp.append(\"------\\n\");\n\n    temp.append(\"Cutoff factor                   : \" + m_CutOffFactor + \"\\n\");\n    temp.append(\"------\\n\");\n    temp.append(\"\\nCluster centers                 : \" + m_NumClusters + \" centers\\n\");\n    for (int i = 0; i < m_NumClusters; i++) {\n      temp.append(\"\\nCluster \"+i+\"\\n           \");\n      for (int j = 0; j < m_ClusterCenters.numAttributes(); j++) {\n\tif (m_ClusterCenters.attribute(j).isNominal()) {\n\t  temp.append(\" \"+m_ClusterCenters.attribute(j).\n\t\t      value((int)m_ClusterCenters.instance(i).value(j)));\n\t} else {\n\t  temp.append(\" \"+m_ClusterCenters.instance(i).value(j));\n\t}\n      }\n    }\n    if (m_Mle != null)\n      temp.append(\"\\n\\nDistortion: \" + \n\t\t  Utils.doubleToString(Utils.sum(m_Mle),6) + \"\\n\");\n    temp.append(\"BIC-Value : \" + Utils.doubleToString(m_Bic,6) + \"\\n\");\n    return temp.toString();\n  }"}, {"signature": "protected void PrCentersFD(int debugLevel)", "full": "protected void PrCentersFD(int debugLevel) {\n    if (debugLevel == m_DebugLevel) {\n      for (int i = 0; i < m_ClusterCenters.numInstances(); i++) {\n\tSystem.out.println(m_ClusterCenters.instance(i));\n      }\n    }\n  }"}, {"signature": "protected boolean TFD(int debugLevel)", "full": "protected boolean TFD(int debugLevel) {\n    return (debugLevel == m_DebugLevel);\n  }"}, {"signature": "protected void PFD(int debugLevel, String output)", "full": "protected void PFD(int debugLevel, String output) {\n    if (debugLevel == m_DebugLevel)\n      System.out.println(output);\n  }"}, {"signature": "protected void PFD_CURR(String output)", "full": "protected void PFD_CURR(String output) {\n    if (m_CurrDebugFlag)\n      System.out.println(output);\n  }"}, {"signature": "public String getRevision()", "full": "public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 5538 $\");\n  }"}, {"signature": "public static void main(String[] argv) \n}", "full": "public static void main(String[] argv) {\n    runClusterer(new XMeans(), argv);\n  }\n}"}], "class_attributes": [{"type": "long", "name": "serialVersionUID"}, {"type": "Instances", "name": "m_Instances"}, {"type": "Instances", "name": "m_Model"}, {"type": "ReplaceMissingValues", "name": "m_ReplaceMissingFilter"}, {"type": "double", "name": "m_BinValue"}, {"type": "double", "name": "m_Bic"}, {"type": "double", "name": "m_Mle"}, {"type": "int", "name": "m_MaxIterations"}, {"type": "int", "name": "m_MaxKMeans"}, {"type": "int", "name": "m_MaxKMeansForChildren"}, {"type": "int", "name": "m_NumClusters"}, {"type": "int", "name": "m_MinNumClusters"}, {"type": "int", "name": "m_MaxNumClusters"}, {"type": "DistanceFunction", "name": "m_DistanceF"}, {"type": "Instances", "name": "m_ClusterCenters"}, {"type": "File", "name": "m_InputCenterFile"}, {"type": "Reader", "name": "m_DebugVectorsInput"}, {"type": "int", "name": "m_DebugVectorsIndex"}, {"type": "Instances", "name": "m_DebugVectors"}, {"type": "File", "name": "m_DebugVectorsFile"}, {"type": "Reader", "name": "m_CenterInput"}, {"type": "File", "name": "m_OutputCenterFile"}, {"type": "PrintWriter", "name": "m_CenterOutput"}, {"type": "int", "name": "m_ClusterAssignments"}, {"type": "double", "name": "m_CutOffFactor"}, {"type": "int", "name": "R_LOW"}, {"type": "int", "name": "R_HIGH"}, {"type": "int", "name": "R_WIDTH"}, {"type": "KDTree", "name": "m_KDTree"}, {"type": "boolean", "name": "m_UseKDTree"}, {"type": "int", "name": "m_IterationCount"}, {"type": "int", "name": "m_KMeansStopped"}, {"type": "int", "name": "m_NumSplits"}, {"type": "int", "name": "m_NumSplitsDone"}, {"type": "int", "name": "m_NumSplitsStillDone"}, {"type": "int", "name": "m_DebugLevel"}, {"type": "int", "name": "D_PRINTCENTERS"}, {"type": "int", "name": "D_FOLLOWSPLIT"}, {"type": "int", "name": "D_CONVCHCLOSER"}, {"type": "int", "name": "D_RANDOMVECTOR"}, {"type": "int", "name": "D_KDTREE"}, {"type": "int", "name": "D_ITERCOUNT"}, {"type": "int", "name": "D_METH_MISUSE"}, {"type": "int", "name": "D_CURR"}, {"type": "int", "name": "D_GENERAL"}, {"type": "boolean", "name": "m_CurrDebugFlag"}]}
{"id": 9168402, "class_signatures": "public class Assessment implements Cloneable, IDeepCloneable, Serializable,\n\t\tComparable<Assessment>", "class_methods": [{"signature": "public Assessment()", "full": "public Assessment() {\n\t\t}"}, {"signature": "public Assessment(ETrafficLightColor color)", "full": "public Assessment(ETrafficLightColor color) {\n\t\tadd(color);\n\t}"}, {"signature": "public final void add(ETrafficLightColor color)", "full": "public final void add(ETrafficLightColor color) {\n\t\tadd(color, 1);\n\t}"}, {"signature": "public final void add(ETrafficLightColor color, int count)", "full": "public final void add(ETrafficLightColor color, int count) {\n\t\tif (count < 0) {\n\t\t\tthrow new IllegalArgumentException(\"Count must be non-negative!\");\n\t\t}\n\t\tmapping[color.ordinal()] += count;\n\t}"}, {"signature": "public int getColorFrequency(ETrafficLightColor color)", "full": "public int getColorFrequency(ETrafficLightColor color) {\n\t\treturn mapping[color.ordinal()];\n\t}"}, {"signature": "public ETrafficLightColor getDominantColor()", "full": "public ETrafficLightColor getDominantColor() {\n\t\tfor (int i = 0; i < ETrafficLightColor.values().length; ++i) {\n\t\t\tif (mapping[i] > 0) {\n\t\t\t\treturn ETrafficLightColor.values()[i];\n\t\t\t}\n\t\t}\n\t\treturn ETrafficLightColor.UNKNOWN;\n\t}"}, {"signature": "public ETrafficLightColor getMostFrequentColor()", "full": "public ETrafficLightColor getMostFrequentColor() {\n\t\tETrafficLightColor result = ETrafficLightColor.UNKNOWN;\n\t\tint bestCount = 0;\n\n\t\tfor (int i = 0; i < mapping.length; ++i) {\n\t\t\tif (mapping[i] > bestCount) {\n\t\t\t\tbestCount = mapping[i];\n\t\t\t\tresult = ETrafficLightColor.values()[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}"}, {"signature": "public String toString()", "full": "@Override\n\tpublic String toString() {\n\t\tint sum = getSize();\n\t\tif (sum == 0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tif (sum == 1) {\n\t\t\treturn getDominantColor().toString();\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder(\"[\");\n\t\tappendColor(builder, ETrafficLightColor.GREEN);\n\t\tbuilder.append(\", \");\n\t\tappendColor(builder, ETrafficLightColor.YELLOW);\n\t\tbuilder.append(\", \");\n\t\tappendColor(builder, ETrafficLightColor.RED);\n\t\tif (getColorFrequency(ETrafficLightColor.BASELINE) > 0) {\n\t\t\tbuilder.append(\", \");\n\t\t\tappendColor(builder, ETrafficLightColor.BASELINE);\n\t\t}\n\t\tbuilder.append(\"]\");\n\t\treturn builder.toString();\n\t}"}, {"signature": "public int getSize()", "full": "public int getSize() {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < mapping.length; ++i) {\n\t\t\tsum += mapping[i];\n\t\t}\n\t\treturn sum;\n\t}"}, {"signature": "private void appendColor(StringBuilder builder, ETrafficLightColor color)", "full": "private void appendColor(StringBuilder builder, ETrafficLightColor color) {\n\t\tbuilder.append(color.toString().substring(0, 1));\n\t\tbuilder.append(\": \");\n\t\tbuilder.append(getColorFrequency(color));\n\t}"}, {"signature": "protected Assessment clone()", "full": "@Override\n\tprotected Assessment clone() {\n\t\treturn deepClone();\n\t}"}, {"signature": "public Assessment deepClone()", "full": "@Override\n\tpublic Assessment deepClone() {\n\t\tAssessment a = new Assessment();\n\t\ta.add(this);\n\t\treturn a;\n\t}"}, {"signature": "public boolean equals(Object obj)", "full": "@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (!(obj instanceof Assessment)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tAssessment a = (Assessment) obj;\n\t\treturn Arrays.equals(mapping, a.mapping);\n\t}"}, {"signature": "public int hashCode()", "full": "@Override\n\tpublic int hashCode() {\n\t\tint hash = 0;\n\t\tfor (int i = 0; i < mapping.length; ++i) {\n\t\t\thash *= 97;\n\t\t\thash += mapping[i];\n\t\t\thash %= 50331653;\n\t\t}\n\t\treturn hash;\n\t}"}, {"signature": "public int compareTo(Assessment other)", "full": "@Override\n\tpublic int compareTo(Assessment other) {\n\t\tfor (int i = 0; i < mapping.length; i++) {\n\t\t\tif (mapping[i] != other.mapping[i]) {\n\t\t\t\treturn mapping[i] - other.mapping[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}"}, {"signature": "public int compareToRelative(Assessment other)", "full": "public int compareToRelative(Assessment other) {\n\t\tint thisSum = getSize();\n\t\tint otherSum = other.getSize();\n\n\t\tif (thisSum == 0 || otherSum == 0) {\n\t\t\treturn thisSum - otherSum;\n\t\t}\n\n\t\tfor (int i = 0; i < mapping.length; i++) {\n\t\t\tint compareResult = Double.compare((double) mapping[i] / thisSum,\n\t\t\t\t\t(double) other.mapping[i] / otherSum);\n\t\t\tif (compareResult != 0) {\n\t\t\t\treturn compareResult;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}"}, {"signature": "public static Assessment aggregate(Collection<Assessment> values) \n\n}", "full": "public static Assessment aggregate(Collection<Assessment> values) {\n\t\tAssessment result = new Assessment();\n\t\tfor (Assessment a : values) {\n\t\t\tresult.add(a);\n\t\t}\n\t\treturn result;\n\t}\n\n}"}], "class_attributes": [{"type": "long", "name": "serialVersionUID"}, {"type": "int", "name": "mapping"}]}
{"id": 9222702, "class_signatures": "public final class FullParser", "class_methods": [{"signature": "private FullParser()", "full": "private FullParser() {\n        }"}, {"signature": "public static List<Item> parse(InputStream is)\n        throws Exception", "full": "public static List<Item> parse(InputStream is)\n        throws Exception {\n\n        if (is == null) {\n            throw new NullPointerException(\"InputStream cannot be null\");\n        }\n\n        FullHandler handler = new FullHandler();\n        SAXParser.parse(new InputSource(is), handler);\n\n        return handler.getItems();\n    }"}, {"signature": "public static List<FastPathObject> realiseObjects(Collection<Item> items, Model model,\n                                                       boolean useIdentifier)\n        throws ClassNotFoundException", "full": "public static List<FastPathObject> realiseObjects(Collection<Item> items, Model model,\n                                                       boolean useIdentifier)\n        throws ClassNotFoundException {\n        return realiseObjects(items, model, useIdentifier, true);\n    }"}, {"signature": "public static List<FastPathObject> realiseObjects(Collection<Item> items, Model model,\n            boolean useIdentifier, boolean abortOnError) throws ClassNotFoundException", "full": "public static List<FastPathObject> realiseObjects(Collection<Item> items, Model model,\n            boolean useIdentifier, boolean abortOnError) throws ClassNotFoundException {\n        Map<String, FastPathObject> objMap = new LinkedHashMap<String, FastPathObject>();\n\n        List<FastPathObject> result = new ArrayList<FastPathObject>();\n        for (Item item : items) {\n            if (item.getIdentifier() != null) {\n                try {\n                    objMap.put(item.getIdentifier(), DynamicUtil.instantiateObject(\n                            ItemHelper.generateClassNames(item.getClassName(), model),\n                            ItemHelper.generateClassNames(item.getImplementations(), model)));\n                } catch (ClassNotFoundException e) {\n                    if (abortOnError) {\n                        throw e;\n                    } else {\n                        LOG.warn(\"Not creating object for item: \" + item.getIdentifier()\n                                 + \" class: \" + item.getClassName() + \" not found in model.\");\n                    }\n                }\n            }\n        }\n\n        for (Item item : items) {\n            FastPathObject instance = null;\n            if (item.getIdentifier() == null) {\n                try {\n                    instance = DynamicUtil.instantiateObject(\n                            ItemHelper.generateClassNames(item.getClassName(), model),\n                            ItemHelper.generateClassNames(item.getImplementations(), model));\n                } catch (ClassNotFoundException e) {\n                    if (abortOnError) {\n                        throw e;\n                    } else {\n                        LOG.warn(\"Not creating object for item: \" + item.getIdentifier()\n                                 + \" class: \" + item.getClassName() + \" not found in model.\");\n                    }\n                }\n            } else {\n                instance = objMap.get(item.getIdentifier());\n            }\n            if (instance != null) {\n                result.add(populateObject(item, objMap, useIdentifier, abortOnError,\n                                          instance));\n            }\n        }\n\n        return result;\n    }"}, {"signature": "protected static FastPathObject populateObject(Item item, Map<String, FastPathObject> objMap,\n            boolean useIdentifier, boolean abortOnError, FastPathObject obj) \n}", "full": "protected static FastPathObject populateObject(Item item, Map<String, FastPathObject> objMap,\n            boolean useIdentifier, boolean abortOnError, FastPathObject obj) {\n        try {\n            for (Attribute attr : item.getAttributes()) {\n                String attrName = attr.getName();\n                if (!(\"id\".equals(attrName))) {\n                    Class<?> attrClass;\n                    try {\n                        attrClass = obj.getFieldType(attrName);\n                        if (attrClass == null) {\n                            String message = \"Class '\" + attrClass + \"' not found for \"\n                                + Util.getFriendlyName(obj.getClass());\n                            throw new IllegalArgumentException(message);\n                        }\n                    } catch (IllegalArgumentException e) {\n                        String message = \"Field \" + attr.getName() + \" not found in \"\n                            + Util.getFriendlyName(obj.getClass());\n                        throw new IllegalArgumentException(message);\n                    }\n                    if (ClobAccess.class.equals(attrClass)) {\n                        obj.setFieldValue(attr.getName(), new PendingClob(attr.getValue()));\n                    } else {\n                        String value = attr.getValue();\n                        if (value != null) {\n                            obj.setFieldValue(attr.getName(), TypeUtil.stringToObject(attrClass,\n                                    value));\n                        } else {\n                            String message = \"Field '\" + attr.getName() + \"' has NULL value in \"\n                                + Util.getFriendlyName(obj.getClass());\n                            throw new IllegalArgumentException(message);\n                        }\n                    }\n                }\n            }\n\n            if (useIdentifier) {\n                obj.setFieldValue(\"id\", TypeUtil.stringToObject(Integer.class,\n                            item.getIdentifier()));\n            }\n\n            for (Reference ref : item.getReferences()) {\n                Object refObj = objMap.get(ref.getRefId());\n                String refName = ref.getName();\n                Class<?> refClass;\n                try {\n                    refClass = obj.getFieldType(refName);\n                } catch (IllegalArgumentException e) {\n                    String message = \"Field \" + ref.getName() + \" not found in \"\n                        + Util.getFriendlyName(obj.getClass());\n                    if (abortOnError) {\n                        throw new IllegalArgumentException(message);\n                    } else {\n                        LOG.warn(message);\n                        continue;\n                    }\n                }\n                if (!InterMineObject.class.isAssignableFrom(refClass)) {\n                    if (abortOnError) {\n                        throw new IllegalArgumentException(\"Looking for a reference, but found a \"\n                                + refClass.getName());\n                    } else {\n                        LOG.warn(\"Looking for a reference, but found a \" + refClass.getName());\n                        continue;\n                    }\n                }\n                if (refObj == null) {\n                    LOG.warn(\"no field \" + ref.getName() + \" in object: \" + obj);\n                } else {\n                    try {\n                        obj.setFieldValue(ref.getName(), refObj);\n                    } catch (IllegalArgumentException e) {\n                        if (abortOnError) {\n                            throw e;\n                        } else {\n                            LOG.warn(\"Failed to set field: \" + e);\n                        }\n                    }\n                }\n            }\n\n            for (ReferenceList refList : item.getCollections()) {\n                @SuppressWarnings(\"unchecked\") Collection<Object> col\n                    = (Collection<Object>) obj.getFieldValue(refList.getName());\n                for (String refId : refList.getRefIds()) {\n                    col.add(objMap.get(refId));\n                }\n            }\n\n        } catch (IllegalAccessException e) {\n            }\n\n        return obj;\n    }\n}"}], "class_attributes": [{"type": "Logger", "name": "LOG"}]}
