{"id": 263287, "method": "@Override\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }", "summary": "Answers a copy of this object.", "signature": "public Object clone()"}
{"id": 400908, "method": "@Override\n    public IPieDataSet getDataSetByIndex(int index) {\n        return index == 0 ? getDataSet() : null;\n    }", "summary": "The PieData object can only have one DataSet.", "signature": "public IPieDataSet getDataSetByIndex(int index)"}
{"id": 400883, "method": "@Transactional\n    public Bag updateBagInDatabase(Long bagId,\n                                   final BagWrapper wrapper,\n                                   final String md5sum,\n                                   final Map<String, Long> missingBagMd5sums,\n                                   final String locationName,\n                                   final List<GpsPosition> gpsPositions,\n                                   final String storageId)\n            throws DuplicateBagException, BagReaderException {\n        Bag bag;\n        if (bagId == null) {\n            bag = insertNewBag(wrapper, md5sum, locationName, gpsPositions, storageId);\n        }\n        else {\n            if (missingBagMd5sums.remove(md5sum) != null) {\n                myLogger.info(\"Missing bag was found.\");\n            }\n            else {\n                myLogger.info(\"Force updating bag info.\");\n            }\n            bag = myBagRepository.findById(bagId).orElseThrow();\n            bag.setPath(wrapper.getPath());\n            bag.setFilename(wrapper.getFilename());\n            bag.setMissing(false);\n            bag.setMd5sum(md5sum);\n            bag.setStorageId(storageId);\n            addTagsToBag(wrapper.getBagFile(), bag);\n        }\n        myBagRepository.save(bag);\n        String msg = \"Committing: \" + wrapper.getPath() + wrapper.getFilename();\n        myLogger.debug(msg);\n        reportStatus(Status.State.WORKING, msg);\n\n        return bag;\n    }", "summary": "Inserts a new bag or updates an existing bag in the database.", "signature": "public Bag updateBagInDatabase(Long bagId,\n                                   final BagWrapper wrapper,\n                                   final String md5sum,\n                                   final Map<String, Long> missingBagMd5sums,\n                                   final String locationName,\n                                   final List<GpsPosition> gpsPositions,\n                                   final String storageId)\n            throws DuplicateBagException, BagReaderException"}
{"id": 1680576, "method": "public String getTypeDescriptor(\n            CallStack callstack, Interpreter interpreter, String defaultPackage) {\n        if (descriptor != null) {\n            return descriptor;\n        }\n\n        String descriptor;\n        SimpleNode node = getTypeNode();\n        if (node instanceof BSHPrimitiveType) {\n            descriptor = getTypeDescriptor(((BSHPrimitiveType) node).type);\n        } else {\n            String clasName = ((BSHAmbiguousName) node).text;\n            BSHClassManager bcm = interpreter.getClassManager();\n            String definingClass = bcm.getClassBeingDefined(clasName);\n\n            Class clas = null;\n            if (definingClass == null) {\n                try {\n                    clas = ((BSHAmbiguousName) node).toClass(\n                            callstack, interpreter);\n                } catch (EvalError e) {\n                    }\n            } else {\n                clasName = definingClass;\n            }\n\n            if (clas != null) {\n                descriptor = getTypeDescriptor(clas);\n            } else {\n                if (defaultPackage == null || Name.isCompound(clasName)) {\n                    descriptor = \"L\" + clasName.replace('.', '/') + \";\";\n                } else {\n                    descriptor\n                            = \"L\" + defaultPackage.replace('.', '/') + \"/\" + clasName + \";\";\n                }\n            }\n        }\n\n        for (int i = 0; i < arrayDims; i++) {\n            descriptor = \"[\" + descriptor;\n        }\n\n        this.descriptor = descriptor;\n        return descriptor;\n    }", "summary": "Returns a class descriptor for this type.", "signature": "public String getTypeDescriptor(\n            CallStack callstack, Interpreter interpreter, String defaultPackage)"}
{"id": 1888819, "method": "public static boolean exists(String file) {\n        return Files.exists(Paths.get(file));\n    }\n}", "summary": "Checks if the specified file path belongs to a file.", "signature": "public static boolean exists(String file) \n}"}
{"id": 1968305, "method": "public long countComplete() {\n        return Query.fromAll()\n                .where(\"cms.workstream.completeIds ^= ?\", getId().toString() + \",\")\n                .count();\n    }", "summary": "Returns the number of items completed.", "signature": "public long countComplete()"}
{"id": 2093621, "method": "private JsonWriter close(int empty, int nonempty, String closeBracket)\n        throws IOException {\n        int context = peek();\n        if (context != nonempty && context != empty) {\n            throw new IllegalStateException(\"Nesting problem.\");\n        }\n        if (deferredName != null) {\n            throw new IllegalStateException(\"Dangling name: \" + deferredName);\n        }\n\n        stackSize--;\n        if (context == nonempty) {\n            newline();\n        }\n        out.write(closeBracket);\n        return this;\n    }", "summary": "Closes the current scope by appending any necessary whitespace and the given bracket.", "signature": "private JsonWriter close(int empty, int nonempty, String closeBracket)\n        throws IOException"}
{"id": 2125149, "method": "public com.anychart.core.annotations.TrendChannel markers(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".markers(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }", "summary": "Setter for data markers.", "signature": "public com.anychart.core.annotations.TrendChannel markers(String settings)"}
{"id": 2238897, "method": "@Override\n    public SimplePipelineExecutor<R,P> waitFor()\n            throws InterruptedException, ExecutionException {\n        if (executorService == null || pipelines == null || futures == null || futures.isEmpty()) {\n            return this;\n        }\n        exceptions = new LinkedList<>();\n        for (Future<R> future : futures) {\n            R r = future.get();\n            if (sink != null && !future.isCancelled()) {\n                try {\n                    sink.sink(r);\n                } catch (IOException e) {\n                    exceptions.add(e);\n                }\n            }\n        }\n        return this;\n    }", "summary": "Wait for all results of the executions.", "signature": "public SimplePipelineExecutor<R,P> waitFor()\n            throws InterruptedException, ExecutionException"}
{"id": 2261769, "method": "public String toStringWithPrivate() {\n        StringBuilder b = new StringBuilder();\n        b.append(toString());\n        if (privKey != null && privKey instanceof BCECPrivateKey) {\n            b.append(\" priv:\").append(Hex.toHexString(((BCECPrivateKey)\n                    privKey).getD().toByteArray()));\n        }\n        return b.toString();\n    }", "summary": "Produce a string rendering of the ECKey INCLUDING the private key.", "signature": "public String toStringWithPrivate()"}
{"id": 2344580, "method": "public void removePlayerScoreboard(Player player) {\n        if (PLAYER_SCOREBOARDS.containsKey(player.getUniqueId())) {\n            PLAYER_SCOREBOARDS.remove(player.getUniqueId());\n        }\n    }\n}", "summary": "Removes the player from the scoreboard hashmap.", "signature": "public void removePlayerScoreboard(Player player) \n}"}
{"id": 2364685, "method": "void save(String filename) throws FileNotFoundException,\n\t\t\tUnsupportedEncodingException {\n\t\tPrintWriter out = new PrintWriter(new BufferedWriter(\n\t\t\t\tnew OutputStreamWriter(new FileOutputStream(filename), \"UTF8\")));\n\n\t\tfor (int i = 0; i < _ccpds.size(); i++) {\n\t\t\tout.println(\"% CCPDs for State \" + getStateName(i));\n\n\t\t\tMap<Variable, Function> ccpds = _ccpds.get(i);\n\t\t\tfor (Variable manifest : ccpds.keySet()) {\n\t\t\t\tout.print(manifest.getName());\n\t\t\t\tfor (double prob : ccpds.get(manifest).getCells()) {\n\t\t\t\t\tout.print(\" \" + prob);\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\n\t\tout.println(\"% CMI Tree in Pre-Order\");\n\t\tout.println(toPreOrderString());\n\n\t\tout.println(\"% Largest Maximum CMI Percent\");\n\t\tout.println(_largestMaxCmiPercent);\n\n\t\tout.println(\"% Natural Order of Manifest Variables\");\n\t\tfor (Variable manifest : _order) {\n\t\t\tout.print(manifest.getName() + \" \");\n\t\t}\n\t\tout.println();\n\n\t\tout.println(\"% PMI\");\n\t\tfor (Variable manifest : _pmi.keySet()) {\n\t\t\tout.println(manifest.getName() + \" \" + _pmi.get(manifest));\n\t\t}\n\n\t\tout.println(\"% Prior Distribution\");\n\n\t\tfor (Variable latent : _prior.getVariables()) {\n\t\t\tout.print(latent.getName() + \" \");\n\t\t}\n\t\tout.println();\n\n\t\tfor (double prob : _prior.getCells()) {\n\t\t\tout.print(prob + \" \");\n\t\t}\n\t\tout.println();\n\n\t\tout.println(\"% Selected Manifest Variables\");\n\t\tfor (Variable manifest : _selectedManifests) {\n\t\t\tout.print(manifest.getName() + \" \");\n\t\t}\n\t\tout.println();\n\n\t\tout.println(\"% Selected Maximum CMI Percent\");\n\t\tout.println(_selectedMaxCmiPercent);\n\n\t\tout.println(\"% TMI\");\n\t\tout.println(_tmi);\n\n\t\tout.close();\n\t}", "summary": "Saves the analysis result to the specified file.", "signature": "void save(String filename) throws FileNotFoundException,\n\t\t\tUnsupportedEncodingException"}
{"id": 2390056, "method": "public com.anychart.core.ui.Legend tooltip(String settings) {\n        APIlib.getInstance().addJSLine(String.format(Locale.US, jsBase + \".tooltip(%s);\", wrapQuotes(settings)));\n\n        return this;\n    }", "summary": "Setter for legend tooltip.", "signature": "public com.anychart.core.ui.Legend tooltip(String settings)"}
{"id": 2645549, "method": "public ASortedMap<K,V> append(K key, V value) {\n\t\tput(key, value);\n\t\treturn this;\n\t}", "summary": "Adds an entry to this map.", "signature": "public ASortedMap<K,V> append(K key, V value)"}
{"id": 2752281, "method": "public MethodExecStats getStats() {\n\t\treturn stats;\n\t}\n}", "summary": "Returns the stats of this method invoker.", "signature": "public MethodExecStats getStats() \n}"}
{"id": 2878100, "method": "@Deprecated\n    public void setRevalidationQueueSize(final int size) {\n        this.revalidationQueueSize = size;\n    }", "summary": "Sets the current maximum queue size for background revalidations.", "signature": "public void setRevalidationQueueSize(final int size)"}
{"id": 2957999, "method": "@Override\n    @NonNull\n    @Input\n    public Set<String> getMerges() {\n        return Sets.newHashSet(merges);\n    }", "summary": "Returns the list of paths where all occurrences are concatenated and packaged in the APK.", "signature": "public Set<String> getMerges()"}
{"id": 4118692, "method": "public CountingInputStream(final InputStream stream) {\n        super(stream);\n        this.markPos = 0;\n        this.readCount = 0;\n    }", "summary": "Creates an instance, which delegates the commands to the given stream.", "signature": "public CountingInputStream(final InputStream stream)"}
{"id": 4204781, "method": "protected void onTrackSegmentStart() {\n    trackData.numberOfSegments++;\n\n    if (trackData.numberOfSegments > 1 && trackData.lastLocationInCurrentSegment != null) {\n      insertLocation(createLocation(TrackRecordingService.PAUSE_LATITUDE, 0.0, 0.0,\n          trackData.lastLocationInCurrentSegment.getTime()));\n    }\n    trackData.lastLocationInCurrentSegment = null;\n  }", "summary": "On track segment start.", "signature": "protected void onTrackSegmentStart()"}
{"id": 4350479, "method": "public SignatureRequest(String signatureType, String objectKey) {\n        setSignatureType(signatureType);\n        this.objectKey = objectKey;\n    }", "summary": "Constructs a signature request for an operation on a specific object key.", "signature": "public SignatureRequest(String signatureType, String objectKey)"}
{"id": 4413079, "method": "@WebMethod(operationName = \"GetCompatibleMetadataConfigurations\", action = \"http://www.onvif.org/ver10/media/wsdl/GetCompatibleMetadataConfigurations\")\n    @RequestWrapper(localName = \"GetCompatibleMetadataConfigurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleMetadataConfigurations\")\n    @ResponseWrapper(localName = \"GetCompatibleMetadataConfigurationsResponse\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\", className = \"org.onvif.ver10.media.wsdl.GetCompatibleMetadataConfigurationsResponse\")\n    @WebResult(name = \"Configurations\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n    public java.util.List<org.onvif.ver10.schema.MetadataConfiguration> getCompatibleMetadataConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );", "summary": "This operation requests all the metadata configurations of the device that are compatible with a certain media profile.", "signature": "public java.util.List<org.onvif.ver10.schema.MetadataConfiguration> getCompatibleMetadataConfigurations(\n\n        @WebParam(name = \"ProfileToken\", targetNamespace = \"http://www.onvif.org/ver10/media/wsdl\")\n        java.lang.String profileToken\n    );"}
{"id": 4497632, "method": "@Override\n    public Optional<XMLObject> get(final String messageID) {\n        final var messages = getMessages();\n        final var o = messages.get(messageID);\n        if (o == null) {\n            log.debug(\"Message {} not found in session {}\", messageID, sessionStore.getSessionId(context, true).get());\n            return Optional.empty();\n        }\n\n        log.debug(\"Message {} found in session {}, clearing\", messageID, sessionStore.getSessionId(context, true).get());\n        messages.clear();\n        updateSession(messages);\n\n        return Configuration.deserializeSamlObject(o);\n    }", "summary": "Returns previously stored message with the given ID or null, if there is no message stored.", "signature": "public Optional<XMLObject> get(final String messageID)"}
{"id": 4741787, "method": "@VisibleForTesting\n    public ControllerServiceStarter awaitServicePausing() {\n        monitor.enterWhenUninterruptibly(hasReachedPausing);\n        try {\n            if (serviceState != ServiceState.PAUSING) {\n                throw new IllegalStateException(\"Expected state=\" + ServiceState.PAUSING +\n                        \", but actual state=\" + serviceState);\n            } else {\n                return this.starter;\n            }\n        } finally {\n            monitor.leave();\n        }\n    }", "summary": "Awaits until the internal state changes to PAUSING, and returns the reference of current ControllerServiceStarter.", "signature": "public ControllerServiceStarter awaitServicePausing()"}
{"id": 4826210, "method": "public int writeCharacteristic(BluetoothGattCharacteristic characteristic) {\n        if(DEBUG) {\n            logi(\"writeCharacteristic() :: start\");\n        }\n\n        int rc = BLE_ERROR_NOOP;\n\n        synchronized(locker) {\n            if(gatt != null && inBleOp == OP_NOOP) {\n                inBleOp = OP_WRITE_CHARACTERISTIC;\n                lastCharacteristic = null;\n                error = 0;\n                try {\n                    callbackCompleted = false;\n                    if(gatt.writeCharacteristic(characteristic)) {\n                        locker.wait(BLE_WAIT_TIMEOUT);\n                        if(!callbackCompleted) {\n                            error = (BLE_ERROR_FAIL | BLE_ERROR_TIMEOUT);\n                        }\n\n                        rc = error | bleState;\n                    } else {\n                        if(DEBUG) {\n                            logi(\"writeCharacteristic() :: failed\");\n                        }\n                    }\n\n\n                } catch(InterruptedException e) {\n                    Log.e(TAG, e.toString());\n                }\n\n                inBleOp = OP_NOOP;\n            } else {\n                logi(\"Couldn't write to characteristic\");\n            }\n\n        }\n\n        if(DEBUG) {\n            logi(\"writeCharacteristic() :: end : rc = \" + rc);\n        }\n\n        return rc;\n    }", "summary": "Write characteristic to connected GATT device.", "signature": "public int writeCharacteristic(BluetoothGattCharacteristic characteristic)"}
{"id": 4880569, "method": "public static final AuthorityInfoAccessFactory create() {\n        AuthorityInfoAccessFactory aiaf = new AuthorityInfoAccessFactory();\n        return aiaf;\n    }", "summary": "Begin defining the authority info access extension.", "signature": "public static final AuthorityInfoAccessFactory create()"}
{"id": 5263027, "method": "protected boolean isCacheable(RenderContext renderContext, String key, Resource resource, Properties fragmentProperties) throws RepositoryException {\n\n        if (cacheProvider.isNonCacheableFragment(key)) {\n            return false;\n        }\n\n        final String cacheExpiration = fragmentProperties.getProperty(CacheUtils.FRAGMNENT_PROPERTY_CACHE_EXPIRATION);\n        Long expiration = cacheExpiration != null ? Long.parseLong(cacheExpiration) : -1;\n        return expiration != 0L;\n    }", "summary": "Is the current fragment cacheable or not.", "signature": "protected boolean isCacheable(RenderContext renderContext, String key, Resource resource, Properties fragmentProperties) throws RepositoryException"}
{"id": 5589100, "method": "public PrintfFormat(String fmtArg)\n      throws IllegalArgumentException {\n    this(Locale.getDefault(),fmtArg);\n  }", "summary": "Constructs an array of control specifications possibly preceded, separated, or followed by ordinary strings.", "signature": "public PrintfFormat(String fmtArg)\n      throws IllegalArgumentException"}
{"id": 5760917, "method": "public LogTypes(final JMenu menu, final int selectedIndex) {\n        final ButtonGroup logFileGroup = new ButtonGroup();\n        logFileGroup.add(logRadio);\n        logFileGroup.add(txtRadio);\n        logFileGroup.add(csvRadio);\n        logFileGroup.add(yamlRadio);\n\n        menu.add(logRadio);\n        menu.add(txtRadio);\n        menu.add(csvRadio);\n        menu.add(yamlRadio);\n\n        logRadio.setBackground(WHITE);\n        txtRadio.setBackground(WHITE);\n        csvRadio.setBackground(WHITE);\n        yamlRadio.setBackground(WHITE);\n\n        if (selectedIndex < 0 || selectedIndex > 3) {\n            throw new RuntimeException(format(\"Log type index %s out of bounds\", selectedIndex));\n        }\n        selectLogType(selectedIndex);\n    }", "summary": "Initializes log type menu items and selects one by index.", "signature": "public LogTypes(final JMenu menu, final int selectedIndex)"}
{"id": 5874750, "method": "void checkAndBindMetrics(MeterRegistry registry) {\n        this.metrics.set(this.metricsSupplier.get());\n        Map<MetricName, ? extends Metric> metrics = this.metrics.get();\n\n        if (!currentMeters.equals(metrics.keySet())) {\n            currentMeters = new HashSet<>(metrics.keySet());\n\n            Map<String, List<Meter>> registryMetersByNames = registry.getMeters().stream()\n                    .collect(Collectors.groupingBy(meter -> meter.getId().getName()));\n\n            metrics.forEach((name, metric) -> {\n                if (!(metric.metricValue() instanceof Number) ||\n                        METRIC_GROUP_APP_INFO.equals(name.group()) ||\n                        METRIC_GROUP_METRICS_COUNT.equals(name.group())) {\n                    return;\n                }\n\n                String meterName = meterName(metric);\n\n                boolean hasLessTags = false;\n                for (Meter other : registryMetersByNames.getOrDefault(meterName, emptyList())) {\n                    List<Tag> tags = other.getId().getTags();\n                    List<Tag> meterTagsWithCommonTags = meterTags(metric, true);\n                    if (tags.size() < meterTagsWithCommonTags.size()) {\n                        registry.remove(other);\n                        registeredMeters.remove(other);\n                    }\n                    else if (tags.size() == meterTagsWithCommonTags.size())\n                        if (tags.containsAll(meterTagsWithCommonTags)) return;\n                        else break;\n                    else hasLessTags = true;\n                }\n                if (hasLessTags) return;\n\n                List<Tag> tags = meterTags(metric);\n                try {\n                    Meter meter = bindMeter(registry, metric.metricName(), meterName, tags);\n                    List<Meter> meters = registryMetersByNames.computeIfAbsent(meterName, k -> new ArrayList<>());\n                    meters.add(meter);\n                }\n                catch (Exception ex) {\n                    String message = ex.getMessage();\n                    if (message != null && message.contains(\"Prometheus requires\")) {\n                        warnThenDebugLogger.log(\"Failed to bind meter: \" + meterName + \" \" + tags\n                                + \". However, this could happen and might be restored in the next refresh.\");\n                    }\n                    else {\n                        log.warn(\"Failed to bind meter: \" + meterName + \" \" + tags + \".\", ex);\n                    }\n                }\n            });\n        }\n    }", "summary": "Gather metrics from Kafka metrics API and register Meters.", "signature": "void checkAndBindMetrics(MeterRegistry registry)"}
{"id": 5926526, "method": "private void makeWithdraw()\n    {\n        System.out.println(\"\");\n        System.out.println(\"- Withrdaw from an Account -\");\n        System.out.println(\"-------------------\");\n        System.out.println(\"\");\n\n        System.out.print(\"Give the Account name : \");\n        String name_debit = input();\n        if (name_debit == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        System.out.print(\"Amount to withdraw : \");\n        String amount = input();\n        if (amount == null)\n        {\n            System.out.println(\"Abort operation...\");\n            return;\n        }\n\n        float famount = 0;\n        try\n        {\n            famount = new Float(amount).floatValue();\n        }\n        catch (java.lang.Exception ex)\n        {\n            System.out.println(\"Invalid float number, abort operation...\");\n            return;\n        }\n\n        try\n        {\n            Current current = OTSManager.get_current();\n            System.out.println(\"Beginning a User transaction to withdraw from an account\");\n            current.begin();\n            try\n            {\n                Account debiter = _bank.get_account(name_debit);\n                debiter.debit(current.get_control(), famount);\n            }\n            catch (NotExistingAccount nea)\n            {\n                System.out.println(\"The requested account does not exist!\");\n                current.rollback_only();\n            }\n            current.commit(false);\n        }\n        catch (Exception e)\n        {\n            System.err.println(\"ERROR - \" + e);\n        }\n    }", "summary": "This operation is used to withdraw money from an account.", "signature": "private void makeWithdraw()"}
{"id": 5946322, "method": "public boolean recovered(Object txID, int txType)\n    {\n        if (isLockID(txID)) {\n            rollbackPreparedTx = false;\n            return true;\n        }\n\n        return false;\n    }", "summary": "called by the AT and BA recovery modules to notify the manager that a participant associated with a specific AT or BA transaction has been recovered from a participant log record.", "signature": "public boolean recovered(Object txID, int txType)"}
{"id": 6127949, "method": "public PixelCalibration createScaledInstance(double scaleX, double scaleY, double scaleZ) {\n\t\tPixelCalibration cal2 = duplicate();\n\t\tcal2.pixelWidth = pixelWidth.scale(scaleX);\n\t\tcal2.pixelHeight = pixelHeight.scale(scaleY);\n\t\tcal2.zSpacing = zSpacing.scale(scaleZ);\n\t\treturn cal2;\n\t}", "summary": "Get a scaled instance of this PixelCalibration, multiplying pixel sizes for x, y and z by the specified scale values.", "signature": "public PixelCalibration createScaledInstance(double scaleX, double scaleY, double scaleZ)"}
{"id": 6367455, "method": "@GetMapping(value = \"/rate/all\", produces = \"application/json; charset=UTF-8\")\n    @ApiOperation(value = \"\u00e8\u008e\u00b7\u00e5\u008f\u0096USD\u00e5\u00af\u00b9\u00e5\u00ba\u0094\u00e6\u00b1\u0087\u00e7\u008e\u0087\")\n    public Map<String, Object> getCurrencyRate(\n        @ApiParam(required = true, value = \"\u00e7\u0089\u0088\u00e6\u009c\u00ac\", defaultValue = \"v1\") @PathVariable(\"version\") String version\n    ) {\n        Map<String, String> rate = currencyRateService.getRate();\n        Map<String, Object> message = new HashMap<>();\n        message.put(Message.RETURN_FIELD_CODE, ReturnCode.SUCCESS);\n        message.put(Message.RETURN_FIELD_DATA, rate);\n        return message;\n    }\n\n}", "summary": "Gets currency rate.", "signature": "public Map<String, Object> getCurrencyRate(\n        @ApiParam(required = true, value = \"\u00e7\u0089\u0088\u00e6\u009c\u00ac\", defaultValue = \"v1\") @PathVariable(\"version\") String version\n    ) \n\n}"}
{"id": 7037335, "method": "@Override\n\tpublic void setValue(Object value) throws IllegalArgumentException {\n\t\tif (value instanceof Collection || (value instanceof Object[] && !(value instanceof Resource[]))) {\n\t\t\tCollection<?> input = (value instanceof Collection ? (Collection<?>) value : Arrays.asList((Object[]) value));\n\t\t\tList<Resource> merged = new ArrayList<>();\n\t\t\tfor (Object element : input) {\n\t\t\t\tif (element instanceof String) {\n\t\t\t\t\tString pattern = resolvePath((String) element).trim();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tResource[] resources = this.resourcePatternResolver.getResources(pattern);\n\t\t\t\t\t\tfor (Resource resource : resources) {\n\t\t\t\t\t\t\tif (!merged.contains(resource)) {\n\t\t\t\t\t\t\t\tmerged.add(resource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Could not retrieve resources for pattern '\" + pattern + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (element instanceof Resource) {\n\t\t\t\t\tResource resource = (Resource) element;\n\t\t\t\t\tif (!merged.contains(resource)) {\n\t\t\t\t\t\tmerged.add(resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot convert element [\" + element + \"] to [\" +\n\t\t\t\t\t\t\tResource.class.getName() + \"]: only location String and Resource object supported\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuper.setValue(merged.toArray(new Resource[0]));\n\t\t}\n\n\t\telse {\n\t\t\tsuper.setValue(value);\n\t\t}\n\t}", "summary": "Treat the given value as a collection or array and convert it to a Resource array.", "signature": "public void setValue(Object value) throws IllegalArgumentException"}
{"id": 7051733, "method": "public static int drain(InputStream in) throws IOException {\n\t\tAssert.notNull(in, \"No InputStream specified\");\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\tint bytesRead = -1;\n\t\tint byteCount = 0;\n\t\twhile ((bytesRead = in.read(buffer)) != -1) {\n\t\t\tbyteCount += bytesRead;\n\t\t}\n\t\treturn byteCount;\n\t}", "summary": "Drain the remaining content of the given InputStream.", "signature": "public static int drain(InputStream in) throws IOException"}
{"id": 7437666, "method": "public static RestTemplate buildRestTemplateWithAuth(String endpoint, String username, String password) {\n        RestTemplate restTemplate = buildLoggingRestTemplate(endpoint);\n        restTemplate.getInterceptors().add(new BasicAuthorizationInterceptor(username, password));\n        return restTemplate;\n    }", "summary": "Build rest template with enabled logging support and basic auth.", "signature": "public static RestTemplate buildRestTemplateWithAuth(String endpoint, String username, String password)"}
{"id": 7584847, "method": "HuffmanDecoder(int[] codes, byte[] lengths) {\n    if (codes.length != 257 || codes.length != lengths.length) {\n      throw new IllegalArgumentException(\"invalid Huffman coding\");\n    }\n    root = buildTree(codes, lengths);\n  }", "summary": "Creates a new Huffman decoder with the specified Huffman coding.", "signature": "HuffmanDecoder(int[] codes, byte[] lengths)"}
{"id": 8901418, "method": "boolean[] initBoolArray(int len) {\n    boolean[] boolArray = new boolean [len];\n    for (int i = 0; i < len; i++) {\n      boolArray[i] = false;\n    }\n    return boolArray;\n  }", "summary": "Creates and initializes boolean array.", "signature": "boolean[] initBoolArray(int len)"}
{"id": 9168402, "method": "public final void add(ETrafficLightColor color, int count) {\n\t\tif (count < 0) {\n\t\t\tthrow new IllegalArgumentException(\"Count must be non-negative!\");\n\t\t}\n\t\tmapping[color.ordinal()] += count;\n\t}", "summary": "Add a single entry of this color to this assessment.", "signature": "public final void add(ETrafficLightColor color, int count)"}
{"id": 9222702, "method": "public static List<FastPathObject> realiseObjects(Collection<Item> items, Model model,\n                                                       boolean useIdentifier)\n        throws ClassNotFoundException {\n        return realiseObjects(items, model, useIdentifier, true);\n    }", "summary": "Create business objects from a collection of Items.", "signature": "public static List<FastPathObject> realiseObjects(Collection<Item> items, Model model,\n                                                       boolean useIdentifier)\n        throws ClassNotFoundException"}
